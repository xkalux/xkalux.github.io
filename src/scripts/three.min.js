!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.THREE = t.THREE || {}) }(this, (function (t) { "use strict"; function e() { } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (null != n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }), Object.assign(e.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); var i = this._listeners; void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; var i = this._listeners; return void 0 !== i[t] && -1 !== i[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 !== this._listeners) { var i = this._listeners[t]; if (void 0 !== i) { var n = i.indexOf(e); -1 !== n && i.splice(n, 1) } } }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; var i = [], n = 0, r = e.length; for (n = 0; n < r; n++)i[n] = e[n]; for (n = 0; n < r; n++)i[n].call(this, t) } } } }); var i, n, r, a, o, s, c = 0, h = 1, l = 2, u = 1, p = 2, d = 0, f = 1, m = 2, g = 1, v = 2, y = 0, x = 0, _ = 1, w = 2, b = 3, M = 4, E = 5, T = 100, S = 204, A = 205, L = 0, R = 1, P = 2, C = 3, U = 4, I = 5, D = 6, N = 7, F = 0, O = 1, z = 2, B = 0, G = 1, H = 2, V = 3, k = 4, j = 301, W = 302, X = 303, Y = 304, q = 305, Z = 306, J = 307, Q = 1e3, K = 1001, $ = 1002, tt = 1003, et = 1004, it = 1005, nt = 1006, rt = 1008, at = 1009, ot = 1012, st = 1015, ct = 1016, ht = 1022, lt = 1023, ut = lt, pt = 1026, dt = 1027, ft = 2300, mt = 2301, gt = 2302, vt = 2400, yt = 2401, xt = 2402, _t = 0, wt = 3e3, bt = 3001, Mt = 3007, Et = 3002, Tt = 3004, St = 3005, At = 3006, Lt = 3200, Rt = 3201; function Pt(t, e) { this.x = t || 0, this.y = e || 0 } function Ct(e, i, n, r, a, o, s, c, h, l) { Object.defineProperty(this, "id", { value: Gt() }), this.uuid = t.Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== e ? e : Ct.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== i ? i : Ct.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : K, this.wrapT = void 0 !== r ? r : K, this.magFilter = void 0 !== a ? a : nt, this.minFilter = void 0 !== o ? o : rt, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== s ? s : lt, this.type = void 0 !== c ? c : at, this.offset = new Pt(0, 0), this.repeat = new Pt(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : wt, this.version = 0, this.onUpdate = null } t.Math = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: (n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), r = new Array(36), a = 0, function () { for (var t = 0; t < 36; t++)8 === t || 13 === t || 18 === t || 23 === t ? r[t] = "-" : 14 === t ? r[t] = "4" : (a <= 2 && (a = 33554432 + 16777216 * Math.random() | 0), i = 15 & a, a >>= 4, r[t] = n[19 === t ? 3 & i | 8 : i]); return r.join("") }), clamp: function (t, e, i) { return Math.max(e, Math.min(i, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, i, n, r) { return n + (t - e) * (r - n) / (i - e) }, smoothstep: function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10) }, random16: function () { return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random() }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, degToRad: function (e) { return e * t.Math.DEG2RAD }, radToDeg: function (e) { return e * t.Math.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, nearestPowerOfTwo: function (t) { return Math.pow(2, Math.round(Math.log(t) / Math.LN2)) }, nextPowerOfTwo: function (t) { return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t } }, Pt.prototype = { constructor: Pt, isVector2: !0, get width() { return this.x }, set width(t) { this.x = t }, get height() { return this.y }, set height(t) { this.y = t }, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.x = t, this.y = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: function (t, e) { return void 0 === o && (o = new Pt, s = new Pt), o.set(t, t), s.set(e, e), this.clamp(o, s) }, clampLength: function (t, e) { var i = this.length(); return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length()) }, angle: function () { var t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, i = this.y - t.y; return e * e + i * i }, distanceToManhattan: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromAttribute: function (t, e, i) { return void 0 === i && (i = 0), e = e * t.itemSize + i, this.x = t.array[e], this.y = t.array[e + 1], this }, rotateAround: function (t, e) { var i = Math.cos(e), n = Math.sin(e), r = this.x - t.x, a = this.y - t.y; return this.x = r * i - a * n + t.x, this.y = r * n + a * i + t.y, this } }, Ct.DEFAULT_IMAGE = void 0, Ct.DEFAULT_MAPPING = 300, Ct.prototype = { constructor: Ct, isTexture: !0, set needsUpdate(t) { !0 === t && this.version++ }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (e) { if (void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; var i = { metadata: { version: 4.4, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], wrap: [this.wrapS, this.wrapT], minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY }; if (void 0 !== this.image) { var n = this.image; void 0 === n.uuid && (n.uuid = t.Math.generateUUID()), void 0 === e.images[n.uuid] && (e.images[n.uuid] = { uuid: n.uuid, url: function (t) { var e; return void 0 !== t.toDataURL ? e = t : ((e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)), e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") }(n) }), i.image = n.uuid } return e.textures[this.uuid] = i, i }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 === this.mapping) { if (t.multiply(this.repeat), t.add(this.offset), t.x < 0 || t.x > 1) switch (this.wrapS) { case Q: t.x = t.x - Math.floor(t.x); break; case K: t.x = t.x < 0 ? 0 : 1; break; case $: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case Q: t.y = t.y - Math.floor(t.y); break; case K: t.y = t.y < 0 ? 0 : 1; break; case $: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }this.flipY && (t.y = 1 - t.y) } } }, Object.assign(Ct.prototype, e.prototype); var Ut, It, Dt, Nt, Ft, Ot, zt, Bt = 0; function Gt() { return Bt++ } function Ht() { this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } function Vt(t, e, i, n) { this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1 } function kt(t, e, i) { this.x = t || 0, this.y = e || 0, this.z = i || 0 } function jt(t, e) { var i, n, r, a, o, s, c = t.context, h = t.state, l = new kt, u = new Vt, p = new kt; function d() { var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), h = new Uint16Array([0, 1, 2, 0, 2, 3]); i = c.createBuffer(), n = c.createBuffer(), c.bindBuffer(c.ARRAY_BUFFER, i), c.bufferData(c.ARRAY_BUFFER, e, c.STATIC_DRAW), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, n), c.bufferData(c.ELEMENT_ARRAY_BUFFER, h, c.STATIC_DRAW), r = function () { var e = c.createProgram(), i = c.createShader(c.VERTEX_SHADER), n = c.createShader(c.FRAGMENT_SHADER); return c.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), c.shaderSource(n, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), c.compileShader(i), c.compileShader(n), c.attachShader(e, i), c.attachShader(e, n), c.linkProgram(e), e }(), a = { position: c.getAttribLocation(r, "position"), uv: c.getAttribLocation(r, "uv") }, o = { uvOffset: c.getUniformLocation(r, "uvOffset"), uvScale: c.getUniformLocation(r, "uvScale"), rotation: c.getUniformLocation(r, "rotation"), scale: c.getUniformLocation(r, "scale"), color: c.getUniformLocation(r, "color"), map: c.getUniformLocation(r, "map"), opacity: c.getUniformLocation(r, "opacity"), modelViewMatrix: c.getUniformLocation(r, "modelViewMatrix"), projectionMatrix: c.getUniformLocation(r, "projectionMatrix"), fogType: c.getUniformLocation(r, "fogType"), fogDensity: c.getUniformLocation(r, "fogDensity"), fogNear: c.getUniformLocation(r, "fogNear"), fogFar: c.getUniformLocation(r, "fogFar"), fogColor: c.getUniformLocation(r, "fogColor"), alphaTest: c.getUniformLocation(r, "alphaTest") }; var l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); l.width = 8, l.height = 8; var u = l.getContext("2d"); u.fillStyle = "white", u.fillRect(0, 0, 8, 8), (s = new Ct(l)).needsUpdate = !0 } function f(t, e) { return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id } this.render = function (m, g) { if (0 !== e.length) { void 0 === r && d(), c.useProgram(r), h.initAttributes(), h.enableAttribute(a.position), h.enableAttribute(a.uv), h.disableUnusedAttributes(), h.disable(c.CULL_FACE), h.enable(c.BLEND), c.bindBuffer(c.ARRAY_BUFFER, i), c.vertexAttribPointer(a.position, 2, c.FLOAT, !1, 16, 0), c.vertexAttribPointer(a.uv, 2, c.FLOAT, !1, 16, 8), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, n), c.uniformMatrix4fv(o.projectionMatrix, !1, g.projectionMatrix.elements), h.activeTexture(c.TEXTURE0), c.uniform1i(o.map, 0); var v = 0, y = 0, x = m.fog; x ? (c.uniform3f(o.fogColor, x.color.r, x.color.g, x.color.b), x && x.isFog ? (c.uniform1f(o.fogNear, x.near), c.uniform1f(o.fogFar, x.far), c.uniform1i(o.fogType, 1), v = 1, y = 1) : x && x.isFogExp2 && (c.uniform1f(o.fogDensity, x.density), c.uniform1i(o.fogType, 2), v = 2, y = 2)) : (c.uniform1i(o.fogType, 0), v = 0, y = 0); for (var _ = 0, w = e.length; _ < w; _++) { (M = e[_]).modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, M.matrixWorld), M.z = -M.modelViewMatrix.elements[14] } e.sort(f); var b = []; for (_ = 0, w = e.length; _ < w; _++) { var M, E = (M = e[_]).material; if (!1 !== E.visible) { c.uniform1f(o.alphaTest, E.alphaTest), c.uniformMatrix4fv(o.modelViewMatrix, !1, M.modelViewMatrix.elements), M.matrixWorld.decompose(l, u, p), b[0] = p.x, b[1] = p.y; var T = 0; m.fog && E.fog && (T = y), v !== T && (c.uniform1i(o.fogType, T), v = T), null !== E.map ? (c.uniform2f(o.uvOffset, E.map.offset.x, E.map.offset.y), c.uniform2f(o.uvScale, E.map.repeat.x, E.map.repeat.y)) : (c.uniform2f(o.uvOffset, 0, 0), c.uniform2f(o.uvScale, 1, 1)), c.uniform1f(o.opacity, E.opacity), c.uniform3f(o.color, E.color.r, E.color.g, E.color.b), c.uniform1f(o.rotation, E.rotation), c.uniform2fv(o.scale, b), h.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), h.setDepthTest(E.depthTest), h.setDepthWrite(E.depthWrite), E.map ? t.setTexture2D(E.map, 0) : t.setTexture2D(s, 0), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0) } } h.enable(c.CULL_FACE), t.resetGLState() } } } function Wt(t, e) { this.min = void 0 !== t ? t : new Pt(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Pt(-1 / 0, -1 / 0) } function Xt(t, e) { var i, n, r, a, o, s, c, h, l = t.context, u = t.state; function p() { var e = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), p = new Uint16Array([0, 1, 2, 0, 2, 3]); i = l.createBuffer(), n = l.createBuffer(), l.bindBuffer(l.ARRAY_BUFFER, i), l.bufferData(l.ARRAY_BUFFER, e, l.STATIC_DRAW), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, n), l.bufferData(l.ELEMENT_ARRAY_BUFFER, p, l.STATIC_DRAW), c = l.createTexture(), h = l.createTexture(), u.bindTexture(l.TEXTURE_2D, c), l.texImage2D(l.TEXTURE_2D, 0, l.RGB, 16, 16, 0, l.RGB, l.UNSIGNED_BYTE, null), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), u.bindTexture(l.TEXTURE_2D, h), l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, 16, 16, 0, l.RGBA, l.UNSIGNED_BYTE, null), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), r = { vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"), fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n") }, a = function (e) { var i = l.createProgram(), n = l.createShader(l.FRAGMENT_SHADER), r = l.createShader(l.VERTEX_SHADER), a = "precision " + t.getPrecision() + " float;\n"; return l.shaderSource(n, a + e.fragmentShader), l.shaderSource(r, a + e.vertexShader), l.compileShader(n), l.compileShader(r), l.attachShader(i, n), l.attachShader(i, r), l.linkProgram(i), i }(r), o = { vertex: l.getAttribLocation(a, "position"), uv: l.getAttribLocation(a, "uv") }, s = { renderType: l.getUniformLocation(a, "renderType"), map: l.getUniformLocation(a, "map"), occlusionMap: l.getUniformLocation(a, "occlusionMap"), opacity: l.getUniformLocation(a, "opacity"), color: l.getUniformLocation(a, "color"), scale: l.getUniformLocation(a, "scale"), rotation: l.getUniformLocation(a, "rotation"), screenPosition: l.getUniformLocation(a, "screenPosition") } } this.render = function (r, d, f) { if (0 !== e.length) { var m = new kt, g = f.w / f.z, v = .5 * f.z, y = .5 * f.w, x = 16 / f.w, _ = new Pt(x * g, x), w = new kt(1, 1, 0), b = new Pt(1, 1), M = new Wt; M.min.set(0, 0), M.max.set(f.z - 16, f.w - 16), void 0 === a && p(), l.useProgram(a), u.initAttributes(), u.enableAttribute(o.vertex), u.enableAttribute(o.uv), u.disableUnusedAttributes(), l.uniform1i(s.occlusionMap, 0), l.uniform1i(s.map, 1), l.bindBuffer(l.ARRAY_BUFFER, i), l.vertexAttribPointer(o.vertex, 2, l.FLOAT, !1, 16, 0), l.vertexAttribPointer(o.uv, 2, l.FLOAT, !1, 16, 8), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, n), u.disable(l.CULL_FACE), u.setDepthWrite(!1); for (var E = 0, T = e.length; E < T; E++) { x = 16 / f.w, _.set(x * g, x); var S = e[E]; if (m.set(S.matrixWorld.elements[12], S.matrixWorld.elements[13], S.matrixWorld.elements[14]), m.applyMatrix4(d.matrixWorldInverse), m.applyProjection(d.projectionMatrix), w.copy(m), b.x = f.x + w.x * v + v - 8, b.y = f.y + w.y * y + y - 8, !0 === M.containsPoint(b)) { u.activeTexture(l.TEXTURE0), u.bindTexture(l.TEXTURE_2D, null), u.activeTexture(l.TEXTURE1), u.bindTexture(l.TEXTURE_2D, c), l.copyTexImage2D(l.TEXTURE_2D, 0, l.RGB, b.x, b.y, 16, 16, 0), l.uniform1i(s.renderType, 0), l.uniform2f(s.scale, _.x, _.y), l.uniform3f(s.screenPosition, w.x, w.y, w.z), u.disable(l.BLEND), u.enable(l.DEPTH_TEST), l.drawElements(l.TRIANGLES, 6, l.UNSIGNED_SHORT, 0), u.activeTexture(l.TEXTURE0), u.bindTexture(l.TEXTURE_2D, h), l.copyTexImage2D(l.TEXTURE_2D, 0, l.RGBA, b.x, b.y, 16, 16, 0), l.uniform1i(s.renderType, 1), u.disable(l.DEPTH_TEST), u.activeTexture(l.TEXTURE1), u.bindTexture(l.TEXTURE_2D, c), l.drawElements(l.TRIANGLES, 6, l.UNSIGNED_SHORT, 0), S.positionScreen.copy(w), S.customUpdateCallback ? S.customUpdateCallback(S) : S.updateLensFlares(), l.uniform1i(s.renderType, 2), u.enable(l.BLEND); for (var A = 0, L = S.lensFlares.length; A < L; A++) { var R = S.lensFlares[A]; R.opacity > .001 && R.scale > .001 && (w.x = R.x, w.y = R.y, w.z = R.z, x = R.size * R.scale / f.w, _.x = x * g, _.y = x, l.uniform3f(s.screenPosition, w.x, w.y, w.z), l.uniform2f(s.scale, _.x, _.y), l.uniform1f(s.rotation, R.rotation), l.uniform1f(s.opacity, R.opacity), l.uniform3f(s.color, R.color.r, R.color.g, R.color.b), u.setBlending(R.blending, R.blendEquation, R.blendSrc, R.blendDst), t.setTexture2D(R.texture, 1), l.drawElements(l.TRIANGLES, 6, l.UNSIGNED_SHORT, 0)) } } } u.enable(l.CULL_FACE), u.enable(l.DEPTH_TEST), u.setDepthWrite(!0), t.resetGLState() } } } function Yt(t, e, i, n, r, a, o, s, c, h) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : j, Ct.call(this, t, e, i, n, r, a, o, s, c, h), this.flipY = !1 } Ht.prototype = { constructor: Ht, isMatrix4: !0, set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) { var g = this.elements; return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new Ht).fromArray(this.elements) }, copy: function (t) { return this.elements.set(t.elements), this }, copyPosition: function (t) { var e = this.elements, i = t.elements; return e[12] = i[12], e[13] = i[13], e[14] = i[14], this }, extractBasis: function (t, e, i) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, i) { return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this }, extractRotation: function (t) { void 0 === Ot && (Ot = new kt); var e = this.elements, i = t.elements, n = 1 / Ot.setFromMatrixColumn(t, 0).length(), r = 1 / Ot.setFromMatrixColumn(t, 1).length(), a = 1 / Ot.setFromMatrixColumn(t, 2).length(); return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, this }, makeRotationFromEuler: function (t) { !1 === (t && t.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var e = this.elements, i = t.x, n = t.y, r = t.z, a = Math.cos(i), o = Math.sin(i), s = Math.cos(n), c = Math.sin(n), h = Math.cos(r), l = Math.sin(r); if ("XYZ" === t.order) { var u = a * h, p = a * l, d = o * h, f = o * l; e[0] = s * h, e[4] = -s * l, e[8] = c, e[1] = p + d * c, e[5] = u - f * c, e[9] = -o * s, e[2] = f - u * c, e[6] = d + p * c, e[10] = a * s } else if ("YXZ" === t.order) { var m = s * h, g = s * l, v = c * h, y = c * l; e[0] = m + y * o, e[4] = v * o - g, e[8] = a * c, e[1] = a * l, e[5] = a * h, e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s } else if ("ZXY" === t.order) { m = s * h, g = s * l, v = c * h, y = c * l; e[0] = m - y * o, e[4] = -a * l, e[8] = v + g * o, e[1] = g + v * o, e[5] = a * h, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s } else if ("ZYX" === t.order) { u = a * h, p = a * l, d = o * h, f = o * l; e[0] = s * h, e[4] = d * c - p, e[8] = u * c + f, e[1] = s * l, e[5] = f * c + u, e[9] = p * c - d, e[2] = -c, e[6] = o * s, e[10] = a * s } else if ("YZX" === t.order) { var x = a * s, _ = a * c, w = o * s, b = o * c; e[0] = s * h, e[4] = b - x * l, e[8] = w * l + _, e[1] = l, e[5] = a * h, e[9] = -o * h, e[2] = -c * h, e[6] = _ * l + w, e[10] = x - b * l } else if ("XZY" === t.order) { x = a * s, _ = a * c, w = o * s, b = o * c; e[0] = s * h, e[4] = -l, e[8] = c * h, e[1] = x * l + b, e[5] = a * h, e[9] = _ * l - w, e[2] = w * l - _, e[6] = o * h, e[10] = b * l + x } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromQuaternion: function (t) { var e = this.elements, i = t.x, n = t.y, r = t.z, a = t.w, o = i + i, s = n + n, c = r + r, h = i * o, l = i * s, u = i * c, p = n * s, d = n * c, f = r * c, m = a * o, g = a * s, v = a * c; return e[0] = 1 - (p + f), e[4] = l - v, e[8] = u + g, e[1] = l + v, e[5] = 1 - (h + f), e[9] = d - m, e[2] = u - g, e[6] = d + m, e[10] = 1 - (h + p), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, lookAt: function (t, e, i) { void 0 === Dt && (Dt = new kt, Nt = new kt, Ft = new kt); var n = this.elements; return Ft.subVectors(t, e).normalize(), 0 === Ft.lengthSq() && (Ft.z = 1), Dt.crossVectors(i, Ft).normalize(), 0 === Dt.lengthSq() && (Ft.z += 1e-4, Dt.crossVectors(i, Ft).normalize()), Nt.crossVectors(Ft, Dt), n[0] = Dt.x, n[4] = Nt.x, n[8] = Ft.x, n[1] = Dt.y, n[5] = Nt.y, n[9] = Ft.y, n[2] = Dt.z, n[6] = Nt.z, n[10] = Ft.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var i = t.elements, n = e.elements, r = this.elements, a = i[0], o = i[4], s = i[8], c = i[12], h = i[1], l = i[5], u = i[9], p = i[13], d = i[2], f = i[6], m = i[10], g = i[14], v = i[3], y = i[7], x = i[11], _ = i[15], w = n[0], b = n[4], M = n[8], E = n[12], T = n[1], S = n[5], A = n[9], L = n[13], R = n[2], P = n[6], C = n[10], U = n[14], I = n[3], D = n[7], N = n[11], F = n[15]; return r[0] = a * w + o * T + s * R + c * I, r[4] = a * b + o * S + s * P + c * D, r[8] = a * M + o * A + s * C + c * N, r[12] = a * E + o * L + s * U + c * F, r[1] = h * w + l * T + u * R + p * I, r[5] = h * b + l * S + u * P + p * D, r[9] = h * M + l * A + u * C + p * N, r[13] = h * E + l * L + u * U + p * F, r[2] = d * w + f * T + m * R + g * I, r[6] = d * b + f * S + m * P + g * D, r[10] = d * M + f * A + m * C + g * N, r[14] = d * E + f * L + m * U + g * F, r[3] = v * w + y * T + x * R + _ * I, r[7] = v * b + y * S + x * P + _ * D, r[11] = v * M + y * A + x * C + _ * N, r[15] = v * E + y * L + x * U + _ * F, this }, multiplyToArray: function (t, e, i) { var n = this.elements; return this.multiplyMatrices(t, e), i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], i[4] = n[4], i[5] = n[5], i[6] = n[6], i[7] = n[7], i[8] = n[8], i[9] = n[9], i[10] = n[10], i[11] = n[11], i[12] = n[12], i[13] = n[13], i[14] = n[14], i[15] = n[15], this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, applyToVector3Array: function () { var t; return function (e, i, n) { void 0 === t && (t = new kt), void 0 === i && (i = 0), void 0 === n && (n = e.length); for (var r = 0, a = i; r < n; r += 3, a += 3)t.fromArray(e, a), t.applyMatrix4(this), t.toArray(e, a); return e } }(), applyToBuffer: function () { var t; return function (e, i, n) { void 0 === t && (t = new kt), void 0 === i && (i = 0), void 0 === n && (n = e.length / e.itemSize); for (var r = 0, a = i; r < n; r++, a++)t.x = e.getX(a), t.y = e.getY(a), t.z = e.getZ(a), t.applyMatrix4(this), e.setXYZ(t.x, t.y, t.z); return e } }(), determinant: function () { var t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], a = t[1], o = t[5], s = t[9], c = t[13], h = t[2], l = t[6], u = t[10], p = t[14]; return t[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) + t[7] * (+e * s * p - e * c * u + r * a * u - n * a * p + n * c * h - r * s * h) + t[11] * (+e * c * l - e * o * p - r * a * l + i * a * p + r * o * h - i * c * h) + t[15] * (-n * o * h - e * s * l + e * o * u + n * a * l - i * a * u + i * s * h) }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), this.toArray(t, e) }, getPosition: function () { var t; return function () { return void 0 === t && (t = new kt), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3) } }(), setPosition: function (t) { var e = this.elements; return e[12] = t.x, e[13] = t.y, e[14] = t.z, this }, getInverse: function (t, e) { var i = this.elements, n = t.elements, r = n[0], a = n[1], o = n[2], s = n[3], c = n[4], h = n[5], l = n[6], u = n[7], p = n[8], d = n[9], f = n[10], m = n[11], g = n[12], v = n[13], y = n[14], x = n[15], _ = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x, w = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x, b = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x, M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y, E = r * _ + a * w + o * b + s * M; if (0 === E) { var T = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(T); return console.warn(T), this.identity() } var S = 1 / E; return i[0] = _ * S, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * x - a * f * x) * S, i[2] = (h * y * s - v * l * s + v * o * u - a * y * u - h * o * x + a * l * x) * S, i[3] = (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * S, i[4] = w * S, i[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * x + r * f * x) * S, i[6] = (g * l * s - c * y * s - g * o * u + r * y * u + c * o * x - r * l * x) * S, i[7] = (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * S, i[8] = b * S, i[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * x - r * d * x) * S, i[10] = (c * v * s - g * h * s + g * a * u - r * v * u - c * a * x + r * h * x) * S, i[11] = (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * S, i[12] = M * S, i[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * S, i[14] = (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h * y) * S, i[15] = (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * S, this }, scale: function (t) { var e = this.elements, i = t.x, n = t.y, r = t.z; return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this }, getMaxScaleOnAxis: function () { var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, i, n)) }, makeTranslation: function (t, e, i) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this }, makeRotationX: function (t) { var e = Math.cos(t), i = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { var e = Math.cos(t), i = Math.sin(t); return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { var e = Math.cos(t), i = Math.sin(t); return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { var i = Math.cos(e), n = Math.sin(e), r = 1 - i, a = t.x, o = t.y, s = t.z, c = r * a, h = r * o; return this.set(c * a + i, c * o - n * s, c * s + n * o, 0, c * o + n * s, h * o + i, h * s - n * a, 0, c * s - n * o, h * s + n * a, r * s * s + i, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, i) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this }, compose: function (t, e, i) { return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this }, decompose: function (t, e, i) { void 0 === Ut && (Ut = new kt, It = new Ht); var n = this.elements, r = Ut.set(n[0], n[1], n[2]).length(), a = Ut.set(n[4], n[5], n[6]).length(), o = Ut.set(n[8], n[9], n[10]).length(); this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], It.elements.set(this.elements); var s = 1 / r, c = 1 / a, h = 1 / o; return It.elements[0] *= s, It.elements[1] *= s, It.elements[2] *= s, It.elements[4] *= c, It.elements[5] *= c, It.elements[6] *= c, It.elements[8] *= h, It.elements[9] *= h, It.elements[10] *= h, e.setFromRotationMatrix(It), i.x = r, i.y = a, i.z = o, this }, makeFrustum: function (t, e, i, n, r, a) { var o = this.elements, s = 2 * r / (e - t), c = 2 * r / (n - i), h = (e + t) / (e - t), l = (n + i) / (n - i), u = -(a + r) / (a - r), p = -2 * a * r / (a - r); return o[0] = s, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = l, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this }, makePerspective: function (e, i, n, r) { var a = n * Math.tan(t.Math.DEG2RAD * e * .5), o = -a, s = o * i, c = a * i; return this.makeFrustum(s, c, o, a, n, r) }, makeOrthographic: function (t, e, i, n, r, a) { var o = this.elements, s = 1 / (e - t), c = 1 / (i - n), h = 1 / (a - r), l = (e + t) * s, u = (i + n) * c, p = (a + r) * h; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -l, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this }, equals: function (t) { for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)if (e[n] !== i[n]) return !1; return !0 }, fromArray: function (t) { return this.elements.set(t), this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var i = this.elements; return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t } }, Vt.prototype = { constructor: Vt, get x() { return this._x }, set x(t) { this._x = t, this.onChangeCallback() }, get y() { return this._y }, set y(t) { this._y = t, this.onChangeCallback() }, get z() { return this._z }, set z(t) { this._z = t, this.onChangeCallback() }, get w() { return this._w }, set w(t) { this._w = t, this.onChangeCallback() }, set: function (t, e, i, n) { return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this }, setFromEuler: function (t, e) { if (!1 === (t && t.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var i = Math.cos(t._x / 2), n = Math.cos(t._y / 2), r = Math.cos(t._z / 2), a = Math.sin(t._x / 2), o = Math.sin(t._y / 2), s = Math.sin(t._z / 2), c = t.order; return "XYZ" === c ? (this._x = a * n * r + i * o * s, this._y = i * o * r - a * n * s, this._z = i * n * s + a * o * r, this._w = i * n * r - a * o * s) : "YXZ" === c ? (this._x = a * n * r + i * o * s, this._y = i * o * r - a * n * s, this._z = i * n * s - a * o * r, this._w = i * n * r + a * o * s) : "ZXY" === c ? (this._x = a * n * r - i * o * s, this._y = i * o * r + a * n * s, this._z = i * n * s + a * o * r, this._w = i * n * r - a * o * s) : "ZYX" === c ? (this._x = a * n * r - i * o * s, this._y = i * o * r + a * n * s, this._z = i * n * s - a * o * r, this._w = i * n * r + a * o * s) : "YZX" === c ? (this._x = a * n * r + i * o * s, this._y = i * o * r + a * n * s, this._z = i * n * s - a * o * r, this._w = i * n * r - a * o * s) : "XZY" === c && (this._x = a * n * r - i * o * s, this._y = i * o * r - a * n * s, this._z = i * n * s + a * o * r, this._w = i * n * r + a * o * s), !1 !== e && this.onChangeCallback(), this }, setFromAxisAngle: function (t, e) { var i = e / 2, n = Math.sin(i); return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e, i = t.elements, n = i[0], r = i[4], a = i[8], o = i[1], s = i[5], c = i[9], h = i[2], l = i[6], u = i[10], p = n + s + u; return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (l - c) * e, this._y = (a - h) * e, this._z = (o - r) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (l - c) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + h) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u), this._w = (a - h) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + u - n - s), this._w = (o - r) / e, this._x = (a + h) / e, this._y = (c + l) / e, this._z = .25 * e), this.onChangeCallback(), this }, setFromUnitVectors: function () { var t, e; return function (i, n) { return void 0 === t && (t = new kt), (e = i.dot(n) + 1) < 1e-6 ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize() } }(), inverse: function () { return this.conjugate().normalize() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { var i = t._x, n = t._y, r = t._z, a = t._w, o = e._x, s = e._y, c = e._z, h = e._w; return this._x = i * h + a * o + n * c - r * s, this._y = n * h + a * s + r * o - i * c, this._z = r * h + a * c + i * s - n * o, this._w = a * h - i * o - n * s - r * c, this.onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); var i = this._x, n = this._y, r = this._z, a = this._w, o = a * t._w + i * t._x + n * t._y + r * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this; var s = Math.sqrt(1 - o * o); if (Math.abs(s) < .001) return this._w = .5 * (a + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this; var c = Math.atan2(s, o), h = Math.sin((1 - e) * c) / s, l = Math.sin(e * c) / s; return this._w = a * h + this._w * l, this._x = i * h + this._x * l, this._y = n * h + this._y * l, this._z = r * h + this._z * l, this.onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }, Object.assign(Vt, { slerp: function (t, e, i, n) { return i.copy(t).slerp(e, n) }, slerpFlat: function (t, e, i, n, r, a, o) { var s = i[n + 0], c = i[n + 1], h = i[n + 2], l = i[n + 3], u = r[a + 0], p = r[a + 1], d = r[a + 2], f = r[a + 3]; if (l !== f || s !== u || c !== p || h !== d) { var m = 1 - o, g = s * u + c * p + h * d + l * f, v = g >= 0 ? 1 : -1, y = 1 - g * g; if (y > Number.EPSILON) { var x = Math.sqrt(y), _ = Math.atan2(x, g * v); m = Math.sin(m * _) / x, o = Math.sin(o * _) / x } var w = o * v; if (s = s * m + u * w, c = c * m + p * w, h = h * m + d * w, l = l * m + f * w, m === 1 - o) { var b = 1 / Math.sqrt(s * s + c * c + h * h + l * l); s *= b, c *= b, h *= b, l *= b } } t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = l } }), kt.prototype = { constructor: kt, isVector3: !0, set: function (t, e, i) { return this.x = t, this.y = e, this.z = i, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: function (t) { return !1 === (t && t.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === zt && (zt = new Vt), this.applyQuaternion(zt.setFromEuler(t)) }, applyAxisAngle: function () { var t; return function (e, i) { return void 0 === t && (t = new Vt), this.applyQuaternion(t.setFromAxisAngle(e, i)) } }(), applyMatrix3: function (t) { var e = this.x, i = this.y, n = this.z, r = t.elements; return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this }, applyMatrix4: function (t) { var e = this.x, i = this.y, n = this.z, r = t.elements; return this.x = r[0] * e + r[4] * i + r[8] * n + r[12], this.y = r[1] * e + r[5] * i + r[9] * n + r[13], this.z = r[2] * e + r[6] * i + r[10] * n + r[14], this }, applyProjection: function (t) { var e = this.x, i = this.y, n = this.z, r = t.elements, a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]); return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a, this }, applyQuaternion: function (t) { var e = this.x, i = this.y, n = this.z, r = t.x, a = t.y, o = t.z, s = t.w, c = s * e + a * n - o * i, h = s * i + o * e - r * n, l = s * n + r * i - a * e, u = -r * e - a * i - o * n; return this.x = c * s + u * -r + h * -o - l * -a, this.y = h * s + u * -a + l * -r - c * -o, this.z = l * s + u * -o + c * -a - h * -r, this }, project: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyProjection(t) } }(), unproject: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyProjection(t) } }(), transformDirection: function (t) { var e = this.x, i = this.y, n = this.z, r = t.elements; return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: function () { var t, e; return function (i, n) { return void 0 === t && (t = new kt, e = new kt), t.set(i, i, i), e.set(n, n, n), this.clamp(t, e) } }(), clampLength: function (t, e) { var i = this.length(); return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, cross: function (t, e) { if (void 0 !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e); var i = this.x, n = this.y, r = this.z; return this.x = n * t.z - r * t.y, this.y = r * t.x - i * t.z, this.z = i * t.y - n * t.x, this }, crossVectors: function (t, e) { var i = t.x, n = t.y, r = t.z, a = e.x, o = e.y, s = e.z; return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a, this }, projectOnVector: function (t) { var e = t.dot(this) / t.lengthSq(); return this.copy(t).multiplyScalar(e) }, projectOnPlane: function () { var t; return function (e) { return void 0 === t && (t = new kt), t.copy(this).projectOnVector(e), this.sub(t) } }(), reflect: function () { var t; return function (e) { return void 0 === t && (t = new kt), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e))) } }(), angleTo: function (e) { var i = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()); return Math.acos(t.Math.clamp(i, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, i = this.y - t.y, n = this.z - t.z; return e * e + i * i + n * n }, distanceToManhattan: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { var e = Math.sin(t.phi) * t.radius; return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this }, setFromMatrixPosition: function (t) { return this.setFromMatrixColumn(t, 3) }, setFromMatrixScale: function (t) { var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = i, this.z = n, this }, setFromMatrixColumn: function (t, e) { if ("number" == typeof t) { console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index )."); var i = t; t = e, e = i } return this.fromArray(t.elements, 4 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromAttribute: function (t, e, i) { return void 0 === i && (i = 0), e = e * t.itemSize + i, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this } }, Wt.prototype = { constructor: Wt, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, i = t.length; e < i; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new Pt; return function (e, i) { var n = t.copy(i).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, center: function (t) { return (t || new Pt).addVectors(this.min, this.max).multiplyScalar(.5) }, size: function (t) { return (t || new Pt).subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return (e || new Pt).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return (e || new Pt).copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new Pt; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }, Yt.prototype = Object.create(Ct.prototype), Yt.prototype.constructor = Yt, Yt.prototype.isCubeTexture = !0, Object.defineProperty(Yt.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }); var qt = new Ct, Zt = new Yt; function Jt() { this.seq = [], this.map = {} } var Qt = [], Kt = []; function $t(t, e, i) { var n = t[0]; if (n <= 0 || n > 0) return t; var r = e * i, a = Qt[r]; if (void 0 === a && (a = new Float32Array(r), Qt[r] = a), 0 !== e) { n.toArray(a, 0); for (var o = 1, s = 0; o !== e; ++o)s += i, t[o].toArray(a, s) } return a } function te(t, e) { var i = Kt[e]; void 0 === i && (i = new Int32Array(e), Kt[e] = i); for (var n = 0; n !== e; ++n)i[n] = t.allocTextureUnit(); return i } function ee(t, e) { t.uniform1f(this.addr, e) } function ie(t, e) { t.uniform1i(this.addr, e) } function ne(t, e) { void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y) } function re(t, e) { void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e) } function ae(t, e) { void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w) } function oe(t, e) { t.uniformMatrix2fv(this.addr, !1, e.elements || e) } function se(t, e) { t.uniformMatrix3fv(this.addr, !1, e.elements || e) } function ce(t, e) { t.uniformMatrix4fv(this.addr, !1, e.elements || e) } function he(t, e, i) { var n = i.allocTextureUnit(); t.uniform1i(this.addr, n), i.setTexture2D(e || qt, n) } function le(t, e, i) { var n = i.allocTextureUnit(); t.uniform1i(this.addr, n), i.setTextureCube(e || Zt, n) } function ue(t, e) { t.uniform2iv(this.addr, e) } function pe(t, e) { t.uniform3iv(this.addr, e) } function de(t, e) { t.uniform4iv(this.addr, e) } function fe(t, e) { t.uniform1fv(this.addr, e) } function me(t, e) { t.uniform1iv(this.addr, e) } function ge(t, e) { t.uniform2fv(this.addr, $t(e, this.size, 2)) } function ve(t, e) { t.uniform3fv(this.addr, $t(e, this.size, 3)) } function ye(t, e) { t.uniform4fv(this.addr, $t(e, this.size, 4)) } function xe(t, e) { t.uniformMatrix2fv(this.addr, !1, $t(e, this.size, 4)) } function _e(t, e) { t.uniformMatrix3fv(this.addr, !1, $t(e, this.size, 9)) } function we(t, e) { t.uniformMatrix4fv(this.addr, !1, $t(e, this.size, 16)) } function be(t, e, i) { var n = e.length, r = te(i, n); t.uniform1iv(this.addr, r); for (var a = 0; a !== n; ++a)i.setTexture2D(e[a] || qt, r[a]) } function Me(t, e, i) { var n = e.length, r = te(i, n); t.uniform1iv(this.addr, r); for (var a = 0; a !== n; ++a)i.setTextureCube(e[a] || Zt, r[a]) } function Ee(t, e, i) { this.id = t, this.addr = i, this.setValue = function (t) { switch (t) { case 5126: return ee; case 35664: return ne; case 35665: return re; case 35666: return ae; case 35674: return oe; case 35675: return se; case 35676: return ce; case 35678: return he; case 35680: return le; case 5124: case 35670: return ie; case 35667: case 35671: return ue; case 35668: case 35672: return pe; case 35669: case 35673: return de } }(e.type) } function Te(t, e, i) { this.id = t, this.addr = i, this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return fe; case 35664: return ge; case 35665: return ve; case 35666: return ye; case 35674: return xe; case 35675: return _e; case 35676: return we; case 35678: return be; case 35680: return Me; case 5124: case 35670: return me; case 35667: case 35671: return ue; case 35668: case 35672: return pe; case 35669: case 35673: return de } }(e.type) } function Se(t) { this.id = t, Jt.call(this) } Se.prototype.setValue = function (t, e) { for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) { var a = i[n]; a.setValue(t, e[a.id]) } }; var Ae = /([\w\d_]+)(\])?(\[|\.)?/g; function Le(t, e) { t.seq.push(e), t.map[e.id] = e } function Re(t, e, i) { var n = t.name, r = n.length; for (Ae.lastIndex = 0; ;) { var a = Ae.exec(n), o = Ae.lastIndex, s = a[1], c = "]" === a[2], h = a[3]; if (c && (s |= 0), void 0 === h || "[" === h && o + 2 === r) { Le(i, void 0 === h ? new Ee(s, t, e) : new Te(s, t, e)); break } var l = i.map[s]; void 0 === l && Le(i, l = new Se(s)), i = l } } function Pe(t, e, i) { Jt.call(this), this.renderer = i; for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r !== n; ++r) { var a = t.getActiveUniform(e, r), o = a.name; Re(a, t.getUniformLocation(e, o), this) } } function Ce(e, i, n, r, a, o, s) { var c = s.memory, h = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext; function l(t, e) { if (t.width > e || t.height > e) { var i = e / Math.max(t.width, t.height), n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t), n } return t } function u(e) { return t.Math.isPowerOfTwo(e.width) && t.Math.isPowerOfTwo(e.height) } function p(t) { return t === tt || t === et || t === it ? e.NEAREST : e.LINEAR } function d(t) { var i = t.target; i.removeEventListener("dispose", d), function (t) { var i = r.get(t); if (t.image && i.__image__webglTextureCube) e.deleteTexture(i.__image__webglTextureCube); else { if (void 0 === i.__webglInit) return; e.deleteTexture(i.__webglTexture) } r.delete(t) }(i), c.textures-- } function f(t) { var i = t.target; i.removeEventListener("dispose", f), function (t) { var i = r.get(t), n = r.get(t.texture); if (!t) return; void 0 !== n.__webglTexture && e.deleteTexture(n.__webglTexture); t.depthTexture && t.depthTexture.dispose(); if (t && t.isWebGLRenderTargetCube) for (var a = 0; a < 6; a++)e.deleteFramebuffer(i.__webglFramebuffer[a]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[a]); else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer); r.delete(t.texture), r.delete(t) }(i), c.textures-- } function m(i, s) { var p = r.get(i); if (i.version > 0 && p.__version !== i.version) { var f = i.image; if (void 0 === f) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", i); else { if (!1 !== f.complete) return void function (i, r, s) { void 0 === i.__webglInit && (i.__webglInit = !0, r.addEventListener("dispose", d), i.__webglTexture = e.createTexture(), c.textures++); n.activeTexture(e.TEXTURE0 + s), n.bindTexture(e.TEXTURE_2D, i.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, r.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, r.unpackAlignment); var p = l(r.image, a.maxTextureSize); (function (t) { return t.wrapS !== K || t.wrapT !== K || t.minFilter !== tt && t.minFilter !== nt })(r) && !1 === u(p) && (p = function (e) { if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) { var i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return i.width = t.Math.nearestPowerOfTwo(e.width), i.height = t.Math.nearestPowerOfTwo(e.height), i.getContext("2d").drawImage(e, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + i.width + "x" + i.height, e), i } return e }(p)); var f = u(p), m = o(r.format), v = o(r.type); g(e.TEXTURE_2D, r, f); var y, x = r.mipmaps; if (r && r.isDepthTexture) { var _ = e.DEPTH_COMPONENT; if (r.type === st) { if (!h) throw new Error("Float Depth Texture only supported in WebGL2.0"); _ = e.DEPTH_COMPONENT32F } else h && (_ = e.DEPTH_COMPONENT16); r.format === dt && (_ = e.DEPTH_STENCIL), n.texImage2D(e.TEXTURE_2D, 0, _, p.width, p.height, 0, m, v, null) } else if (r && r.isDataTexture) if (x.length > 0 && f) { for (var w = 0, b = x.length; w < b; w++)y = x[w], n.texImage2D(e.TEXTURE_2D, w, m, y.width, y.height, 0, m, v, y.data); r.generateMipmaps = !1 } else n.texImage2D(e.TEXTURE_2D, 0, m, p.width, p.height, 0, m, v, p.data); else if (r && r.isCompressedTexture) for (w = 0, b = x.length; w < b; w++)y = x[w], r.format !== lt && r.format !== ht ? n.getCompressedTextureFormats().indexOf(m) > -1 ? n.compressedTexImage2D(e.TEXTURE_2D, w, m, y.width, y.height, 0, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, w, m, y.width, y.height, 0, m, v, y.data); else if (x.length > 0 && f) { for (w = 0, b = x.length; w < b; w++)y = x[w], n.texImage2D(e.TEXTURE_2D, w, m, m, v, y); r.generateMipmaps = !1 } else n.texImage2D(e.TEXTURE_2D, 0, m, m, v, p); r.generateMipmaps && f && e.generateMipmap(e.TEXTURE_2D); i.__version = r.version, r.onUpdate && r.onUpdate(r) }(p, i, s); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", i) } } n.activeTexture(e.TEXTURE0 + s), n.bindTexture(e.TEXTURE_2D, p.__webglTexture) } function g(t, n, s) { var c; if (s ? (e.texParameteri(t, e.TEXTURE_WRAP_S, o(n.wrapS)), e.texParameteri(t, e.TEXTURE_WRAP_T, o(n.wrapT)), e.texParameteri(t, e.TEXTURE_MAG_FILTER, o(n.magFilter)), e.texParameteri(t, e.TEXTURE_MIN_FILTER, o(n.minFilter))) : (e.texParameteri(t, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(t, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n.wrapS === K && n.wrapT === K || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", n), e.texParameteri(t, e.TEXTURE_MAG_FILTER, p(n.magFilter)), e.texParameteri(t, e.TEXTURE_MIN_FILTER, p(n.minFilter)), n.minFilter !== tt && n.minFilter !== nt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", n)), c = i.get("EXT_texture_filter_anisotropic")) { if (n.type === st && null === i.get("OES_texture_float_linear")) return; if (n.type === ct && null === i.get("OES_texture_half_float_linear")) return; (n.anisotropy > 1 || r.get(n).__currentAnisotropy) && (e.texParameterf(t, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(n.anisotropy, a.getMaxAnisotropy())), r.get(n).__currentAnisotropy = n.anisotropy) } } function v(t, i, a, s) { var c = o(i.texture.format), h = o(i.texture.type); n.texImage2D(s, 0, c, i.width, i.height, 0, c, h, null), e.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(e.FRAMEBUFFER, null) } function y(t, i) { e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer && !i.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)) : i.depthBuffer && i.stencilBuffer ? (e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)) : e.renderbufferStorage(e.RENDERBUFFER, e.RGBA4, i.width, i.height), e.bindRenderbuffer(e.RENDERBUFFER, null) } function x(t) { var i = r.get(t), n = t && t.isWebGLRenderTargetCube; if (t.depthTexture) { if (n) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, i) { if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported!"); if (e.bindFramebuffer(e.FRAMEBUFFER, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), m(i.depthTexture, 0); var n = r.get(i.depthTexture).__webglTexture; if (i.depthTexture.format === pt) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, n, 0); else { if (i.depthTexture.format !== dt) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, n, 0) } }(i.__webglFramebuffer, t) } else if (n) { i.__webglDepthbuffer = []; for (var a = 0; a < 6; a++)e.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[a]), i.__webglDepthbuffer[a] = e.createRenderbuffer(), y(i.__webglDepthbuffer[a], t) } else e.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), y(i.__webglDepthbuffer, t); e.bindFramebuffer(e.FRAMEBUFFER, null) } this.setTexture2D = m, this.setTextureCube = function (t, i) { var s = r.get(t); if (6 === t.image.length) if (t.version > 0 && s.__version !== t.version) { s.__image__webglTextureCube || (t.addEventListener("dispose", d), s.__image__webglTextureCube = e.createTexture(), c.textures++), n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, s.__image__webglTextureCube), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t.flipY); for (var h = t && t.isCompressedTexture, p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; m < 6; m++)f[m] = h || p ? p ? t.image[m].image : t.image[m] : l(t.image[m], a.maxCubemapSize); var v = u(f[0]), y = o(t.format), x = o(t.type); g(e.TEXTURE_CUBE_MAP, t, v); for (m = 0; m < 6; m++)if (h) for (var _, w = f[m].mipmaps, b = 0, M = w.length; b < M; b++)_ = w[b], t.format !== lt && t.format !== ht ? n.getCompressedTextureFormats().indexOf(y) > -1 ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, b, y, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, b, y, _.width, _.height, 0, y, x, _.data); else p ? n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, f[m].width, f[m].height, 0, y, x, f[m].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, y, x, f[m]); t.generateMipmaps && v && e.generateMipmap(e.TEXTURE_CUBE_MAP), s.__version = t.version, t.onUpdate && t.onUpdate(t) } else n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, s.__image__webglTextureCube) }, this.setTextureCubeDynamic = function (t, i) { n.activeTexture(e.TEXTURE0 + i), n.bindTexture(e.TEXTURE_CUBE_MAP, r.get(t).__webglTexture) }, this.setupRenderTarget = function (t) { var i = r.get(t), a = r.get(t.texture); t.addEventListener("dispose", f), a.__webglTexture = e.createTexture(), c.textures++; var o = t && t.isWebGLRenderTargetCube, s = u(t); if (o) { i.__webglFramebuffer = []; for (var h = 0; h < 6; h++)i.__webglFramebuffer[h] = e.createFramebuffer() } else i.__webglFramebuffer = e.createFramebuffer(); if (o) { n.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture), g(e.TEXTURE_CUBE_MAP, t.texture, s); for (h = 0; h < 6; h++)v(i.__webglFramebuffer[h], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + h); t.texture.generateMipmaps && s && e.generateMipmap(e.TEXTURE_CUBE_MAP), n.bindTexture(e.TEXTURE_CUBE_MAP, null) } else n.bindTexture(e.TEXTURE_2D, a.__webglTexture), g(e.TEXTURE_2D, t.texture, s), v(i.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, e.TEXTURE_2D), t.texture.generateMipmaps && s && e.generateMipmap(e.TEXTURE_2D), n.bindTexture(e.TEXTURE_2D, null); t.depthBuffer && x(t) }, this.updateRenderTargetMipmap = function (t) { var i = t.texture; if (i.generateMipmaps && u(t) && i.minFilter !== tt && i.minFilter !== nt) { var a = t && t.isWebGLRenderTargetCube ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, o = r.get(i).__webglTexture; n.bindTexture(a, o), e.generateMipmap(a), n.bindTexture(a, null) } } } function Ue(t, e, i, n) { this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1 } function Ie(t, e, i) { var n = new function () { var e = !1, i = new Ue, n = null, r = new Ue; return { setMask: function (i) { n === i || e || (t.colorMask(i, i, i, i), n = i) }, setLocked: function (t) { e = t }, setClear: function (e, n, a, o) { i.set(e, n, a, o), !1 === r.equals(i) && (t.clearColor(e, n, a, o), r.copy(i)) }, reset: function () { e = !1, n = null, r.set(0, 0, 0, 1) } } }, r = new function () { var e = !1, i = null, n = null, r = null; return { setTest: function (e) { e ? J(t.DEPTH_TEST) : Q(t.DEPTH_TEST) }, setMask: function (n) { i === n || e || (t.depthMask(n), i = n) }, setFunc: function (e) { if (n !== e) { if (e) switch (e) { case L: t.depthFunc(t.NEVER); break; case R: t.depthFunc(t.ALWAYS); break; case P: t.depthFunc(t.LESS); break; case C: t.depthFunc(t.LEQUAL); break; case U: t.depthFunc(t.EQUAL); break; case I: t.depthFunc(t.GEQUAL); break; case D: t.depthFunc(t.GREATER); break; case N: t.depthFunc(t.NOTEQUAL); break; default: t.depthFunc(t.LEQUAL) } else t.depthFunc(t.LEQUAL); n = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, i = null, n = null, r = null } } }, a = new function () { var e = !1, i = null, n = null, r = null, a = null, o = null, s = null, c = null, h = null; return { setTest: function (e) { e ? J(t.STENCIL_TEST) : Q(t.STENCIL_TEST) }, setMask: function (n) { i === n || e || (t.stencilMask(n), i = n) }, setFunc: function (e, i, o) { n === e && r === i && a === o || (t.stencilFunc(e, i, o), n = e, r = i, a = o) }, setOp: function (e, i, n) { o === e && s === i && c === n || (t.stencilOp(e, i, n), o = e, s = i, c = n) }, setLocked: function (t) { e = t }, setClear: function (e) { h !== e && (t.clearStencil(e), h = e) }, reset: function () { e = !1, i = null, n = null, r = null, a = null, o = null, s = null, c = null, h = null } } }, o = t.getParameter(t.MAX_VERTEX_ATTRIBS), s = new Uint8Array(o), u = new Uint8Array(o), p = new Uint8Array(o), d = {}, f = null, m = null, g = null, v = null, y = null, T = null, S = null, A = null, F = !1, O = null, z = null, B = null, G = null, H = null, V = null, k = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), j = null, W = {}, X = new Ue, Y = new Ue; function q(e, i, n) { var r = new Uint8Array(4), a = t.createTexture(); t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST); for (var o = 0; o < n; o++)t.texImage2D(i + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r); return a } var Z = {}; function J(e) { !0 !== d[e] && (t.enable(e), d[e] = !0) } function Q(e) { !1 !== d[e] && (t.disable(e), d[e] = !1) } function K(e, n, r, a, o, s, c, h) { if (e === x) return Q(t.BLEND), void (m = e); J(t.BLEND), e === m && h === F || (e === w ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === b ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === M ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), m = e, F = h), e === E ? (o = o || n, s = s || r, c = c || a, n === g && o === T || (t.blendEquationSeparate(i(n), i(o)), g = n, T = o), r === v && a === y && s === S && c === A || (t.blendFuncSeparate(i(r), i(a), i(s), i(c)), v = r, y = a, S = s, A = c)) : (g = null, v = null, y = null, T = null, S = null, A = null) } function $(t) { r.setFunc(t) } function tt(e) { O !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), O = e) } function et(e) { e !== c ? (J(t.CULL_FACE), e !== z && (e === h ? t.cullFace(t.BACK) : e === l ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Q(t.CULL_FACE), z = e } function it(e) { void 0 === e && (e = t.TEXTURE0 + k - 1), j !== e && (t.activeTexture(e), j = e) } function nt(t, e, i, r) { n.setClear(t, e, i, r) } function rt(t) { r.setClear(t) } function at(t) { a.setClear(t) } return Z[t.TEXTURE_2D] = q(t.TEXTURE_2D, t.TEXTURE_2D, 1), Z[t.TEXTURE_CUBE_MAP] = q(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), { buffers: { color: n, depth: r, stencil: a }, init: function () { nt(0, 0, 0, 1), rt(1), at(0), J(t.DEPTH_TEST), $(C), tt(!1), et(h), J(t.CULL_FACE), J(t.BLEND), K(_) }, initAttributes: function () { for (var t = 0, e = s.length; t < e; t++)s[t] = 0 }, enableAttribute: function (i) { s[i] = 1, 0 === u[i] && (t.enableVertexAttribArray(i), u[i] = 1), 0 !== p[i] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), p[i] = 0) }, enableAttributeAndDivisor: function (e, i, n) { s[e] = 1, 0 === u[e] && (t.enableVertexAttribArray(e), u[e] = 1), p[e] !== i && (n.vertexAttribDivisorANGLE(e, i), p[e] = i) }, disableUnusedAttributes: function () { for (var e = 0, i = u.length; e !== i; ++e)u[e] !== s[e] && (t.disableVertexAttribArray(e), u[e] = 0) }, enable: J, disable: Q, getCompressedTextureFormats: function () { if (null === f && (f = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1"))) for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++)f.push(i[n]); return f }, setBlending: K, setColorWrite: function (t) { n.setMask(t) }, setDepthTest: function (t) { r.setTest(t) }, setDepthWrite: function (t) { r.setMask(t) }, setDepthFunc: $, setStencilTest: function (t) { a.setTest(t) }, setStencilWrite: function (t) { a.setMask(t) }, setStencilFunc: function (t, e, i) { a.setFunc(t, e, i) }, setStencilOp: function (t, e, i) { a.setOp(t, e, i) }, setFlipSided: tt, setCullFace: et, setLineWidth: function (e) { e !== B && (t.lineWidth(e), B = e) }, setPolygonOffset: function (e, i, n) { e ? (J(t.POLYGON_OFFSET_FILL), G === i && H === n || (t.polygonOffset(i, n), G = i, H = n)) : Q(t.POLYGON_OFFSET_FILL) }, getScissorTest: function () { return V }, setScissorTest: function (e) { V = e, e ? J(t.SCISSOR_TEST) : Q(t.SCISSOR_TEST) }, activeTexture: it, bindTexture: function (e, i) { null === j && it(); var n = W[j]; void 0 === n && (n = { type: void 0, texture: void 0 }, W[j] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || Z[e]), n.type = e, n.texture = i) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error(t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error(t) } }, clearColor: nt, clearDepth: rt, clearStencil: at, scissor: function (e) { !1 === X.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), X.copy(e)) }, viewport: function (e) { !1 === Y.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), Y.copy(e)) }, reset: function () { for (var e = 0; e < u.length; e++)1 === u[e] && (t.disableVertexAttribArray(e), u[e] = 0); d = {}, f = null, j = null, W = {}, m = null, O = null, z = null, n.reset(), r.reset(), a.reset() } } } function De(e, i, n) { this.uuid = t.Math.generateUUID(), this.width = e, this.height = i, this.scissor = new Ue(0, 0, e, i), this.scissorTest = !1, this.viewport = new Ue(0, 0, e, i), void 0 === (n = n || {}).minFilter && (n.minFilter = nt), this.texture = new Ct(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function Ne() { Object.defineProperty(this, "id", { value: Oe() }), this.uuid = t.Math.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = _, this.side = d, this.shading = v, this.vertexColors = y, this.opacity = 1, this.transparent = !1, this.blendSrc = S, this.blendDst = A, this.blendEquation = T, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = C, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this._needsUpdate = !0 } Pe.prototype.setValue = function (t, e, i) { var n = this.map[e]; void 0 !== n && n.setValue(t, i, this.renderer) }, Pe.prototype.set = function (t, e, i) { var n = this.map[i]; void 0 !== n && n.setValue(t, e[i], this.renderer) }, Pe.prototype.setOptional = function (t, e, i) { var n = e[i]; void 0 !== n && this.setValue(t, i, n) }, Pe.upload = function (t, e, i, n) { for (var r = 0, a = e.length; r !== a; ++r) { var o = e[r], s = i[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, n) } }, Pe.seqWithValue = function (t, e) { for (var i = [], n = 0, r = t.length; n !== r; ++n) { var a = t[n]; a.id in e && i.push(a) } return i }, Pe.splitDynamic = function (t, e) { for (var i = null, n = t.length, r = 0, a = 0; a !== n; ++a) { var o = t[a], s = e[o.id]; s && !0 === s.dynamic ? (null === i && (i = []), i.push(o)) : (r < a && (t[r] = o), ++r) } return r < n && (t.length = r), i }, Pe.evalDynamic = function (t, e, i, n) { for (var r = 0, a = t.length; r !== a; ++r) { var o = e[t[r].id], s = o.onUpdateCallback; void 0 !== s && s.call(o, i, n) } }, Ue.prototype = { constructor: Ue, isVector4: !0, set: function (t, e, i, n) { return this.x = t, this.y = e, this.z = i, this.w = n, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this.w *= t) : (this.x = 0, this.y = 0, this.z = 0, this.w = 0), this }, applyMatrix4: function (t) { var e = this.x, i = this.y, n = this.z, r = this.w, a = t.elements; return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { var e, i, n, r, a = .01, o = .1, s = t.elements, c = s[0], h = s[4], l = s[8], u = s[1], p = s[5], d = s[9], f = s[2], m = s[6], g = s[10]; if (Math.abs(h - u) < a && Math.abs(l - f) < a && Math.abs(d - m) < a) { if (Math.abs(h + u) < o && Math.abs(l + f) < o && Math.abs(d + m) < o && Math.abs(c + p + g - 3) < o) return this.set(1, 0, 0, 0), this; e = Math.PI; var v = (c + 1) / 2, y = (p + 1) / 2, x = (g + 1) / 2, _ = (h + u) / 4, w = (l + f) / 4, b = (d + m) / 4; return v > y && v > x ? v < a ? (i = 0, n = .707106781, r = .707106781) : (n = _ / (i = Math.sqrt(v)), r = w / i) : y > x ? y < a ? (i = .707106781, n = 0, r = .707106781) : (i = _ / (n = Math.sqrt(y)), r = b / n) : x < a ? (i = .707106781, n = .707106781, r = 0) : (i = w / (r = Math.sqrt(x)), n = b / r), this.set(i, n, r, e), this } var M = Math.sqrt((m - d) * (m - d) + (l - f) * (l - f) + (u - h) * (u - h)); return Math.abs(M) < .001 && (M = 1), this.x = (m - d) / M, this.y = (l - f) / M, this.z = (u - h) / M, this.w = Math.acos((c + p + g - 1) / 2), this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function () { var t, e; return function (i, n) { return void 0 === t && (t = new Ue, e = new Ue), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e) } }(), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromAttribute: function (t, e, i) { return void 0 === i && (i = 0), e = e * t.itemSize + i, this.x = t.array[e], this.y = t.array[e + 1], this.z = t.array[e + 2], this.w = t.array[e + 3], this } }, Object.assign(De.prototype, e.prototype, { isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Ne.prototype = { constructor: Ne, isMaterial: !0, get needsUpdate() { return this._needsUpdate }, set needsUpdate(t) { !0 === t && this.update(), this._needsUpdate = t }, setValues: function (t) { if (void 0 !== t) for (var e in t) { var i = t[e]; if (void 0 !== i) { var n = this[e]; void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } else console.warn("THREE.Material: '" + e + "' parameter is undefined.") } }, toJSON: function (t) { var e = void 0 === t; e && (t = { textures: {}, images: {} }); var i = { metadata: { version: 4.4, type: "Material", generator: "Material.toJSON" } }; function n(t) { var e = []; for (var i in t) { var n = t[i]; delete n.metadata, e.push(n) } return e } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== _ && (i.blending = this.blending), this.shading !== v && (i.shading = this.shading), this.side !== d && (i.side = this.side), this.vertexColors !== y && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), i.skinning = this.skinning, i.morphTargets = this.morphTargets, e) { var r = n(t.textures), a = n(t.images); r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a) } return i }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.shading = t.shading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.clipShadows = t.clipShadows; var e = t.clippingPlanes, i = null; if (null !== e) { var n = e.length; i = new Array(n); for (var r = 0; r !== n; ++r)i[r] = e[r].clone() } return this.clippingPlanes = i, this }, update: function () { this.dispatchEvent({ type: "update" }) }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }, Object.assign(Ne.prototype, e.prototype); var Fe = 0; function Oe() { return Fe++ } function ze(t) { Ne.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } t.UniformsUtils = { merge: function (t) { for (var e = {}, i = 0; i < t.length; i++) { var n = this.clone(t[i]); for (var r in n) e[r] = n[r] } return e }, clone: function (t) { var e = {}; for (var i in t) for (var n in e[i] = {}, t[i]) { var r = t[i][n]; r && r.isColor || r && r.isVector2 || r && r.isVector3 || r && r.isVector4 || r && r.isMatrix3 || r && r.isMatrix4 || r && r.isTexture ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r } return e } }, ze.prototype = Object.create(Ne.prototype), ze.prototype.constructor = ze, ze.prototype.isShaderMaterial = !0, ze.prototype.copy = function (e) { return Ne.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = t.UniformsUtils.clone(e.uniforms), this.defines = e.defines, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this }, ze.prototype.toJSON = function (t) { var e = Ne.prototype.toJSON.call(this, t); return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e }; var Be = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "\nvec3 transformed = vec3( position );\n", beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n", bsdfs: "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", fog_fragment: "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n", normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n", equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", normal_frag: "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n", normal_vert: "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n", shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n" }; function Ge(t, e, i) { return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i) } Ge.prototype = { constructor: Ge, isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { this.r = t, this.g = t, this.b = t }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, i) { return this.r = t, this.g = e, this.b = i, this }, setHSL: function () { function e(t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t } return function (i, n, r) { if (i = t.Math.euclideanModulo(i, 1), n = t.Math.clamp(n, 0, 1), r = t.Math.clamp(r, 0, 1), 0 === n) this.r = this.g = this.b = r; else { var a = r <= .5 ? r * (1 + n) : r + n - r * n, o = 2 * r - a; this.r = e(o, a, i + 1 / 3), this.g = e(o, a, i), this.b = e(o, a, i - 1 / 3) } return this } }(), setStyle: function (e) { function i(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } var n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) { var r, a = n[1], o = n[2]; switch (a) { case "rgb": case "rgba": if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, i(r[5]), this; if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, i(r[5]), this; break; case "hsl": case "hsla": if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) { var s = parseFloat(r[1]) / 360, c = parseInt(r[2], 10) / 100, h = parseInt(r[3], 10) / 100; return i(r[5]), this.setHSL(s, c, h) } } } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) { var l, u = (l = n[1]).length; if (3 === u) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this; if (6 === u) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this } e && e.length > 0 && (void 0 !== (l = t.ColorKeywords[e]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e)); return this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); var i = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this }, convertGammaToLinear: function () { var t = this.r, e = this.g, i = this.b; return this.r = t * t, this.g = e * e, this.b = i * i, this }, convertLinearToGamma: function () { return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { var e, i, n = t || { h: 0, s: 0, l: 0 }, r = this.r, a = this.g, o = this.b, s = Math.max(r, a, o), c = Math.min(r, a, o), h = (c + s) / 2; if (c === s) e = 0, i = 0; else { var l = s - c; switch (i = h <= .5 ? l / (s + c) : l / (2 - s - c), s) { case r: e = (a - o) / l + (a < o ? 6 : 0); break; case a: e = (o - r) / l + 2; break; case o: e = (r - a) / l + 4 }e /= 6 } return n.h = e, n.s = i, n.l = h, n }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (t, e, i) { var n = this.getHSL(); return n.h += t, n.s += e, n.l += i, this.setHSL(n.h, n.s, n.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, toJSON: function () { return this.getHex() } }, t.ColorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; var He, Ve, ke, je, We, Xe, Ye = { common: { diffuse: { value: new Ge(15658734) }, opacity: { value: 1 }, map: { value: null }, offsetRepeat: { value: new Ue(0, 0, 1, 1) }, specularMap: { value: null }, alphaMap: { value: null }, envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Pt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ge(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } } }, points: { diffuse: { value: new Ge(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, offsetRepeat: { value: new Ue(0, 0, 1, 1) } } }, qe = { basic: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.aomap, Ye.fog]), vertexShader: Be.meshbasic_vert, fragmentShader: Be.meshbasic_frag }, lambert: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.fog, Ye.lights, { emissive: { value: new Ge(0) } }]), vertexShader: Be.meshlambert_vert, fragmentShader: Be.meshlambert_frag }, phong: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.fog, Ye.lights, { emissive: { value: new Ge(0) }, specular: { value: new Ge(1118481) }, shininess: { value: 30 } }]), vertexShader: Be.meshphong_vert, fragmentShader: Be.meshphong_frag }, standard: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.aomap, Ye.lightmap, Ye.emissivemap, Ye.bumpmap, Ye.normalmap, Ye.displacementmap, Ye.roughnessmap, Ye.metalnessmap, Ye.fog, Ye.lights, { emissive: { value: new Ge(0) }, roughness: { value: .5 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Be.meshphysical_vert, fragmentShader: Be.meshphysical_frag }, points: { uniforms: t.UniformsUtils.merge([Ye.points, Ye.fog]), vertexShader: Be.points_vert, fragmentShader: Be.points_frag }, dashed: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Be.linedashed_vert, fragmentShader: Be.linedashed_frag }, depth: { uniforms: t.UniformsUtils.merge([Ye.common, Ye.displacementmap]), vertexShader: Be.depth_vert, fragmentShader: Be.depth_frag }, normal: { uniforms: { opacity: { value: 1 } }, vertexShader: Be.normal_vert, fragmentShader: Be.normal_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Be.cube_vert, fragmentShader: Be.cube_frag }, equirect: { uniforms: { tEquirect: { value: null }, tFlip: { value: -1 } }, vertexShader: Be.equirect_vert, fragmentShader: Be.equirect_frag }, distanceRGBA: { uniforms: { lightPos: { value: new kt } }, vertexShader: Be.distanceRGBA_vert, fragmentShader: Be.distanceRGBA_frag } }; function Ze(t) { Ne.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Lt, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t) } function Je(t, e) { this.min = void 0 !== t ? t : new kt(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new kt(-1 / 0, -1 / 0, -1 / 0) } function Qe(t, e) { this.center = void 0 !== t ? t : new kt, this.radius = void 0 !== e ? e : 0 } function Ke() { this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } function $e(t, e) { this.normal = void 0 !== t ? t : new kt(1, 0, 0), this.constant = void 0 !== e ? e : 0 } function ti(t, e, i, n, r, a) { this.planes = [void 0 !== t ? t : new $e, void 0 !== e ? e : new $e, void 0 !== i ? i : new $e, void 0 !== n ? n : new $e, void 0 !== r ? r : new $e, void 0 !== a ? a : new $e] } function ei(e, i, n, r) { var a = e.context, o = e.state, s = new ti, c = new Ht, h = i.shadows, l = new Pt, p = new Pt(r.maxTextureSize, r.maxTextureSize), g = new kt, v = new kt, y = [], x = new Array(4), _ = new Array(4), w = {}, b = [new kt(1, 0, 0), new kt(-1, 0, 0), new kt(0, 0, 1), new kt(0, 0, -1), new kt(0, 1, 0), new kt(0, -1, 0)], M = [new kt(0, 1, 0), new kt(0, 1, 0), new kt(0, 1, 0), new kt(0, 1, 0), new kt(0, 0, 1), new kt(0, 0, -1)], E = [new Ue, new Ue, new Ue, new Ue, new Ue, new Ue], T = new Ze; T.depthPacking = Rt, T.clipping = !0; for (var S = qe.distanceRGBA, A = t.UniformsUtils.clone(S.uniforms), L = 0; 4 !== L; ++L) { var R = 0 != (1 & L), P = 0 != (2 & L), C = T.clone(); C.morphTargets = R, C.skinning = P, x[L] = C; var U = new ze({ defines: { USE_SHADOWMAP: "" }, uniforms: A, vertexShader: S.vertexShader, fragmentShader: S.fragmentShader, morphTargets: R, skinning: P, clipping: !0 }); _[L] = U } var I = this; function D(t, i, n, r) { var a = t.geometry, o = null, s = x, c = t.customDepthMaterial; if (n && (s = _, c = t.customDistanceMaterial), c) o = c; else { var h = !1; i.morphTargets && (a && a.isBufferGeometry ? h = a.morphAttributes && a.morphAttributes.position && a.morphAttributes.position.length > 0 : a && a.isGeometry && (h = a.morphTargets && a.morphTargets.length > 0)); var l = 0; h && (l |= 1), t.isSkinnedMesh && i.skinning && (l |= 2), o = s[l] } if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { var u = o.uuid, p = i.uuid, g = w[u]; void 0 === g && (g = {}, w[u] = g); var v = g[p]; void 0 === v && (v = o.clone(), g[p] = v), o = v } o.visible = i.visible, o.wireframe = i.wireframe; var y = i.side; return I.renderSingleSided && y == m && (y = d), I.renderReverseSided && (y === d ? y = f : y === f && (y = d)), o.side = y, o.clipShadows = i.clipShadows, o.clippingPlanes = i.clippingPlanes, o.wireframeLinewidth = i.wireframeLinewidth, o.linewidth = i.linewidth, n && void 0 !== o.uniforms.lightPos && o.uniforms.lightPos.value.copy(r), o } function N(t, e, i) { if (!1 !== t.visible) { if (0 != (t.layers.mask & e.layers.mask) && (t.isMesh || t.isLine || t.isPoints)) if (t.castShadow && (!1 === t.frustumCulled || !0 === s.intersectsObject(t))) !0 === t.material.visible && (t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), y.push(t)); for (var n = t.children, r = 0, a = n.length; r < a; r++)N(n[r], e, i) } } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = u, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function (t, i) { if (!1 !== I.enabled && (!1 !== I.autoUpdate || !1 !== I.needsUpdate) && 0 !== h.length) { var r, u; o.clearColor(1, 1, 1, 1), o.disable(a.BLEND), o.setDepthTest(!0), o.setScissorTest(!1); for (var d = 0, f = h.length; d < f; d++) { var m = h[d], x = m.shadow; if (void 0 !== x) { var _ = x.camera; if (l.copy(x.mapSize), l.min(p), m && m.isPointLight) { r = 6, u = !0; var w = l.x, T = l.y; E[0].set(2 * w, T, w, T), E[1].set(0, T, w, T), E[2].set(3 * w, T, w, T), E[3].set(w, T, w, T), E[4].set(3 * w, 0, w, T), E[5].set(w, 0, w, T), l.x *= 4, l.y *= 2 } else r = 1, u = !1; if (null === x.map) { var S = { minFilter: tt, magFilter: tt, format: lt }; x.map = new De(l.x, l.y, S), _.updateProjectionMatrix() } x && x.isSpotLightShadow && x.update(m); var A = x.map, L = x.matrix; v.setFromMatrixPosition(m.matrixWorld), _.position.copy(v), e.setRenderTarget(A), e.clear(); for (var R = 0; R < r; R++) { if (u) { g.copy(_.position), g.add(b[R]), _.up.copy(M[R]), _.lookAt(g); var P = E[R]; o.viewport(P) } else g.setFromMatrixPosition(m.target.matrixWorld), _.lookAt(g); _.updateMatrixWorld(), _.matrixWorldInverse.getInverse(_.matrixWorld), L.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), L.multiply(_.projectionMatrix), L.multiply(_.matrixWorldInverse), c.multiplyMatrices(_.projectionMatrix, _.matrixWorldInverse), s.setFromMatrix(c), y.length = 0, N(t, i, _); for (var C = 0, U = y.length; C < U; C++) { var F = y[C], O = n.update(F), z = F.material; if (z && z.isMultiMaterial) for (var B = O.groups, G = z.materials, H = 0, V = B.length; H < V; H++) { var k = B[H], j = G[k.materialIndex]; if (!0 === j.visible) { var W = D(F, j, u, v); e.renderBufferDirect(_, null, O, W, F, k) } } else { W = D(F, z, u, v); e.renderBufferDirect(_, null, O, W, F, null) } } } } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.") } var X = e.getClearColor(), Y = e.getClearAlpha(); e.setClearColor(X, Y), I.needsUpdate = !1 } } } function ii(t, e, i) { var n = t.createShader(e); return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), function (t) { for (var e = t.split("\n"), i = 0; i < e.length; i++)e[i] = i + 1 + ": " + e[i]; return e.join("\n") }(i)), n } function ni() { var t = {}; return { get: function (e) { var i = e.uuid, n = t[i]; return void 0 === n && (n = {}, t[i] = n), n }, delete: function (e) { delete t[e.uuid] }, clear: function () { t = {} } } } qe.physical = { uniforms: t.UniformsUtils.merge([qe.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: Be.meshphysical_vert, fragmentShader: Be.meshphysical_frag }, Ze.prototype = Object.create(Ne.prototype), Ze.prototype.constructor = Ze, Ze.prototype.isMeshDepthMaterial = !0, Ze.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, Je.prototype = { constructor: Je, isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) { var h = t[s], l = t[s + 1], u = t[s + 2]; h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l > a && (a = l), u > o && (o = u) } this.min.set(e, i, n), this.max.set(r, a, o) }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, i = t.length; e < i; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new kt; return function (e, i) { var n = t.copy(i).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } }(), setFromObject: function () { var t = new kt; return function (e) { var i = this; return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse((function (e) { var n = e.geometry; if (void 0 !== n) if (n && n.isGeometry) for (var r = n.vertices, a = 0, o = r.length; a < o; a++)t.copy(r[a]), t.applyMatrix4(e.matrixWorld), i.expandByPoint(t); else if (n && n.isBufferGeometry) { var s = n.attributes.position; if (void 0 !== s) { var c, h, l; s && s.isInterleavedBufferAttribute ? (c = s.data.array, h = s.offset, l = s.data.stride) : (c = s.array, h = 0, l = 3); for (a = h, o = c.length; a < o; a += l)t.fromArray(c, a), t.applyMatrix4(e.matrixWorld), i.expandByPoint(t) } } })), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, center: function (t) { return (t || new kt).addVectors(this.min, this.max).multiplyScalar(.5) }, size: function (t) { return (t || new kt).subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return (e || new kt).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: function (t) { return void 0 === Ve && (Ve = new kt), this.clampPoint(t.center, Ve), Ve.distanceToSquared(t.center) <= t.radius * t.radius }, intersectsPlane: function (t) { var e, i; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant }, clampPoint: function (t, e) { return (e || new kt).copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new kt; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), getBoundingSphere: function () { var t = new kt; return function (e) { var i = e || new Qe; return i.center = this.center(), i.radius = .5 * this.size(t).length(), i } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: (He = [new kt, new kt, new kt, new kt, new kt, new kt, new kt, new kt], function (t) { return this.isEmpty() || (He[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), He[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), He[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), He[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), He[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), He[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), He[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), He[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(He)), this }), translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }, Qe.prototype = { constructor: Qe, set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: (ke = new Je, function (t, e) { var i = this.center; void 0 !== e ? i.copy(e) : ke.setFromPoints(t).center(i); for (var n = 0, r = 0, a = t.length; r < a; r++)n = Math.max(n, i.distanceToSquared(t[r])); return this.radius = Math.sqrt(n), this }), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius }, clampPoint: function (t, e) { var i = this.center.distanceToSquared(t), n = e || new kt; return n.copy(t), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n }, getBoundingBox: function (t) { var e = t || new Je; return e.set(this.center, this.center), e.expandByScalar(this.radius), e }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }, Ke.prototype = { constructor: Ke, isMatrix3: !0, set: function (t, e, i, n, r, a, o, s, c) { var h = this.elements; return h[0] = t, h[1] = n, h[2] = o, h[3] = e, h[4] = r, h[5] = s, h[6] = i, h[7] = a, h[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { var e = t.elements; return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this }, setFromMatrix4: function (t) { var e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }, applyToVector3Array: function () { var t; return function (e, i, n) { void 0 === t && (t = new kt), void 0 === i && (i = 0), void 0 === n && (n = e.length); for (var r = 0, a = i; r < n; r += 3, a += 3)t.fromArray(e, a), t.applyMatrix3(this), t.toArray(e, a); return e } }(), applyToBuffer: function () { var t; return function (e, i, n) { void 0 === t && (t = new kt), void 0 === i && (i = 0), void 0 === n && (n = e.length / e.itemSize); for (var r = 0, a = i; r < n; r++, a++)t.x = e.getX(a), t.y = e.getY(a), t.z = e.getZ(a), t.applyMatrix3(this), e.setXYZ(t.x, t.y, t.z); return e } }(), multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], a = t[4], o = t[5], s = t[6], c = t[7], h = t[8]; return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s }, getInverse: function (t, e) { t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument."); var i = t.elements, n = this.elements, r = i[0], a = i[1], o = i[2], s = i[3], c = i[4], h = i[5], l = i[6], u = i[7], p = i[8], d = p * c - h * u, f = h * l - p * s, m = u * s - c * l, g = r * d + a * f + o * m; if (0 === g) { var v = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"; if (!0 === e) throw new Error(v); return console.warn(v), this.identity() } var y = 1 / g; return n[0] = d * y, n[1] = (o * u - p * a) * y, n[2] = (h * a - o * c) * y, n[3] = f * y, n[4] = (p * r - o * l) * y, n[5] = (o * s - h * r) * y, n[6] = m * y, n[7] = (a * l - u * r) * y, n[8] = (c * r - a * s) * y, this }, transpose: function () { var t, e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), this.toArray(t, e) }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, fromArray: function (t) { return this.elements.set(t), this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var i = this.elements; return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t } }, $e.prototype = { constructor: $e, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, i, n) { return this.normal.set(t, e, i), this.constant = n, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function () { var t = new kt, e = new kt; return function (i, n, r) { var a = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize(); return this.setFromNormalAndCoplanarPoint(a, i), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return this.orthoPoint(t, e).sub(t).negate() }, orthoPoint: function (t, e) { var i = this.distanceToPoint(t); return (e || new kt).copy(this.normal).multiplyScalar(i) }, intersectLine: function () { var t = new kt; return function (e, i) { var n = i || new kt, r = e.delta(t), a = this.normal.dot(r); if (0 === a) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0; var o = -(e.start.dot(this.normal) + this.constant) / a; return o < 0 || o > 1 ? void 0 : n.copy(r).multiplyScalar(o).add(e.start) } }(), intersectsLine: function (t) { var e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end); return e < 0 && i > 0 || i < 0 && e > 0 }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return (t || new kt).copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var t = new kt, e = new Ke; return function (i, n) { var r = this.coplanarPoint(t).applyMatrix4(i), a = n || e.getNormalMatrix(i), o = this.normal.applyMatrix3(a).normalize(); return this.constant = -r.dot(o), this } }(), translate: function (t) { return this.constant = this.constant - t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }, ti.prototype = { constructor: ti, set: function (t, e, i, n, r, a) { var o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { for (var e = this.planes, i = 0; i < 6; i++)e[i].copy(t.planes[i]); return this }, setFromMatrix: function (t) { var e = this.planes, i = t.elements, n = i[0], r = i[1], a = i[2], o = i[3], s = i[4], c = i[5], h = i[6], l = i[7], u = i[8], p = i[9], d = i[10], f = i[11], m = i[12], g = i[13], v = i[14], y = i[15]; return e[0].setComponents(o - n, l - s, f - u, y - m).normalize(), e[1].setComponents(o + n, l + s, f + u, y + m).normalize(), e[2].setComponents(o + r, l + c, f + p, y + g).normalize(), e[3].setComponents(o - r, l - c, f - p, y - g).normalize(), e[4].setComponents(o - a, l - h, f - d, y - v).normalize(), e[5].setComponents(o + a, l + h, f + d, y + v).normalize(), this }, intersectsObject: (Xe = new Qe, function (t) { var e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Xe.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Xe) }), intersectsSprite: function () { var t = new Qe; return function (e) { return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t) } }(), intersectsSphere: function (t) { for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) { if (e[r].distanceToPoint(i) < n) return !1 } return !0 }, intersectsBox: (je = new kt, We = new kt, function (t) { for (var e = this.planes, i = 0; i < 6; i++) { var n = e[i]; je.x = n.normal.x > 0 ? t.min.x : t.max.x, We.x = n.normal.x > 0 ? t.max.x : t.min.x, je.y = n.normal.y > 0 ? t.min.y : t.max.y, We.y = n.normal.y > 0 ? t.max.y : t.min.y, je.z = n.normal.z > 0 ? t.min.z : t.max.z, We.z = n.normal.z > 0 ? t.max.z : t.min.z; var r = n.distanceToPoint(je), a = n.distanceToPoint(We); if (r < 0 && a < 0) return !1 } return !0 }), containsPoint: function (t) { for (var e = this.planes, i = 0; i < 6; i++)if (e[i].distanceToPoint(t) < 0) return !1; return !0 } }; var ri, ai, oi, si, ci, hi = 0; function li(t) { switch (t) { case wt: return ["Linear", "( value )"]; case bt: return ["sRGB", "( value )"]; case Et: return ["RGBE", "( value )"]; case Tt: return ["RGBM", "( value, 7.0 )"]; case St: return ["RGBM", "( value, 16.0 )"]; case At: return ["RGBD", "( value, 256.0 )"]; case Mt: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw new Error("unsupported encoding: " + t) } } function ui(t, e) { var i = li(e); return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }" } function pi(t, e) { var i; switch (e) { case G: i = "Linear"; break; case H: i = "Reinhard"; break; case V: i = "Uncharted2"; break; case k: i = "OptimizedCineon"; break; default: throw new Error("unsupported toneMapping: " + e) }return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }" } function di(t) { return "" !== t } function fi(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights) } function mi(t) { return t.replace(/#include +<([\w\d.]+)>/g, (function (t, e) { var i = Be[e]; if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">"); return mi(i) })) } function gi(t) { return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function (t, e, i, n) { for (var r = "", a = parseInt(e); a < parseInt(i); a++)r += n.replace(/\[ i \]/g, "[ " + a + " ]"); return r })) } function vi(t, e, i, n) { var r = t.context, a = i.extensions, o = i.defines, s = i.__webglShader.vertexShader, c = i.__webglShader.fragmentShader, h = "SHADOWMAP_TYPE_BASIC"; n.shadowMapType === u ? h = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === p && (h = "SHADOWMAP_TYPE_PCF_SOFT"); var l = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", f = "ENVMAP_BLENDING_MULTIPLY"; if (n.envMap) { switch (i.envMap.mapping) { case j: case W: l = "ENVMAP_TYPE_CUBE"; break; case Z: case J: l = "ENVMAP_TYPE_CUBE_UV"; break; case X: case Y: l = "ENVMAP_TYPE_EQUIREC"; break; case q: l = "ENVMAP_TYPE_SPHERE" }switch (i.envMap.mapping) { case W: case Y: d = "ENVMAP_MODE_REFRACTION" }switch (i.combine) { case F: f = "ENVMAP_BLENDING_MULTIPLY"; break; case O: f = "ENVMAP_BLENDING_MIX"; break; case z: f = "ENVMAP_BLENDING_ADD" } } var m, g, v, y, x, _ = t.gammaFactor > 0 ? t.gammaFactor : 1, w = function (t, e, i) { return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(di).join("\n") }(a, n, t.extensions), b = function (t) { var e = []; for (var i in t) { var n = t[i]; !1 !== n && e.push("#define " + i + " " + n) } return e.join("\n") }(o), M = r.createProgram(); i.isRawShaderMaterial ? (m = [b, "\n"].filter(di).join("\n"), g = [w, b, "\n"].filter(di).join("\n")) : (m = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, b, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(di).join("\n"), g = [w, "precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, b, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", "#define GAMMA_FACTOR " + _, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", n.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", n.toneMapping !== B ? "#define TONE_MAPPING" : "", n.toneMapping !== B ? Be.tonemapping_pars_fragment : "", n.toneMapping !== B ? pi("toneMapping", n.toneMapping) : "", n.outputEncoding || n.mapEncoding || n.envMapEncoding || n.emissiveMapEncoding ? Be.encodings_pars_fragment : "", n.mapEncoding ? ui("mapTexelToLinear", n.mapEncoding) : "", n.envMapEncoding ? ui("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? ui("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.outputEncoding ? (v = "linearToOutputTexel", y = n.outputEncoding, x = li(y), "vec4 " + v + "( vec4 value ) { return LinearTo" + x[0] + x[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(di).join("\n")), s = fi(s = mi(s), n), c = fi(c = mi(c), n), i.isShaderMaterial || (s = gi(s), c = gi(c)); var E = m + s, T = g + c, S = ii(r, r.VERTEX_SHADER, E), A = ii(r, r.FRAGMENT_SHADER, T); r.attachShader(M, S), r.attachShader(M, A), void 0 !== i.index0AttributeName ? r.bindAttribLocation(M, 0, i.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(M, 0, "position"), r.linkProgram(M); var L, R, P = r.getProgramInfoLog(M), C = r.getShaderInfoLog(S), U = r.getShaderInfoLog(A), I = !0, D = !0; return !1 === r.getProgramParameter(M, r.LINK_STATUS) ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(M, r.VALIDATE_STATUS), "gl.getProgramInfoLog", P, C, U)) : "" !== P ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : "" !== C && "" !== U || (D = !1), D && (this.diagnostics = { runnable: I, material: i, programLog: P, vertexShader: { log: C, prefix: m }, fragmentShader: { log: U, prefix: g } }), r.deleteShader(S), r.deleteShader(A), this.getUniforms = function () { return void 0 === L && (L = new Pe(r, M, t)), L }, this.getAttributes = function () { return void 0 === R && (R = function (t, e, i) { for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), a = 0; a < r; a++) { var o = t.getActiveAttrib(e, a).name; n[o] = t.getAttribLocation(e, o) } return n }(r, M)), R }, this.destroy = function () { r.deleteProgram(M), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function () { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function () { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.id = hi++, this.code = e, this.usedTimes = 1, this.program = M, this.vertexShader = S, this.fragmentShader = A, this } function yi(t, e) { var i = [], n = { MeshDepthMaterial: "depth", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points" }, r = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"]; function a(t, e) { var i; return t ? t && t.isTexture ? i = t.encoding : t && t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = wt, i === wt && e && (i = Mt), i } this.getParameters = function (i, r, o, s, c) { var h = n[i.type], l = function (t) { if (e.floatVertexTextures && t && t.skeleton && t.skeleton.useVertexTexture) return 1024; var i = e.maxVertexUniforms, n = Math.floor((i - 20) / 4); return void 0 !== t && t && t.isSkinnedMesh && (n = Math.min(t.skeleton.bones.length, n)) < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + n + " (try OpenGL instead of ANGLE)"), n }(c), u = t.getPrecision(); null !== i.precision && (u = e.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", u, "instead."); var p = t.getCurrentRenderTarget(); return { shaderID: h, precision: u, supportsVertexTextures: e.vertexTextures, outputEncoding: a(p ? p.texture : null, t.gammaOutput), map: !!i.map, mapEncoding: a(i.map, t.gammaInput), envMap: !!i.envMap, envMapMode: i.envMap && i.envMap.mapping, envMapEncoding: a(i.envMap, t.gammaInput), envMapCubeUV: !!i.envMap && (i.envMap.mapping === Z || i.envMap.mapping === J), lightMap: !!i.lightMap, aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: a(i.emissiveMap, t.gammaInput), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, combine: i.combine, vertexColors: i.vertexColors, fog: !!o, useFog: i.fog, fogExp: o && o.isFogExp2, flatShading: i.shading === g, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: e.logarithmicDepthBuffer, skinning: i.skinning, maxBones: l, useVertexTexture: e.floatVertexTextures && c && c.skeleton && c.skeleton.useVertexTexture, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: r.directional.length, numPointLights: r.point.length, numSpotLights: r.spot.length, numHemiLights: r.hemi.length, numClippingPlanes: s, shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && r.shadows.length > 0, shadowMapType: t.shadowMap.type, toneMapping: t.toneMapping, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === m, flipSided: i.side === f, depthPacking: void 0 !== i.depthPacking && i.depthPacking } }, this.getProgramCode = function (t, e) { var i = []; if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines) for (var n in t.defines) i.push(n), i.push(t.defines[n]); for (var a = 0; a < r.length; a++)i.push(e[r[a]]); return i.join() }, this.acquireProgram = function (e, n, r) { for (var a, o = 0, s = i.length; o < s; o++) { var c = i[o]; if (c.code === r) { ++(a = c).usedTimes; break } } return void 0 === a && (a = new vi(t, r, e, n), i.push(a)), a }, this.releaseProgram = function (t) { if (0 == --t.usedTimes) { var e = i.indexOf(t); i[e] = i[i.length - 1], i.pop(), t.destroy() } }, this.programs = i } function xi(e, i, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.uuid = t.Math.generateUUID(), this.array = e, this.itemSize = i, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function _i(t, e) { return new xi(new Uint16Array(t), e) } function wi(t, e) { return new xi(new Uint32Array(t), e) } function bi(t, e) { return new xi(new Float32Array(t), e) } function Mi(t, e, i, n, r, a) { this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new kt, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Ge, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 } function Ei(t, e, i, n) { this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || Ei.DefaultOrder } function Ti() { this.mask = 1 } function Si() { Object.defineProperty(this, "id", { value: Ri() }), this.uuid = t.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Si.DefaultUp.clone(); var e = new kt, i = new Ei, n = new Vt, r = new kt(1, 1, 1); i.onChange((function () { n.setFromEuler(i, !1) })), n.onChange((function () { i.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { enumerable: !0, value: e }, rotation: { enumerable: !0, value: i }, quaternion: { enumerable: !0, value: n }, scale: { enumerable: !0, value: r }, modelViewMatrix: { value: new Ht }, normalMatrix: { value: new Ke } }), this.matrix = new Ht, this.matrixWorld = new Ht, this.matrixAutoUpdate = Si.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Ti, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } xi.prototype = { constructor: xi, isBufferAttribute: !0, get count() { return this.array.length / this.itemSize }, set needsUpdate(t) { !0 === t && this.version++ }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.normalized = t.normalized, this.dynamic = t.dynamic, this }, copyAt: function (t, e, i) { t *= this.itemSize, i *= e.itemSize; for (var n = 0, r = this.itemSize; n < r; n++)this.array[t + n] = e.array[i + n]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new Ge), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b } return this }, copyIndicesArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; e[i++] = a.a, e[i++] = a.b, e[i++] = a.c } return this }, copyVector2sArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new Pt), e[i++] = a.x, e[i++] = a.y } return this }, copyVector3sArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new kt), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z } return this }, copyVector4sArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new Ue), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w } return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this }, setXYZ: function (t, e, i, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this }, setXYZW: function (t, e, i, n, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this }, clone: function () { return (new this.constructor).copy(this) } }, Mi.prototype = { constructor: Mi, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, i = t.vertexNormals.length; e < i; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (e = 0, i = t.vertexColors.length; e < i; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }, Ei.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ei.DefaultOrder = "XYZ", Ei.prototype = { constructor: Ei, isEuler: !0, get x() { return this._x }, set x(t) { this._x = t, this.onChangeCallback() }, get y() { return this._y }, set y(t) { this._y = t, this.onChangeCallback() }, get z() { return this._z }, set z(t) { this._z = t, this.onChangeCallback() }, get order() { return this._order }, set order(t) { this._order = t, this.onChangeCallback() }, set: function (t, e, i, n) { return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (e, i, n) { var r = t.Math.clamp, a = e.elements, o = a[0], s = a[4], c = a[8], h = a[1], l = a[5], u = a[9], p = a[2], d = a[6], f = a[10]; return "XYZ" === (i = i || this._order) ? (this._y = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === i ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(c, f), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-p, o), this._z = 0)) : "ZXY" === i ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-p, f), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(h, o))) : "ZYX" === i ? (this._y = Math.asin(-r(p, -1, 1)), Math.abs(p) < .99999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-s, l))) : "YZX" === i ? (this._z = Math.asin(r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-p, o)) : (this._x = 0, this._y = Math.atan2(c, f))) : "XZY" === i ? (this._z = Math.asin(-r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-u, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + i), this._order = i, !1 !== n && this.onChangeCallback(), this }, setFromQuaternion: function () { var t; return function (e, i, n) { return void 0 === t && (t = new Ht), t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n) } }(), setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: (ri = new Vt, function (t) { return ri.setFromEuler(this), this.setFromQuaternion(ri, t) }), equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new kt(this._x, this._y, this._z) }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }, Ti.prototype = { constructor: Ti, set: function (t) { this.mask = 1 << t }, enable: function (t) { this.mask |= 1 << t }, toggle: function (t) { this.mask ^= 1 << t }, disable: function (t) { this.mask &= ~(1 << t) }, test: function (t) { return 0 != (this.mask & t.mask) } }, Si.DefaultUp = new kt(0, 1, 0), Si.DefaultMatrixAutoUpdate = !0, Object.assign(Si.prototype, e.prototype, { isObject3D: !0, applyMatrix: function (t) { this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: (ci = new Vt, function (t, e) { return ci.setFromAxisAngle(t, e), this.quaternion.multiply(ci), this }), rotateX: function () { var t = new kt(1, 0, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateY: function () { var t = new kt(0, 1, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateZ: function () { var t = new kt(0, 0, 1); return function (e) { return this.rotateOnAxis(t, e) } }(), translateOnAxis: function () { var t = new kt; return function (e, i) { return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this } }(), translateX: function () { var t = new kt(1, 0, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateY: function () { var t = new kt(0, 1, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateZ: function () { var t = new kt(0, 0, 1); return function (e) { return this.translateOnAxis(t, e) } }(), localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: (si = new Ht, function (t) { return t.applyMatrix4(si.getInverse(this.matrixWorld)) }), lookAt: function () { var t = new Ht; return function (e) { t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t) } }(), add: function (t) { if (arguments.length > 1) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]); var i = this.children.indexOf(t); -1 !== i && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(i, 1)) }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (var i = 0, n = this.children.length; i < n; i++) { var r = this.children[i].getObjectByProperty(t, e); if (void 0 !== r) return r } }, getWorldPosition: function (t) { var e = t || new kt; return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: (ai = new kt, oi = new kt, function (t) { var e = t || new Vt; return this.updateMatrixWorld(!0), this.matrixWorld.decompose(ai, e, oi), e }), getWorldRotation: function () { var t = new Vt; return function (e) { var i = e || new Ei; return this.getWorldQuaternion(t), i.setFromQuaternion(t, this.rotation.order, !1) } }(), getWorldScale: function () { var t = new kt, e = new Vt; return function (i) { var n = i || new kt; return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n } }(), getWorldDirection: function () { var t = new Vt; return function (e) { var i = e || new kt; return this.getWorldQuaternion(t), i.set(0, 0, 1).applyQuaternion(t) } }(), raycast: function () { }, traverse: function (t) { t(this); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].traverseVisible(t) } }, traverseAncestors: function (t) { var e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== t || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].updateMatrixWorld(t) }, toJSON: function (t) { var e = void 0 === t || "" === t, i = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {} }, i.metadata = { version: 4.4, type: "Object", generator: "Object3D.toJSON" }); var n = {}; if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), n.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), n.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), n.material = this.material.uuid), this.children.length > 0) { n.children = []; for (var r = 0; r < this.children.length; r++)n.children.push(this.children[r].toJSON(t).object) } if (e) { var a = h(t.geometries), o = h(t.materials), s = h(t.textures), c = h(t.images); a.length > 0 && (i.geometries = a), o.length > 0 && (i.materials = o), s.length > 0 && (i.textures = s), c.length > 0 && (i.images = c) } return i.object = n, i; function h(t) { var e = []; for (var i in t) { var n = t[i]; delete n.metadata, e.push(n) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var i = 0; i < t.children.length; i++) { var n = t.children[i]; this.add(n.clone()) } return this } }); var Ai, Li = 0; function Ri() { return Li++ } function Pi() { Object.defineProperty(this, "id", { value: Hi() }), this.uuid = t.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } Object.assign(Pi.prototype, e.prototype, { isGeometry: !0, applyMatrix: function (t) { for (var e = (new Ke).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) { this.vertices[i].applyMatrix4(t) } for (i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i]; r.normal.applyMatrix3(e).normalize(); for (var a = 0, o = r.vertexNormals.length; a < o; a++)r.vertexNormals[a].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationX(e), this.applyMatrix(t), this } }(), rotateY: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationY(e), this.applyMatrix(t), this } }(), rotateZ: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationZ(e), this.applyMatrix(t), this } }(), translate: function () { var t; return function (e, i, n) { return void 0 === t && (t = new Ht), t.makeTranslation(e, i, n), this.applyMatrix(t), this } }(), scale: function () { var t; return function (e, i, n) { return void 0 === t && (t = new Ht), t.makeScale(e, i, n), this.applyMatrix(t), this } }(), lookAt: function (t) { void 0 === Ai && (Ai = new Si), Ai.lookAt(t), Ai.updateMatrix(), this.applyMatrix(Ai.matrix) }, fromBufferGeometry: function (t) { var e = this, i = null !== t.index ? t.index.array : void 0, n = t.attributes, r = n.position.array, a = void 0 !== n.normal ? n.normal.array : void 0, o = void 0 !== n.color ? n.color.array : void 0, s = void 0 !== n.uv ? n.uv.array : void 0, c = void 0 !== n.uv2 ? n.uv2.array : void 0; void 0 !== c && (this.faceVertexUvs[1] = []); for (var h = [], l = [], u = [], p = 0, d = 0; p < r.length; p += 3, d += 2)e.vertices.push(new kt(r[p], r[p + 1], r[p + 2])), void 0 !== a && h.push(new kt(a[p], a[p + 1], a[p + 2])), void 0 !== o && e.colors.push(new Ge(o[p], o[p + 1], o[p + 2])), void 0 !== s && l.push(new Pt(s[d], s[d + 1])), void 0 !== c && u.push(new Pt(c[d], c[d + 1])); function f(t, i, n, r) { var p = new Mi(t, i, n, void 0 !== a ? [h[t].clone(), h[i].clone(), h[n].clone()] : [], void 0 !== o ? [e.colors[t].clone(), e.colors[i].clone(), e.colors[n].clone()] : [], r); e.faces.push(p), void 0 !== s && e.faceVertexUvs[0].push([l[t].clone(), l[i].clone(), l[n].clone()]), void 0 !== c && e.faceVertexUvs[1].push([u[t].clone(), u[i].clone(), u[n].clone()]) } if (void 0 !== i) { var m = t.groups; if (m.length > 0) for (p = 0; p < m.length; p++)for (var g = m[p], v = g.start, y = (d = v, v + g.count); d < y; d += 3)f(i[d], i[d + 1], i[d + 2], g.materialIndex); else for (p = 0; p < i.length; p += 3)f(i[p], i[p + 1], i[p + 2]) } else for (p = 0; p < r.length / 3; p += 3)f(p, p + 1, p + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { this.computeBoundingBox(); var t = this.boundingBox.center().negate(); return this.translate(t.x, t.y, t.z), t }, normalize: function () { this.computeBoundingSphere(); var t = this.boundingSphere.center, e = this.boundingSphere.radius, i = 0 === e ? 1 : 1 / e, n = new Ht; return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this }, computeFaceNormals: function () { for (var t = new kt, e = new kt, i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i], a = this.vertices[r.a], o = this.vertices[r.b], s = this.vertices[r.c]; t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t) } }, computeVertexNormals: function (t) { var e, i, n, r, a, o; for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++)o[e] = new kt; if (t) { var s, c, h, l = new kt, u = new kt; for (n = 0, r = this.faces.length; n < r; n++)a = this.faces[n], s = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], l.subVectors(h, c), u.subVectors(s, c), l.cross(u), o[a.a].add(l), o[a.b].add(l), o[a.c].add(l) } else for (n = 0, r = this.faces.length; n < r; n++)o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal); for (e = 0, i = this.vertices.length; e < i; e++)o[e].normalize(); for (n = 0, r = this.faces.length; n < r; n++) { var p = (a = this.faces[n]).vertexNormals; 3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var t, e, i, n, r; for (i = 0, n = this.faces.length; i < n; i++)for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++)r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone(); var a = new Pi; for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) { if (!this.morphNormals[t]) { this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = []; var o = this.morphNormals[t].faceNormals, s = this.morphNormals[t].vertexNormals; for (i = 0, n = this.faces.length; i < n; i++)c = new kt, h = { a: new kt, b: new kt, c: new kt }, o.push(c), s.push(h) } var c, h, l = this.morphNormals[t]; for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++)r = this.faces[i], c = l.faceNormals[i], h = l.vertexNormals[i], c.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2]) } for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals }, computeTangents: function () { console.warn("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++)i > 0 && (t += e[i].distanceTo(e[i - 1])), this.lineDistances[i] = t }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Je), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Qe), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, i) { if (!1 !== (t && t.isGeometry)) { var n, r = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, c = t.faces, h = this.faceVertexUvs[0], l = t.faceVertexUvs[0]; void 0 === i && (i = 0), void 0 !== e && (n = (new Ke).getNormalMatrix(e)); for (var u = 0, p = o.length; u < p; u++) { var d = o[u].clone(); void 0 !== e && d.applyMatrix4(e), a.push(d) } for (u = 0, p = c.length; u < p; u++) { var f, m, g, v = c[u], y = v.vertexNormals, x = v.vertexColors; (f = new Mi(v.a + r, v.b + r, v.c + r)).normal.copy(v.normal), void 0 !== n && f.normal.applyMatrix3(n).normalize(); for (var _ = 0, w = y.length; _ < w; _++)m = y[_].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), f.vertexNormals.push(m); f.color.copy(v.color); for (_ = 0, w = x.length; _ < w; _++)g = x[_], f.vertexColors.push(g.clone()); f.materialIndex = v.materialIndex + i, s.push(f) } for (u = 0, p = l.length; u < p; u++) { var b = l[u], M = []; if (void 0 !== b) { for (_ = 0, w = b.length; _ < w; _++)M.push(b[_].clone()); h.push(M) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t) }, mergeMesh: function (t) { !1 !== (t && t.isMesh) ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { var t, e, i, n, r, a, o, s, c = {}, h = [], l = [], u = Math.pow(10, 4); for (i = 0, n = this.vertices.length; i < n; i++)t = this.vertices[i], void 0 === c[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (c[e] = i, h.push(this.vertices[i]), l[i] = h.length - 1) : l[i] = l[c[e]]; var p = []; for (i = 0, n = this.faces.length; i < n; i++) { (r = this.faces[i]).a = l[r.a], r.b = l[r.b], r.c = l[r.c], a = [r.a, r.b, r.c]; for (var d = 0; d < 3; d++)if (a[d] === a[(d + 1) % 3]) { d, p.push(i); break } } for (i = p.length - 1; i >= 0; i--) { var f = p[i]; for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)this.faceVertexUvs[o].splice(f, 1) } var m = this.vertices.length - h.length; return this.vertices = h, m }, sortFacesByMaterialIndex: function () { for (var t = this.faces, e = t.length, i = 0; i < e; i++)t[i]._id = i; t.sort((function (t, e) { return t.materialIndex - e.materialIndex })); var n, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1]; a && a.length === e && (n = []), o && o.length === e && (r = []); for (i = 0; i < e; i++) { var s = t[i]._id; n && n.push(a[s]), r && r.push(o[s]) } n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r) }, toJSON: function () { var t = { metadata: { version: 4.4, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e = this.parameters; for (var i in e) void 0 !== e[i] && (t[i] = e[i]); return t } for (var n = [], r = 0; r < this.vertices.length; r++) { var a = this.vertices[r]; n.push(a.x, a.y, a.z) } var o = [], s = [], c = {}, h = [], l = {}, u = [], p = {}; for (r = 0; r < this.faces.length; r++) { var d = this.faces[r], f = void 0 !== this.faceVertexUvs[0][r], m = d.normal.length() > 0, g = d.vertexNormals.length > 0, v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b, y = d.vertexColors.length > 0, x = 0; if (x = M(x, 0, 0), x = M(x, 1, !0), x = M(x, 2, !1), x = M(x, 3, f), x = M(x, 4, m), x = M(x, 5, g), x = M(x, 6, v), x = M(x, 7, y), o.push(x), o.push(d.a, d.b, d.c), o.push(d.materialIndex), f) { var _ = this.faceVertexUvs[0][r]; o.push(S(_[0]), S(_[1]), S(_[2])) } if (m && o.push(E(d.normal)), g) { var w = d.vertexNormals; o.push(E(w[0]), E(w[1]), E(w[2])) } if (v && o.push(T(d.color)), y) { var b = d.vertexColors; o.push(T(b[0]), T(b[1]), T(b[2])) } } function M(t, e, i) { return i ? t | 1 << e : t & ~(1 << e) } function E(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[e] } function T(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== l[e] || (l[e] = h.length, h.push(t.getHex())), l[e] } function S(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e] } return t.data = {}, t.data.vertices = n, t.data.normals = s, h.length > 0 && (t.data.colors = h), u.length > 0 && (t.data.uvs = [u]), t.data.faces = o, t }, clone: function () { return (new Pi).copy(this) }, copy: function (t) { this.vertices = [], this.faces = [], this.faceVertexUvs = [[]]; for (var e = t.vertices, i = 0, n = e.length; i < n; i++)this.vertices.push(e[i].clone()); var r = t.faces; for (i = 0, n = r.length; i < n; i++)this.faces.push(r[i].clone()); for (i = 0, n = t.faceVertexUvs.length; i < n; i++) { var a = t.faceVertexUvs[i]; void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []); for (var o = 0, s = a.length; o < s; o++) { for (var c = a[o], h = [], l = 0, u = c.length; l < u; l++) { var p = c[l]; h.push(p.clone()) } this.faceVertexUvs[i].push(h) } } return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var Ci, Ui, Ii, Di, Ni, Fi, Oi, zi, Bi, Gi = 0; function Hi() { return Gi++ } function Vi() { Object.defineProperty(this, "id", { value: Hi() }), this.uuid = t.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function ki() { Object.defineProperty(this, "id", { value: Hi() }), this.uuid = t.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 } } function ji(t, e, i) { var n = {}; function r(t) { var o = t.target, s = n[o.id]; null !== s.index && a(s.index), function (t) { for (var e in t) a(t[e]) }(s.attributes), o.removeEventListener("dispose", r), delete n[o.id]; var c = e.get(o); c.wireframe && a(c.wireframe), e.delete(o); var h = e.get(s); h.wireframe && a(h.wireframe), e.delete(s), i.memory.geometries-- } function a(i) { var n = function (t) { return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer }(i); void 0 !== n && (t.deleteBuffer(n), function (t) { t.isInterleavedBufferAttribute ? e.delete(t.data) : e.delete(t) }(i)) } return { get: function (t) { var e, a = t.geometry; return void 0 !== n[a.id] ? n[a.id] : (a.addEventListener("dispose", r), a.isBufferGeometry ? e = a : a.isGeometry && (void 0 === a._bufferGeometry && (a._bufferGeometry = (new ki).setFromObject(t)), e = a._bufferGeometry), n[a.id] = e, i.memory.geometries++, e) } } } function Wi(t, e, i) { var n = new ji(t, e, i); function r(i, n) { var r = i.isInterleavedBufferAttribute ? i.data : i, a = e.get(r); void 0 === a.__webglBuffer ? function (e, i, n) { e.__webglBuffer = t.createBuffer(), t.bindBuffer(n, e.__webglBuffer); var r = i.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW; t.bufferData(n, i.array, r), e.version = i.version }(a, r, n) : a.version !== r.version && function (e, i, n) { t.bindBuffer(n, e.__webglBuffer), !1 === i.dynamic || -1 === i.updateRange.count ? t.bufferSubData(n, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)), i.updateRange.count = 0); e.version = i.version }(a, r, n) } function a(t, e, i) { if (e > i) { var n = e; e = i, i = n } var r = t[e]; return void 0 === r ? (t[e] = [i], !0) : -1 === r.indexOf(i) && (r.push(i), !0) } return { getAttributeBuffer: function (t) { return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer }, getWireframeAttribute: function (i) { var n = e.get(i); if (void 0 !== n.wireframe) return n.wireframe; var o, s = [], c = i.index, h = i.attributes, l = h.position; if (null !== c) for (var u = {}, p = 0, d = (o = c.array).length; p < d; p += 3) { var f = o[p + 0], m = o[p + 1], g = o[p + 2]; a(u, f, m) && s.push(f, m), a(u, m, g) && s.push(m, g), a(u, g, f) && s.push(g, f) } else for (p = 0, d = (o = h.position.array).length / 3 - 1; p < d; p += 3) { f = p + 0, m = p + 1, g = p + 2; s.push(f, m, m, g, g, f) } var v = new xi(new (l.count > 65535 ? Uint32Array : Uint16Array)(s), 1); return r(v, t.ELEMENT_ARRAY_BUFFER), n.wireframe = v, v }, update: function (e) { var i = n.get(e); e.geometry.isGeometry && i.updateFromObject(e); var a = i.index, o = i.attributes; for (var s in null !== a && r(a, t.ELEMENT_ARRAY_BUFFER), o) r(o[s], t.ARRAY_BUFFER); var c = i.morphAttributes; for (var s in c) for (var h = c[s], l = 0, u = h.length; l < u; l++)r(h[l], t.ARRAY_BUFFER); return i } } } function Xi() { var t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; var i; switch (e.type) { case "DirectionalLight": i = { direction: new kt, color: new Ge, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pt }; break; case "SpotLight": i = { position: new kt, direction: new kt, color: new Ge, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pt }; break; case "PointLight": i = { position: new kt, color: new Ge, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Pt }; break; case "HemisphereLight": i = { direction: new kt, skyColor: new Ge, groundColor: new Ge } }return t[e.id] = i, i } } } function Yi(t, e, i) { var n; function r(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } var a = void 0 !== i.precision ? i.precision : "highp", o = r(a); return o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o), { getMaxAnisotropy: function () { if (void 0 !== n) return n; var i = e.get("EXT_texture_filter_anisotropic"); return n = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: a, logarithmicDepthBuffer: !0 === i.logarithmicDepthBuffer && !!e.get("EXT_frag_depth"), maxTextures: t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), maxVertexTextures: t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize: t.getParameter(t.MAX_TEXTURE_SIZE), maxCubemapSize: t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes: t.getParameter(t.MAX_VERTEX_ATTRIBS), maxVertexUniforms: t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings: t.getParameter(t.MAX_VARYING_VECTORS), maxFragmentUniforms: t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: this.maxVertexTextures > 0, floatFragmentTextures: !!e.get("OES_texture_float"), floatVertexTextures: this.vertexTextures && this.floatFragmentTextures } } function qi(t) { var e = {}; return { get: function (i) { if (void 0 !== e[i]) return e[i]; var n; switch (i) { case "WEBGL_depth_texture": n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; case "WEBGL_compressed_texture_etc1": n = t.getExtension("WEBGL_compressed_texture_etc1"); break; default: n = t.getExtension(i) }return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n } } } function Zi(t, e, i) { var n, r, a; return { setMode: function (t) { n = t }, setIndex: function (i) { i.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (r = t.UNSIGNED_INT, a = 4) : (r = t.UNSIGNED_SHORT, a = 2) }, render: function (e, o) { t.drawElements(n, o, r, e * a), i.calls++, i.vertices += o, n === t.TRIANGLES && (i.faces += o / 3) }, renderInstances: function (o, s, c) { var h = e.get("ANGLE_instanced_arrays"); null !== h ? (h.drawElementsInstancedANGLE(n, c, r, s * a, o.maxInstancedCount), i.calls++, i.vertices += c * o.maxInstancedCount, n === t.TRIANGLES && (i.faces += o.maxInstancedCount * c / 3)) : console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") } } } function Ji() { var t = this, e = null, i = 0, n = !1, r = !1, a = new $e, o = new Ke, s = { value: null, needsUpdate: !1 }; function c() { s.value !== e && (s.value = e, s.needsUpdate = i > 0), t.numPlanes = i } function h(e, i, n, r) { var c = null !== e ? e.length : 0, h = null; if (0 !== c) { if (h = s.value, !0 !== r || null === h) { var l = n + 4 * c, u = i.matrixWorldInverse; o.getNormalMatrix(u), (null === h || h.length < l) && (h = new Float32Array(l)); for (var p = 0, d = n; p !== c; ++p, d += 4)a.copy(e[p]).applyMatrix4(u, o), a.normal.toArray(h, d), h[d + 3] = a.constant } s.value = h, s.needsUpdate = !0 } return t.numPlanes = c, h } this.uniform = s, this.numPlanes = 0, this.init = function (t, r, a) { var o = 0 !== t.length || r || 0 !== i || n; return n = r, e = h(t, a, 0), i = t.length, o }, this.beginShadows = function () { r = !0, h(null) }, this.endShadows = function () { r = !1, c() }, this.setState = function (t, a, o, l, u) { if (!n || null === t || 0 === t.length || r && !a) r ? h(null) : c(); else { var p = r ? 0 : i, d = 4 * p, f = l.clippingState || null; s.value = f, f = h(t, o, d, u); for (var m = 0; m !== d; ++m)f[m] = e[m]; l.clippingState = f, this.numPlanes += p } } } function Qi(t, e, i) { var n; return { setMode: function (t) { n = t }, render: function (e, r) { t.drawArrays(n, e, r), i.calls++, i.vertices += r, n === t.TRIANGLES && (i.faces += r / 3) }, renderInstances: function (r) { var a = e.get("ANGLE_instanced_arrays"); if (null !== a) { var o = r.attributes.position, s = 0; o && o.isInterleavedBufferAttribute ? (s = o.data.count, a.drawArraysInstancedANGLE(n, 0, s, r.maxInstancedCount)) : (s = o.count, a.drawArraysInstancedANGLE(n, 0, s, r.maxInstancedCount)), i.calls++, i.vertices += s * r.maxInstancedCount, n === t.TRIANGLES && (i.faces += r.maxInstancedCount * s / 3) } else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") } } } function Ki(t, e, i) { De.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0 } function $i(t, e, i, n, r, a) { ki.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }; var o, s, c, h, l = this, u = function (t, e, i) { var n = 0; return n += (t + 1) * (e + 1) * 2, n += (t + 1) * (i + 1) * 2, n += (i + 1) * (e + 1) * 2, n }(n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1), p = (h = 0, h += (o = n) * (s = r) * 2, h += o * (c = a) * 2, 6 * (h += c * s * 2)), d = new (p > 65535 ? Uint32Array : Uint16Array)(p), f = new Float32Array(3 * u), m = new Float32Array(3 * u), g = new Float32Array(2 * u), v = 0, y = 0, x = 0, _ = 0, w = 0; function b(t, e, i, n, r, a, o, s, c, h, u) { for (var p = a / c, b = o / h, M = a / 2, E = o / 2, T = s / 2, S = c + 1, A = h + 1, L = 0, R = 0, P = new kt, C = 0; C < A; C++)for (var U = C * b - E, I = 0; I < S; I++) { var D = I * p - M; P[t] = D * n, P[e] = U * r, P[i] = T, f[v] = P.x, f[v + 1] = P.y, f[v + 2] = P.z, P[t] = 0, P[e] = 0, P[i] = s > 0 ? 1 : -1, m[v] = P.x, m[v + 1] = P.y, m[v + 2] = P.z, g[y] = I / c, g[y + 1] = 1 - C / h, v += 3, y += 2, L += 1 } for (C = 0; C < h; C++)for (I = 0; I < c; I++) { var N = _ + I + S * C, F = _ + I + S * (C + 1), O = _ + (I + 1) + S * (C + 1), z = _ + (I + 1) + S * C; d[x] = N, d[x + 1] = F, d[x + 2] = z, d[x + 3] = F, d[x + 4] = O, d[x + 5] = z, x += 6, R += 6 } l.addGroup(w, R, u), w += R, _ += L } b("z", "y", "x", -1, -1, i, e, t, a, r, 0), b("z", "y", "x", 1, -1, i, e, -t, a, r, 1), b("x", "z", "y", 1, 1, t, i, e, n, a, 2), b("x", "z", "y", 1, -1, t, i, -e, n, a, 3), b("x", "y", "z", 1, -1, t, e, i, n, r, 4), b("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(new xi(d, 1)), this.addAttribute("position", new xi(f, 3)), this.addAttribute("normal", new xi(m, 3)), this.addAttribute("uv", new xi(g, 2)) } function tn(t, e) { this.origin = void 0 !== t ? t : new kt, this.direction = void 0 !== e ? e : new kt } function en(t, e) { this.start = void 0 !== t ? t : new kt, this.end = void 0 !== e ? e : new kt } function nn(t, e, i) { this.a = void 0 !== t ? t : new kt, this.b = void 0 !== e ? e : new kt, this.c = void 0 !== i ? i : new kt } function rn(t) { Ne.call(this), this.type = "MeshBasicMaterial", this.color = new Ge(16777215), this.map = null, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t) } function an(t, e) { Si.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ki, this.material = void 0 !== e ? e : new rn({ color: 16777215 * Math.random() }), this.drawMode = _t, this.updateMorphTargets() } function on(t, e, i, n) { ki.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }; for (var r = t / 2, a = e / 2, o = Math.floor(i) || 1, s = Math.floor(n) || 1, c = o + 1, h = s + 1, l = t / o, u = e / s, p = new Float32Array(c * h * 3), d = new Float32Array(c * h * 3), f = new Float32Array(c * h * 2), m = 0, g = 0, v = 0; v < h; v++)for (var y = v * u - a, x = 0; x < c; x++) { var _ = x * l - r; p[m] = _, p[m + 1] = -y, d[m + 2] = 1, f[g] = x / o, f[g + 1] = 1 - v / s, m += 3, g += 2 } m = 0; var w = new (p.length / 3 > 65535 ? Uint32Array : Uint16Array)(o * s * 6); for (v = 0; v < s; v++)for (x = 0; x < o; x++) { var b = x + c * v, M = x + c * (v + 1), E = x + 1 + c * (v + 1), T = x + 1 + c * v; w[m] = b, w[m + 1] = M, w[m + 2] = T, w[m + 3] = M, w[m + 4] = E, w[m + 5] = T, m += 6 } this.setIndex(new xi(w, 1)), this.addAttribute("position", new xi(p, 3)), this.addAttribute("normal", new xi(d, 3)), this.addAttribute("uv", new xi(f, 2)) } function sn() { Si.call(this), this.type = "Camera", this.matrixWorldInverse = new Ht, this.projectionMatrix = new Ht } function cn(t, e, i, n) { sn.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function hn(t, e, i, n, r, a) { sn.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() } function ln(e) { console.log("THREE.WebGLRenderer", "80"); var i = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = void 0 !== e.context ? e.context : null, r = void 0 !== e.alpha && e.alpha, a = void 0 === e.depth || e.depth, o = void 0 === e.stencil || e.stencil, s = void 0 !== e.antialias && e.antialias, c = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, h = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, l = [], u = [], p = -1, d = [], v = -1, _ = new Float32Array(8), w = [], b = []; this.domElement = i, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = G, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var M, E = this, L = null, R = null, P = null, C = -1, U = "", I = null, D = new Ue, N = null, F = new Ue, O = 0, z = new Ge(0), B = 0, H = i.width, V = i.height, k = 1, j = new Ue(0, 0, H, V), W = !1, X = new Ue(0, 0, H, V), Y = new ti, q = new Ji, Z = !1, J = !1, ut = new Qe, ft = new Ht, mt = new kt, gt = { hash: "", ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], shadows: [] }, vt = { calls: 0, vertices: 0, faces: 0, points: 0 }; this.info = { render: vt, memory: { geometries: 0, textures: 0 }, programs: null }; try { var yt = { alpha: r, depth: a, stencil: o, antialias: s, premultipliedAlpha: c, preserveDrawingBuffer: h }; if (null === (M = n || i.getContext("webgl", yt) || i.getContext("experimental-webgl", yt))) throw null !== i.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context."; void 0 === M.getShaderPrecisionFormat && (M.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }), i.addEventListener("webglcontextlost", Yt, !1) } catch (t) { console.error("THREE.WebGLRenderer: " + t) } var xt = new qi(M); xt.get("WEBGL_depth_texture"), xt.get("OES_texture_float"), xt.get("OES_texture_float_linear"), xt.get("OES_texture_half_float"), xt.get("OES_texture_half_float_linear"), xt.get("OES_standard_derivatives"), xt.get("ANGLE_instanced_arrays"), xt.get("OES_element_index_uint") && (ki.MaxIndex = 4294967296); var wt = new Yi(M, xt, e), bt = new Ie(M, xt, se), Mt = new ni, Et = new Ce(M, xt, bt, Mt, wt, se, this.info), Tt = new Wi(M, Mt, this.info), St = new yi(this, wt), At = new Xi; this.info.programs = St.programs; var Lt = new Qi(M, xt, vt), Rt = new Zi(M, xt, vt), Pt = new hn(-1, 1, 1, -1, 0, 1), Ct = new cn, Ut = new an(new on(2, 2), new rn({ depthTest: !1, depthWrite: !1, fog: !1 })), It = qe.cube, Dt = new an(new $i(5, 5, 5), new ze({ uniforms: It.uniforms, vertexShader: It.vertexShader, fragmentShader: It.fragmentShader, side: f, depthTest: !1, depthWrite: !1, fog: !1 })); function Nt() { return null === R ? k : 1 } function Ft(t, e, i, n) { !0 === c && (t *= n, e *= n, i *= n), bt.clearColor(t, e, i, n) } function Ot() { bt.init(), bt.scissor(D.copy(j).multiplyScalar(k)), bt.viewport(F.copy(X).multiplyScalar(k)), Ft(z.r, z.g, z.b, B) } function zt() { L = null, I = null, U = "", C = -1, bt.reset() } Ot(), this.context = M, this.capabilities = wt, this.extensions = xt, this.properties = Mt, this.state = bt; var Bt = new ei(this, gt, Tt, wt); this.shadowMap = Bt; var Gt, Vt = new jt(this, w), Wt = new Xt(this, b); function Yt(t) { t.preventDefault(), zt(), Ot(), Mt.clear() } function qt(t) { var e = t.target; e.removeEventListener("dispose", qt), function (t) { Zt(t), Mt.delete(t) }(e) } function Zt(t) { var e = Mt.get(t).program; t.program = void 0, void 0 !== e && St.releaseProgram(e) } function Jt(t, e) { return Math.abs(e[0]) - Math.abs(t[0]) } function Qt(t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.program && e.material.program && t.material.program !== e.material.program ? t.material.program.id - e.material.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function Kt(t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function $t(t, e, i, n, r) { var a, o; i.transparent ? (a = d, o = ++v) : (a = u, o = ++p); var s = a[o]; void 0 !== s ? (s.id = t.id, s.object = t, s.geometry = e, s.material = i, s.z = mt.z, s.group = r) : (s = { id: t.id, object: t, geometry: e, material: i, z: mt.z, group: r }, a.push(s)) } function te(t) { if (!Y.intersectsSphere(t)) return !1; var e = q.numPlanes; if (0 === e) return !0; var i = E.clippingPlanes, n = t.center, r = -t.radius, a = 0; do { if (i[a].distanceToPoint(n) < r) return !1 } while (++a !== e); return !0 } function ee(t, e) { if (!1 !== t.visible) { var i; if (0 != (t.layers.mask & e.layers.mask)) if (t.isLight) l.push(t); else if (t.isSprite) !1 !== t.frustumCulled && !0 !== (i = t, ut.center.set(0, 0, 0), ut.radius = .7071067811865476, ut.applyMatrix4(i.matrixWorld), te(ut)) || w.push(t); else if (t.isLensFlare) b.push(t); else if (t.isImmediateRenderObject) !0 === E.sortObjects && (mt.setFromMatrixPosition(t.matrixWorld), mt.applyProjection(ft)), $t(t, null, t.material, mt.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !1 === t.frustumCulled || !0 === function (t) { var e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), ut.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), te(ut) }(t))) { var n = t.material; if (!0 === n.visible) { !0 === E.sortObjects && (mt.setFromMatrixPosition(t.matrixWorld), mt.applyProjection(ft)); var r = Tt.update(t); if (n.isMultiMaterial) for (var a = r.groups, o = n.materials, s = 0, c = a.length; s < c; s++) { var h = a[s], u = o[h.materialIndex]; !0 === u.visible && $t(t, r, u, mt.z, h) } else $t(t, r, n, mt.z, null) } } var p = t.children; for (s = 0, c = p.length; s < c; s++)ee(p[s], e) } } function ie(t, e, i, n) { for (var r = 0, a = t.length; r < a; r++) { var o = t[r], s = o.object, c = o.geometry, h = void 0 === n ? o.material : n, l = o.group; if (s.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, s.matrixWorld), s.normalMatrix.getNormalMatrix(s.modelViewMatrix), s.isImmediateRenderObject) { ne(h); var u = re(e, i, h, s); U = "", s.render((function (t) { E.renderBufferImmediate(t, u, h) })) } else E.renderBufferDirect(e, i, c, h, s, l) } } function ne(t) { t.side === m ? bt.disable(M.CULL_FACE) : bt.enable(M.CULL_FACE), bt.setFlipSided(t.side === f), !0 === t.transparent ? bt.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : bt.setBlending(x), bt.setDepthFunc(t.depthFunc), bt.setDepthTest(t.depthTest), bt.setDepthWrite(t.depthWrite), bt.setColorWrite(t.colorWrite), bt.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) } function re(e, n, r, a) { O = 0; var o = Mt.get(r); if (Z && (J || e !== I)) { var s = e === I && r.id === C; q.setState(r.clippingPlanes, r.clipShadows, e, o, s) } !1 === r.needsUpdate && (void 0 === o.program || r.fog && o.fog !== n || r.lights && o.lightsHash !== gt.hash || void 0 !== o.numClippingPlanes && o.numClippingPlanes !== q.numPlanes) && (r.needsUpdate = !0), r.needsUpdate && (!function (e, i, n) { var r = Mt.get(e), a = St.getParameters(e, gt, i, q.numPlanes, n), o = St.getProgramCode(e, a), s = r.program, c = !0; if (void 0 === s) e.addEventListener("dispose", qt); else if (s.code !== o) Zt(e); else { if (void 0 !== a.shaderID) return; c = !1 } if (c) { if (a.shaderID) { var h = qe[a.shaderID]; r.__webglShader = { name: e.type, uniforms: t.UniformsUtils.clone(h.uniforms), vertexShader: h.vertexShader, fragmentShader: h.fragmentShader } } else r.__webglShader = { name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }; e.__webglShader = r.__webglShader, s = St.acquireProgram(e, a, o), r.program = s, e.program = s } var l = s.getAttributes(); if (e.morphTargets) { e.numSupportedMorphTargets = 0; for (var u = 0; u < E.maxMorphTargets; u++)l["morphTarget" + u] >= 0 && e.numSupportedMorphTargets++ } if (e.morphNormals) for (e.numSupportedMorphNormals = 0, u = 0; u < E.maxMorphNormals; u++)l["morphNormal" + u] >= 0 && e.numSupportedMorphNormals++; var p = r.__webglShader.uniforms; !e.isShaderMaterial && !e.isRawShaderMaterial | !0 === e.clipping && (r.numClippingPlanes = q.numPlanes, p.clippingPlanes = q.uniform), r.fog = i, r.lightsHash = gt.hash, e.lights && (p.ambientLightColor.value = gt.ambient, p.directionalLights.value = gt.directional, p.spotLights.value = gt.spot, p.pointLights.value = gt.point, p.hemisphereLights.value = gt.hemi, p.directionalShadowMap.value = gt.directionalShadowMap, p.directionalShadowMatrix.value = gt.directionalShadowMatrix, p.spotShadowMap.value = gt.spotShadowMap, p.spotShadowMatrix.value = gt.spotShadowMatrix, p.pointShadowMap.value = gt.pointShadowMap, p.pointShadowMatrix.value = gt.pointShadowMatrix); var d = r.program.getUniforms(), f = Pe.seqWithValue(d.seq, p); r.uniformsList = f, r.dynamicUniforms = Pe.splitDynamic(f, p) }(r, n, a), r.needsUpdate = !1); var c, h, l = !1, u = !1, p = !1, d = o.program, f = d.getUniforms(), m = o.__webglShader.uniforms; if (d.id !== L && (M.useProgram(d.program), L = d.id, l = !0, u = !0, p = !0), r.id !== C && (C = r.id, u = !0), l || e !== I) { if (f.set(M, e, "projectionMatrix"), wt.logarithmicDepthBuffer && f.setValue(M, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), e !== I && (I = e, u = !0, p = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) { var g = f.map.cameraPosition; void 0 !== g && g.setValue(M, mt.setFromMatrixPosition(e.matrixWorld)) } (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && f.setValue(M, "viewMatrix", e.matrixWorldInverse), f.set(M, E, "toneMappingExposure"), f.set(M, E, "toneMappingWhitePoint") } if (r.skinning) { f.setOptional(M, a, "bindMatrix"), f.setOptional(M, a, "bindMatrixInverse"); var v = a.skeleton; v && (wt.floatVertexTextures && v.useVertexTexture ? (f.set(M, v, "boneTexture"), f.set(M, v, "boneTextureWidth"), f.set(M, v, "boneTextureHeight")) : f.setOptional(M, v, "boneMatrices")) } u && (r.lights && (h = p, (c = m).ambientLightColor.needsUpdate = h, c.directionalLights.needsUpdate = h, c.pointLights.needsUpdate = h, c.spotLights.needsUpdate = h, c.hemisphereLights.needsUpdate = h), n && r.fog && function (t, e) { t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }(m, n), (r.isMeshBasicMaterial || r.isMeshLambertMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.isMeshDepthMaterial) && function (t, e) { t.opacity.value = e.opacity, t.diffuse.value = e.color, e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity); t.map.value = e.map, t.specularMap.value = e.specularMap, t.alphaMap.value = e.alphaMap, e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity); var i; e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap); if (void 0 !== i) { i.isWebGLRenderTarget && (i = i.texture); var n = i.offset, r = i.repeat; t.offsetRepeat.value.set(n.x, n.y, r.x, r.y) } t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio }(m, r), r.isLineBasicMaterial ? ae(m, r) : r.isLineDashedMaterial ? (ae(m, r), function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(m, r)) : r.isPointsMaterial ? function (t, e) { if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * k, t.scale.value = .5 * i.clientHeight, t.map.value = e.map, null !== e.map) { var n = e.map.offset, r = e.map.repeat; t.offsetRepeat.value.set(n.x, n.y, r.x, r.y) } }(m, r) : r.isMeshLambertMaterial ? function (t, e) { e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity); e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(m, r) : r.isMeshPhongMaterial ? function (t, e) { t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity); e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(m, r) : r.isMeshPhysicalMaterial ? function (t, e) { t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, oe(t, e) }(m, r) : r.isMeshStandardMaterial ? oe(m, r) : r.isMeshDepthMaterial ? r.displacementMap && (m.displacementMap.value = r.displacementMap, m.displacementScale.value = r.displacementScale, m.displacementBias.value = r.displacementBias) : r.isMeshNormalMaterial && (m.opacity.value = r.opacity), Pe.upload(M, o.uniformsList, m, E)), f.set(M, a, "modelViewMatrix"), f.set(M, a, "normalMatrix"), f.setValue(M, "modelMatrix", a.matrixWorld); var y = o.dynamicUniforms; return null !== y && (Pe.evalDynamic(y, m, a, e), Pe.upload(M, y, m, E)), d } function ae(t, e) { t.diffuse.value = e.color, t.opacity.value = e.opacity } function oe(t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity) } function se(t) { var e; if (t === Q) return M.REPEAT; if (t === K) return M.CLAMP_TO_EDGE; if (t === $) return M.MIRRORED_REPEAT; if (t === tt) return M.NEAREST; if (t === et) return M.NEAREST_MIPMAP_NEAREST; if (t === it) return M.NEAREST_MIPMAP_LINEAR; if (t === nt) return M.LINEAR; if (1007 === t) return M.LINEAR_MIPMAP_NEAREST; if (t === rt) return M.LINEAR_MIPMAP_LINEAR; if (t === at) return M.UNSIGNED_BYTE; if (1017 === t) return M.UNSIGNED_SHORT_4_4_4_4; if (1018 === t) return M.UNSIGNED_SHORT_5_5_5_1; if (1019 === t) return M.UNSIGNED_SHORT_5_6_5; if (1010 === t) return M.BYTE; if (1011 === t) return M.SHORT; if (t === ot) return M.UNSIGNED_SHORT; if (1013 === t) return M.INT; if (1014 === t) return M.UNSIGNED_INT; if (t === st) return M.FLOAT; if (null !== (e = xt.get("OES_texture_half_float")) && t === ct) return e.HALF_FLOAT_OES; if (1021 === t) return M.ALPHA; if (t === ht) return M.RGB; if (t === lt) return M.RGBA; if (1024 === t) return M.LUMINANCE; if (1025 === t) return M.LUMINANCE_ALPHA; if (t === pt) return M.DEPTH_COMPONENT; if (t === dt) return M.DEPTH_STENCIL; if (t === T) return M.FUNC_ADD; if (101 === t) return M.FUNC_SUBTRACT; if (102 === t) return M.FUNC_REVERSE_SUBTRACT; if (200 === t) return M.ZERO; if (201 === t) return M.ONE; if (202 === t) return M.SRC_COLOR; if (203 === t) return M.ONE_MINUS_SRC_COLOR; if (t === S) return M.SRC_ALPHA; if (t === A) return M.ONE_MINUS_SRC_ALPHA; if (206 === t) return M.DST_ALPHA; if (207 === t) return M.ONE_MINUS_DST_ALPHA; if (208 === t) return M.DST_COLOR; if (209 === t) return M.ONE_MINUS_DST_COLOR; if (210 === t) return M.SRC_ALPHA_SATURATE; if (null !== (e = xt.get("WEBGL_compressed_texture_s3tc"))) { if (2001 === t) return e.COMPRESSED_RGB_S3TC_DXT1_EXT; if (2002 === t) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (2003 === t) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (2004 === t) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (null !== (e = xt.get("WEBGL_compressed_texture_pvrtc"))) { if (2100 === t) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (2101 === t) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (2102 === t) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (2103 === t) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (null !== (e = xt.get("WEBGL_compressed_texture_etc1")) && 2151 === t) return e.COMPRESSED_RGB_ETC1_WEBGL; if (null !== (e = xt.get("EXT_blend_minmax"))) { if (103 === t) return e.MIN_EXT; if (104 === t) return e.MAX_EXT } return null !== (e = xt.get("WEBGL_depth_texture")) && 1020 === t ? e.UNSIGNED_INT_24_8_WEBGL : 0 } this.getContext = function () { return M }, this.getContextAttributes = function () { return M.getContextAttributes() }, this.forceContextLoss = function () { xt.get("WEBGL_lose_context").loseContext() }, this.getMaxAnisotropy = function () { return wt.getMaxAnisotropy() }, this.getPrecision = function () { return wt.precision }, this.getPixelRatio = function () { return k }, this.setPixelRatio = function (t) { void 0 !== t && (k = t, this.setSize(X.z, X.w, !1)) }, this.getSize = function () { return { width: H, height: V } }, this.setSize = function (t, e, n) { H = t, V = e, i.width = t * k, i.height = e * k, !1 !== n && (i.style.width = t + "px", i.style.height = e + "px"), this.setViewport(0, 0, t, e) }, this.setViewport = function (t, e, i, n) { bt.viewport(X.set(t, e, i, n)) }, this.setScissor = function (t, e, i, n) { bt.scissor(j.set(t, e, i, n)) }, this.setScissorTest = function (t) { bt.setScissorTest(W = t) }, this.getClearColor = function () { return z }, this.setClearColor = function (t, e) { z.set(t), B = void 0 !== e ? e : 1, Ft(z.r, z.g, z.b, B) }, this.getClearAlpha = function () { return B }, this.setClearAlpha = function (t) { B = t, Ft(z.r, z.g, z.b, B) }, this.clear = function (t, e, i) { var n = 0; (void 0 === t || t) && (n |= M.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= M.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= M.STENCIL_BUFFER_BIT), M.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.clearTarget = function (t, e, i, n) { this.setRenderTarget(t), this.clear(e, i, n) }, this.resetGLState = zt, this.dispose = function () { d = [], v = -1, u = [], p = -1, i.removeEventListener("webglcontextlost", Yt, !1) }, this.renderBufferImmediate = function (t, e, i) { bt.initAttributes(); var n = Mt.get(t); t.hasPositions && !n.position && (n.position = M.createBuffer()), t.hasNormals && !n.normal && (n.normal = M.createBuffer()), t.hasUvs && !n.uv && (n.uv = M.createBuffer()), t.hasColors && !n.color && (n.color = M.createBuffer()); var r = e.getAttributes(); if (t.hasPositions && (M.bindBuffer(M.ARRAY_BUFFER, n.position), M.bufferData(M.ARRAY_BUFFER, t.positionArray, M.DYNAMIC_DRAW), bt.enableAttribute(r.position), M.vertexAttribPointer(r.position, 3, M.FLOAT, !1, 0, 0)), t.hasNormals) { if (M.bindBuffer(M.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && i.shading === g) for (var a = 0, o = 3 * t.count; a < o; a += 9) { var s = t.normalArray, c = (s[a + 0] + s[a + 3] + s[a + 6]) / 3, h = (s[a + 1] + s[a + 4] + s[a + 7]) / 3, l = (s[a + 2] + s[a + 5] + s[a + 8]) / 3; s[a + 0] = c, s[a + 1] = h, s[a + 2] = l, s[a + 3] = c, s[a + 4] = h, s[a + 5] = l, s[a + 6] = c, s[a + 7] = h, s[a + 8] = l } M.bufferData(M.ARRAY_BUFFER, t.normalArray, M.DYNAMIC_DRAW), bt.enableAttribute(r.normal), M.vertexAttribPointer(r.normal, 3, M.FLOAT, !1, 0, 0) } t.hasUvs && i.map && (M.bindBuffer(M.ARRAY_BUFFER, n.uv), M.bufferData(M.ARRAY_BUFFER, t.uvArray, M.DYNAMIC_DRAW), bt.enableAttribute(r.uv), M.vertexAttribPointer(r.uv, 2, M.FLOAT, !1, 0, 0)), t.hasColors && i.vertexColors !== y && (M.bindBuffer(M.ARRAY_BUFFER, n.color), M.bufferData(M.ARRAY_BUFFER, t.colorArray, M.DYNAMIC_DRAW), bt.enableAttribute(r.color), M.vertexAttribPointer(r.color, 3, M.FLOAT, !1, 0, 0)), bt.disableUnusedAttributes(), M.drawArrays(M.TRIANGLES, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, i, n, r, a) { ne(n); var o = re(t, e, n, r), s = !1, c = i.id + "_" + o.id + "_" + n.wireframe; c !== U && (U = c, s = !0); var h = r.morphTargetInfluences; if (void 0 !== h) { for (var l = [], u = 0, p = h.length; u < p; u++) { var d = h[u]; l.push([d, u]) } l.sort(Jt), l.length > 8 && (l.length = 8); var f = i.morphAttributes; for (u = 0, p = l.length; u < p; u++) { d = l[u]; if (_[u] = d[0], 0 !== d[0]) { var m = d[1]; !0 === n.morphTargets && f.position && i.addAttribute("morphTarget" + u, f.position[m]), !0 === n.morphNormals && f.normal && i.addAttribute("morphNormal" + u, f.normal[m]) } else !0 === n.morphTargets && i.removeAttribute("morphTarget" + u), !0 === n.morphNormals && i.removeAttribute("morphNormal" + u) } o.getUniforms().setValue(M, "morphTargetInfluences", _), s = !0 } m = i.index; var g, v = i.attributes.position; !0 === n.wireframe && (m = Tt.getWireframeAttribute(i)), null !== m ? (g = Rt).setIndex(m) : g = Lt, s && (!function (t, e, i, n) { var r; if (i && i.isInstancedBufferGeometry && null === (r = xt.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); void 0 === n && (n = 0); bt.initAttributes(); var a = i.attributes, o = e.getAttributes(), s = t.defaultAttributeValues; for (var c in o) { var h = o[c]; if (h >= 0) { var l = a[c]; if (void 0 !== l) { var u = M.FLOAT, p = l.array, d = l.normalized; p instanceof Float32Array ? u = M.FLOAT : p instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : p instanceof Uint16Array ? u = M.UNSIGNED_SHORT : p instanceof Int16Array ? u = M.SHORT : p instanceof Uint32Array ? u = M.UNSIGNED_INT : p instanceof Int32Array ? u = M.INT : p instanceof Int8Array ? u = M.BYTE : p instanceof Uint8Array && (u = M.UNSIGNED_BYTE); var f = l.itemSize, m = Tt.getAttributeBuffer(l); if (l && l.isInterleavedBufferAttribute) { var g = l.data, v = g.stride, y = l.offset; g && g.isInstancedInterleavedBuffer ? (bt.enableAttributeAndDivisor(h, g.meshPerAttribute, r), void 0 === i.maxInstancedCount && (i.maxInstancedCount = g.meshPerAttribute * g.count)) : bt.enableAttribute(h), M.bindBuffer(M.ARRAY_BUFFER, m), M.vertexAttribPointer(h, f, u, d, v * g.array.BYTES_PER_ELEMENT, (n * v + y) * g.array.BYTES_PER_ELEMENT) } else l && l.isInstancedBufferAttribute ? (bt.enableAttributeAndDivisor(h, l.meshPerAttribute, r), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : bt.enableAttribute(h), M.bindBuffer(M.ARRAY_BUFFER, m), M.vertexAttribPointer(h, f, u, d, 0, n * f * l.array.BYTES_PER_ELEMENT) } else if (void 0 !== s) { var x = s[c]; if (void 0 !== x) switch (x.length) { case 2: M.vertexAttrib2fv(h, x); break; case 3: M.vertexAttrib3fv(h, x); break; case 4: M.vertexAttrib4fv(h, x); break; default: M.vertexAttrib1fv(h, x) } } } } bt.disableUnusedAttributes() }(n, o, i), null !== m && M.bindBuffer(M.ELEMENT_ARRAY_BUFFER, Tt.getAttributeBuffer(m))); var y = 1 / 0; null !== m ? y = m.count : void 0 !== v && (y = v.count); var x = i.drawRange.start, w = i.drawRange.count, b = null !== a ? a.start : 0, E = null !== a ? a.count : 1 / 0, T = Math.max(0, x, b), S = Math.min(0 + y, x + w, b + E) - 1, A = Math.max(0, S - T + 1); if (r.isMesh) if (!0 === n.wireframe) bt.setLineWidth(n.wireframeLinewidth * Nt()), g.setMode(M.LINES); else switch (r.drawMode) { case _t: g.setMode(M.TRIANGLES); break; case 1: g.setMode(M.TRIANGLE_STRIP); break; case 2: g.setMode(M.TRIANGLE_FAN) } else if (r.isLine) { var L = n.linewidth; void 0 === L && (L = 1), bt.setLineWidth(L * Nt()), r.isLineSegments ? g.setMode(M.LINES) : g.setMode(M.LINE_STRIP) } else r.isPoints && g.setMode(M.POINTS); i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && g.renderInstances(i, T, A) : g.render(T, A) }, this.render = function (t, e, i, n) { if (!1 !== (e && e.isCamera)) { var r = t.fog; U = "", C = -1, I = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), e.matrixWorldInverse.getInverse(e.matrixWorld), ft.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Y.setFromMatrix(ft), l.length = 0, p = -1, v = -1, w.length = 0, b.length = 0, J = this.localClippingEnabled, Z = q.init(this.clippingPlanes, J, e), ee(t, e), u.length = p + 1, d.length = v + 1, !0 === E.sortObjects && (u.sort(Qt), d.sort(Kt)), Z && q.beginShadows(), function (t) { for (var e = 0, i = 0, n = t.length; i < n; i++) { var r = t[i]; r.castShadow && (gt.shadows[e++] = r) } gt.shadows.length = e }(l), Bt.render(t, e), function (t, e) { var i, n, r, a, o, s, c, h = 0, l = 0, u = 0, p = e.matrixWorldInverse, d = 0, f = 0, m = 0, g = 0; for (i = 0, n = t.length; i < n; i++)if (a = (r = t[i]).color, o = r.intensity, s = r.distance, c = r.shadow && r.shadow.map ? r.shadow.map.texture : null, r.isAmbientLight) h += a.r * o, l += a.g * o, u += a.b * o; else if (r.isDirectionalLight) { (v = At.get(r)).color.copy(r.color).multiplyScalar(r.intensity), v.direction.setFromMatrixPosition(r.matrixWorld), mt.setFromMatrixPosition(r.target.matrixWorld), v.direction.sub(mt), v.direction.transformDirection(p), v.shadow = r.castShadow, r.castShadow && (v.shadowBias = r.shadow.bias, v.shadowRadius = r.shadow.radius, v.shadowMapSize = r.shadow.mapSize), gt.directionalShadowMap[d] = c, gt.directionalShadowMatrix[d] = r.shadow.matrix, gt.directional[d++] = v } else if (r.isSpotLight) { (v = At.get(r)).position.setFromMatrixPosition(r.matrixWorld), v.position.applyMatrix4(p), v.color.copy(a).multiplyScalar(o), v.distance = s, v.direction.setFromMatrixPosition(r.matrixWorld), mt.setFromMatrixPosition(r.target.matrixWorld), v.direction.sub(mt), v.direction.transformDirection(p), v.coneCos = Math.cos(r.angle), v.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)), v.decay = 0 === r.distance ? 0 : r.decay, v.shadow = r.castShadow, r.castShadow && (v.shadowBias = r.shadow.bias, v.shadowRadius = r.shadow.radius, v.shadowMapSize = r.shadow.mapSize), gt.spotShadowMap[m] = c, gt.spotShadowMatrix[m] = r.shadow.matrix, gt.spot[m++] = v } else if (r.isPointLight) { (v = At.get(r)).position.setFromMatrixPosition(r.matrixWorld), v.position.applyMatrix4(p), v.color.copy(r.color).multiplyScalar(r.intensity), v.distance = r.distance, v.decay = 0 === r.distance ? 0 : r.decay, v.shadow = r.castShadow, r.castShadow && (v.shadowBias = r.shadow.bias, v.shadowRadius = r.shadow.radius, v.shadowMapSize = r.shadow.mapSize), gt.pointShadowMap[f] = c, void 0 === gt.pointShadowMatrix[f] && (gt.pointShadowMatrix[f] = new Ht), mt.setFromMatrixPosition(r.matrixWorld).negate(), gt.pointShadowMatrix[f].identity().setPosition(mt), gt.point[f++] = v } else if (r.isHemisphereLight) { var v; (v = At.get(r)).direction.setFromMatrixPosition(r.matrixWorld), v.direction.transformDirection(p), v.direction.normalize(), v.skyColor.copy(r.color).multiplyScalar(o), v.groundColor.copy(r.groundColor).multiplyScalar(o), gt.hemi[g++] = v } gt.ambient[0] = h, gt.ambient[1] = l, gt.ambient[2] = u, gt.directional.length = d, gt.spot.length = m, gt.point.length = f, gt.hemi.length = g, gt.hash = d + "," + f + "," + m + "," + g + "," + gt.shadows.length }(l, e), Z && q.endShadows(), vt.calls = 0, vt.vertices = 0, vt.faces = 0, vt.points = 0, void 0 === i && (i = null), this.setRenderTarget(i); var a = t.background; if (null === a ? Ft(z.r, z.g, z.b, B) : a && a.isColor && (Ft(a.r, a.g, a.b, 1), n = !0), (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), a && a.isCubeTexture ? (Ct.projectionMatrix.copy(e.projectionMatrix), Ct.matrixWorld.extractRotation(e.matrixWorld), Ct.matrixWorldInverse.getInverse(Ct.matrixWorld), Dt.material.uniforms.tCube.value = a, Dt.modelViewMatrix.multiplyMatrices(Ct.matrixWorldInverse, Dt.matrixWorld), Tt.update(Dt), E.renderBufferDirect(Ct, null, Dt.geometry, Dt.material, Dt, null)) : a && a.isTexture && (Ut.material.map = a, Tt.update(Ut), E.renderBufferDirect(Pt, null, Ut.geometry, Ut.material, Ut, null)), t.overrideMaterial) { var o = t.overrideMaterial; ie(u, e, r, o), ie(d, e, r, o) } else bt.setBlending(x), ie(u, e, r), ie(d, e, r); Vt.render(t, e), Wt.render(t, e, F), i && Et.updateRenderTargetMipmap(i), bt.setDepthTest(!0), bt.setDepthWrite(!0), bt.setColorWrite(!0) } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFaceCulling = function (t, e) { bt.setCullFace(t), bt.setFlipSided(0 === e) }, this.allocTextureUnit = function () { var t = O; return t >= wt.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + wt.maxTextures), O += 1, t }, this.setTexture2D = (Gt = !1, function (t, e) { t && t.isWebGLRenderTarget && (Gt || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), Gt = !0), t = t.texture), Et.setTexture2D(t, e) }), this.setTexture = function () { var t = !1; return function (e, i) { t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), Et.setTexture2D(e, i) } }(), this.setTextureCube = function () { var t = !1; return function (e, i) { e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Et.setTextureCube(e, i) : Et.setTextureCubeDynamic(e, i) } }(), this.getCurrentRenderTarget = function () { return R }, this.setRenderTarget = function (t) { R = t, t && void 0 === Mt.get(t).__webglFramebuffer && Et.setupRenderTarget(t); var e, i = t && t.isWebGLRenderTargetCube; if (t) { var n = Mt.get(t); e = i ? n.__webglFramebuffer[t.activeCubeFace] : n.__webglFramebuffer, D.copy(t.scissor), N = t.scissorTest, F.copy(t.viewport) } else e = null, D.copy(j).multiplyScalar(k), N = W, F.copy(X).multiplyScalar(k); if (P !== e && (M.bindFramebuffer(M.FRAMEBUFFER, e), P = e), bt.scissor(D), bt.setScissorTest(N), bt.viewport(F), i) { var r = Mt.get(t.texture); M.framebufferTexture2D(M.FRAMEBUFFER, M.COLOR_ATTACHMENT0, M.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel) } }, this.readRenderTargetPixels = function (t, e, i, n, r, a) { if (!1 !== (t && t.isWebGLRenderTarget)) { var o = Mt.get(t).__webglFramebuffer; if (o) { var s = !1; o !== P && (M.bindFramebuffer(M.FRAMEBUFFER, o), s = !0); try { var c = t.texture, h = c.format, l = c.type; if (h !== lt && se(h) !== M.getParameter(M.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(l === at || se(l) === M.getParameter(M.IMPLEMENTATION_COLOR_READ_TYPE) || l === st && (xt.get("OES_texture_float") || xt.get("WEBGL_color_buffer_float")) || l === ct && xt.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); M.checkFramebufferStatus(M.FRAMEBUFFER) === M.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && M.readPixels(e, i, n, r, se(h), se(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && M.bindFramebuffer(M.FRAMEBUFFER, P) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") } } function un(t, e) { this.name = "", this.color = new Ge(t), this.density = void 0 !== e ? e : 25e-5 } function pn(t, e, i) { this.name = "", this.color = new Ge(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3 } function dn() { Si.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 } function fn(t, e, i, n, r) { Si.call(this), this.lensFlares = [], this.positionScreen = new kt, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, i, n, r) } function mn(t) { Ne.call(this), this.type = "SpriteMaterial", this.color = new Ge(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t) } function gn(t) { Si.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new mn } function vn() { Si.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function yn(t, e, i, n, r, a, o, s, c, h, l, u) { Ct.call(this, null, a, o, s, c, h, n, r, l, u), this.image = { data: t, width: e, height: i }, this.magFilter = void 0 !== c ? c : tt, this.minFilter = void 0 !== h ? h : tt, this.flipY = !1, this.generateMipmaps = !1 } function xn(e, i, n) { if (this.useVertexTexture = void 0 === n || n, this.identityMatrix = new Ht, e = e || [], this.bones = e.slice(0), this.useVertexTexture) { var r = Math.sqrt(4 * this.bones.length); r = t.Math.nextPowerOfTwo(Math.ceil(r)), r = Math.max(r, 4), this.boneTextureWidth = r, this.boneTextureHeight = r, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new yn(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, lt, st) } else this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === i) this.calculateInverses(); else if (this.bones.length === i.length) this.boneInverses = i.slice(0); else { console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = []; for (var a = 0, o = this.bones.length; a < o; a++)this.boneInverses.push(new Ht) } } function _n(t) { Si.call(this), this.type = "Bone", this.skin = t } function wn(t, e, i) { an.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ht, this.bindMatrixInverse = new Ht; var n = []; if (this.geometry && void 0 !== this.geometry.bones) { for (var r, a, o = 0, s = this.geometry.bones.length; o < s; ++o)a = this.geometry.bones[o], r = new _n(this), n.push(r), r.name = a.name, r.position.fromArray(a.pos), r.quaternion.fromArray(a.rotq), void 0 !== a.scl && r.scale.fromArray(a.scl); for (o = 0, s = this.geometry.bones.length; o < s; ++o)-1 !== (a = this.geometry.bones[o]).parent && null !== a.parent && void 0 !== n[a.parent] ? n[a.parent].add(n[o]) : this.add(n[o]) } this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new xn(n, void 0, i), this.matrixWorld) } function bn(t) { Ne.call(this), this.type = "LineBasicMaterial", this.color = new Ge(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t) } function Mn(t, e, i) { if (1 === i) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new En(t, e); Si.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ki, this.material = void 0 !== e ? e : new bn({ color: 16777215 * Math.random() }) } function En(t, e) { Mn.call(this, t, e), this.type = "LineSegments" } function Tn(t) { Ne.call(this), this.type = "PointsMaterial", this.color = new Ge(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t) } function Sn(t, e) { Si.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ki, this.material = void 0 !== e ? e : new Tn({ color: 16777215 * Math.random() }) } function An() { Si.call(this), this.type = "Group" } function Ln(t, e, i, n, r, a, o, s, c) { Ct.call(this, t, e, i, n, r, a, o, s, c), this.generateMipmaps = !1; var h = this; !function e() { requestAnimationFrame(e), t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0) }() } function Rn(t, e, i, n, r, a, o, s, c, h, l, u) { Ct.call(this, null, a, o, s, c, h, n, r, l, u), this.image = { width: e, height: i }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function Pn(t, e, i, n, r, a, o, s, c) { Ct.call(this, t, e, i, n, r, a, o, s, c), this.needsUpdate = !0 } function Cn(t, e, i, n, r, a, o, s, c, h) { if ((h = void 0 !== h ? h : pt) !== pt && h !== dt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); Ct.call(this, null, n, r, a, o, s, h, i, c), this.image = { width: t, height: e }, this.type = void 0 !== i ? i : ot, this.magFilter = void 0 !== o ? o : tt, this.minFilter = void 0 !== s ? s : tt, this.flipY = !1, this.generateMipmaps = !1 } function Un() { ze.call(this, { uniforms: t.UniformsUtils.merge([Ye.lights, { opacity: { value: 1 } }]), vertexShader: Be.shadow_vert, fragmentShader: Be.shadow_frag }), this.lights = !0, this.transparent = !0, Object.defineProperties(this, { opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (t) { this.uniforms.opacity.value = t } } }) } function In(t) { ze.call(this, t), this.type = "RawShaderMaterial" } function Dn(e) { this.uuid = t.Math.generateUUID(), this.type = "MultiMaterial", this.materials = e instanceof Array ? e : [], this.visible = !0 } function Nn(t) { Ne.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ge(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new Pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Fn(t) { Nn.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t) } function On(t) { Ne.call(this), this.type = "MeshPhongMaterial", this.color = new Ge(16777215), this.specular = new Ge(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new Pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function zn(t) { Ne.call(this, t), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.morphTargets = !1, this.setValues(t) } function Bn(t) { Ne.call(this), this.type = "MeshLambertMaterial", this.color = new Ge(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = F, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Gn(t) { Ne.call(this), this.type = "LineDashedMaterial", this.color = new Ge(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(t) } function Hn(t, e, i) { var n = this, r = !1, a = 0, o = 0; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) { o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), r = !0 }, this.itemEnd = function (t) { a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (r = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (t) { void 0 !== n.onError && n.onError(t) } } function Vn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function kn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this._parser = null } Object.assign(Vi.prototype, e.prototype, { computeBoundingBox: Pi.prototype.computeBoundingBox, computeBoundingSphere: Pi.prototype.computeBoundingSphere, computeFaceNormals: function () { console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.") }, computeVertexNormals: function () { console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.") }, computeGroups: function (t) { for (var e, i, n = [], r = t.faces, a = 0; a < r.length; a++) { var o = r[a]; o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = { start: 3 * a, materialIndex: i }) } void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n }, fromGeometry: function (t) { var e, i = t.faces, n = t.vertices, r = t.faceVertexUvs, a = r[0] && r[0].length > 0, o = r[1] && r[1].length > 0, s = t.morphTargets, c = s.length; if (c > 0) { e = []; for (var h = 0; h < c; h++)e[h] = []; this.morphTargets.position = e } var l, u = t.morphNormals, p = u.length; if (p > 0) { l = []; for (h = 0; h < p; h++)l[h] = []; this.morphTargets.normal = l } var d = t.skinIndices, f = t.skinWeights, m = d.length === n.length, g = f.length === n.length; for (h = 0; h < i.length; h++) { var v = i[h]; this.vertices.push(n[v.a], n[v.b], n[v.c]); var y = v.vertexNormals; if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else { var x = v.normal; this.normals.push(x, x, x) } var _, w = v.vertexColors; if (3 === w.length) this.colors.push(w[0], w[1], w[2]); else { var b = v.color; this.colors.push(b, b, b) } if (!0 === a) void 0 !== (_ = r[0][h]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new Pt, new Pt, new Pt)); if (!0 === o) void 0 !== (_ = r[1][h]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new Pt, new Pt, new Pt)); for (var M = 0; M < c; M++) { var E = s[M].vertices; e[M].push(E[v.a], E[v.b], E[v.c]) } for (M = 0; M < p; M++) { var T = u[M].vertexNormals[h]; l[M].push(T.a, T.b, T.c) } m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.assign(ki.prototype, e.prototype, { isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { this.index = t }, addAttribute: function (t, e) { return !1 === (e && e.isBufferAttribute) && !1 === (e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new xi(arguments[1], arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) }, getAttribute: function (t) { return this.attributes[t] }, removeAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, i) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== i ? i : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix: function (t) { var e = this.attributes.position; void 0 !== e && (t.applyToVector3Array(e.array), e.needsUpdate = !0); var i = this.attributes.normal; void 0 !== i && ((new Ke).getNormalMatrix(t).applyToVector3Array(i.array), i.needsUpdate = !0); return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationX(e), this.applyMatrix(t), this } }(), rotateY: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationY(e), this.applyMatrix(t), this } }(), rotateZ: function () { var t; return function (e) { return void 0 === t && (t = new Ht), t.makeRotationZ(e), this.applyMatrix(t), this } }(), translate: function () { var t; return function (e, i, n) { return void 0 === t && (t = new Ht), t.makeTranslation(e, i, n), this.applyMatrix(t), this } }(), scale: function () { var t; return function (e, i, n) { return void 0 === t && (t = new Ht), t.makeScale(e, i, n), this.applyMatrix(t), this } }(), lookAt: function () { var t; return function (e) { void 0 === t && (t = new Si), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix) } }(), center: function () { this.computeBoundingBox(); var t = this.boundingBox.center().negate(); return this.translate(t.x, t.y, t.z), t }, setFromObject: function (t) { var e = t.geometry; if (t && t.isPoints || t && t.isLine) { var i = new bi(3 * e.vertices.length, 3), n = new bi(3 * e.colors.length, 3); if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) { var r = new bi(e.lineDistances.length, 1); this.addAttribute("lineDistance", r.copyArray(e.lineDistances)) } null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t && t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, updateFromObject: function (t) { var e, i = t.geometry; if (t && t.isMesh) { var n = i.__directGeometry; if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i); n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n } return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Vi).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { var e = new Float32Array(3 * t.vertices.length); if (this.addAttribute("position", new xi(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) { var i = new Float32Array(3 * t.normals.length); this.addAttribute("normal", new xi(i, 3).copyVector3sArray(t.normals)) } if (t.colors.length > 0) { var n = new Float32Array(3 * t.colors.length); this.addAttribute("color", new xi(n, 3).copyColorsArray(t.colors)) } if (t.uvs.length > 0) { var r = new Float32Array(2 * t.uvs.length); this.addAttribute("uv", new xi(r, 2).copyVector2sArray(t.uvs)) } if (t.uvs2.length > 0) { var a = new Float32Array(2 * t.uvs2.length); this.addAttribute("uv2", new xi(a, 2).copyVector2sArray(t.uvs2)) } if (t.indices.length > 0) { var o = new (t.vertices.length > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length); this.setIndex(new xi(o, 1).copyIndicesArray(t.indices)) } for (var s in this.groups = t.groups, t.morphTargets) { for (var c = [], h = t.morphTargets[s], l = 0, u = h.length; l < u; l++) { var p = h[l], d = new bi(3 * p.length, 3); c.push(d.copyVector3sArray(p)) } this.morphAttributes[s] = c } if (t.skinIndices.length > 0) { var f = new bi(4 * t.skinIndices.length, 4); this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices)) } if (t.skinWeights.length > 0) { var m = new bi(4 * t.skinWeights.length, 4); this.addAttribute("skinWeight", m.copyVector4sArray(t.skinWeights)) } return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Je); var t = this.attributes.position.array; void 0 !== t ? this.boundingBox.setFromArray(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { var t = new Je, e = new kt; return function () { null === this.boundingSphere && (this.boundingSphere = new Qe); var i = this.attributes.position; if (i) { var n = i.array, r = this.boundingSphere.center; t.setFromArray(n), t.center(r); for (var a = 0, o = 0, s = n.length; o < s; o += 3)e.fromArray(n, o), a = Math.max(a, r.distanceToSquared(e)); this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } }(), computeFaceNormals: function () { }, computeVertexNormals: function () { var t = this.index, e = this.attributes, i = this.groups; if (e.position) { var n = e.position.array; if (void 0 === e.normal) this.addAttribute("normal", new xi(new Float32Array(n.length), 3)); else for (var r = e.normal.array, a = 0, o = r.length; a < o; a++)r[a] = 0; var s, c, h, l = e.normal.array, u = new kt, p = new kt, d = new kt, f = new kt, m = new kt; if (t) { var g = t.array; 0 === i.length && this.addGroup(0, g.length); for (var v = 0, y = i.length; v < y; ++v) { var x = i[v], _ = x.start; for (a = _, o = _ + x.count; a < o; a += 3)s = 3 * g[a + 0], c = 3 * g[a + 1], h = 3 * g[a + 2], u.fromArray(n, s), p.fromArray(n, c), d.fromArray(n, h), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), l[s] += f.x, l[s + 1] += f.y, l[s + 2] += f.z, l[c] += f.x, l[c + 1] += f.y, l[c + 2] += f.z, l[h] += f.x, l[h + 1] += f.y, l[h + 2] += f.z } } else for (a = 0, o = n.length; a < o; a += 9)u.fromArray(n, a), p.fromArray(n, a + 3), d.fromArray(n, a + 6), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), l[a] = f.x, l[a + 1] = f.y, l[a + 2] = f.z, l[a + 3] = f.x, l[a + 4] = f.y, l[a + 5] = f.z, l[a + 6] = f.x, l[a + 7] = f.y, l[a + 8] = f.z; this.normalizeNormals(), e.normal.needsUpdate = !0 } }, merge: function (t, e) { if (!1 !== (t && t.isBufferGeometry)) { void 0 === e && (e = 0); var i = this.attributes; for (var n in i) if (void 0 !== t.attributes[n]) for (var r = i[n].array, a = t.attributes[n], o = a.array, s = 0, c = a.itemSize * e; s < o.length; s++, c++)r[c] = o[s]; return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t) }, normalizeNormals: function () { for (var t, e, i, n, r = this.attributes.normal.array, a = 0, o = r.length; a < o; a += 3)t = r[a], e = r[a + 1], i = r[a + 2], n = 1 / Math.sqrt(t * t + e * e + i * i), r[a] *= n, r[a + 1] *= n, r[a + 2] *= n }, toNonIndexed: function () { if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var t = new ki, e = this.index.array, i = this.attributes; for (var n in i) { for (var r = i[n], a = r.array, o = r.itemSize, s = new a.constructor(e.length * o), c = 0, h = 0, l = 0, u = e.length; l < u; l++) { c = e[l] * o; for (var p = 0; p < o; p++)s[h++] = a[c++] } t.addAttribute(n, new xi(s, o)) } return t }, toJSON: function () { var t = { metadata: { version: 4.4, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { var e = this.parameters; for (var i in e) void 0 !== e[i] && (t[i] = e[i]); return t } t.data = { attributes: {} }; var n = this.index; if (null !== n) { var r = Array.prototype.slice.call(n.array); t.data.index = { type: n.array.constructor.name, array: r } } var a = this.attributes; for (var i in a) { var o = a[i]; r = Array.prototype.slice.call(o.array); t.data.attributes[i] = { itemSize: o.itemSize, type: o.array.constructor.name, array: r, normalized: o.normalized } } var s = this.groups; s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s))); var c = this.boundingSphere; return null !== c && (t.data.boundingSphere = { center: c.center.toArray(), radius: c.radius }), t }, clone: function () { return (new ki).copy(this) }, copy: function (t) { var e = t.index; null !== e && this.setIndex(e.clone()); var i = t.attributes; for (var n in i) { var r = i[n]; this.addAttribute(n, r.clone()) } for (var a = t.groups, o = 0, s = a.length; o < s; o++) { var c = a[o]; this.addGroup(c.start, c.count, c.materialIndex) } return this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), ki.MaxIndex = 65535, Ki.prototype = Object.create(De.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isWebGLRenderTargetCube = !0, $i.prototype = Object.create(ki.prototype), $i.prototype.constructor = $i, tn.prototype = { constructor: tn, set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return (e || new kt).copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: function () { var t = new kt; return function (e) { return this.origin.copy(this.at(e, t)), this } }(), closestPointToPoint: function (t, e) { var i = e || new kt; i.subVectors(t, this.origin); var n = i.dot(this.direction); return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: function () { var t = new kt; return function (e) { var i = t.subVectors(e, this.origin).dot(this.direction); return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e)) } }(), distanceSqToSegment: (Ui = new kt, Ii = new kt, Di = new kt, function (t, e, i, n) { Ui.copy(t).add(e).multiplyScalar(.5), Ii.copy(e).sub(t).normalize(), Di.copy(this.origin).sub(Ui); var r, a, o, s, c = .5 * t.distanceTo(e), h = -this.direction.dot(Ii), l = Di.dot(this.direction), u = -Di.dot(Ii), p = Di.lengthSq(), d = Math.abs(1 - h * h); if (d > 0) if (a = h * l - u, s = c * d, (r = h * u - l) >= 0) if (a >= -s) if (a <= s) { var f = 1 / d; o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r + a + 2 * u) + p } else a = c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p; else a = -c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p; else a <= -s ? o = -(r = Math.max(0, -(-h * c + l))) * r + (a = r > 0 ? -c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p : a <= s ? (r = 0, o = (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p) : o = -(r = Math.max(0, -(h * c + l))) * r + (a = r > 0 ? c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p; else a = h > 0 ? -c : c, o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p; return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(Ii).multiplyScalar(a).add(Ui), o }), intersectSphere: function () { var t = new kt; return function (e, i) { t.subVectors(e.center, this.origin); var n = t.dot(this.direction), r = t.dot(t) - n * n, a = e.radius * e.radius; if (r > a) return null; var o = Math.sqrt(a - r), s = n - o, c = n + o; return s < 0 && c < 0 ? null : s < 0 ? this.at(c, i) : this.at(s, i) } }(), intersectsSphere: function (t) { return this.distanceToPoint(t.center) <= t.radius }, distanceToPlane: function (t) { var e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; var i = -(this.origin.dot(t.normal) + t.constant) / e; return i >= 0 ? i : null }, intersectPlane: function (t, e) { var i = this.distanceToPlane(t); return null === i ? null : this.at(i, e) }, intersectsPlane: function (t) { var e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { var i, n, r, a, o, s, c = 1 / this.direction.x, h = 1 / this.direction.y, l = 1 / this.direction.z, u = this.origin; return c >= 0 ? (i = (t.min.x - u.x) * c, n = (t.max.x - u.x) * c) : (i = (t.max.x - u.x) * c, n = (t.min.x - u.x) * c), h >= 0 ? (r = (t.min.y - u.y) * h, a = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, a = (t.min.y - u.y) * h), i > a || r > n ? null : ((r > i || i != i) && (i = r), (a < n || n != n) && (n = a), l >= 0 ? (o = (t.min.z - u.z) * l, s = (t.max.z - u.z) * l) : (o = (t.max.z - u.z) * l, s = (t.min.z - u.z) * l), i > s || o > n ? null : ((o > i || i != i) && (i = o), (s < n || n != n) && (n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e))) }, intersectsBox: (Ci = new kt, function (t) { return null !== this.intersectBox(t, Ci) }), intersectTriangle: function () { var t = new kt, e = new kt, i = new kt, n = new kt; return function (r, a, o, s, c) { e.subVectors(a, r), i.subVectors(o, r), n.crossVectors(e, i); var h, l = this.direction.dot(n); if (l > 0) { if (s) return null; h = 1 } else { if (!(l < 0)) return null; h = -1, l = -l } t.subVectors(this.origin, r); var u = h * this.direction.dot(i.crossVectors(t, i)); if (u < 0) return null; var p = h * this.direction.dot(e.cross(t)); if (p < 0) return null; if (u + p > l) return null; var d = -h * t.dot(n); return d < 0 ? null : this.at(d / l, c) } }(), applyMatrix4: function (t) { return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }, en.prototype = { constructor: en, set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, center: function (t) { return (t || new kt).addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return (t || new kt).subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { var i = e || new kt; return this.delta(i).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: (Ni = new kt, Fi = new kt, function (e, i) { Ni.subVectors(e, this.start), Fi.subVectors(this.end, this.start); var n = Fi.dot(Fi), r = Fi.dot(Ni) / n; return i && (r = t.Math.clamp(r, 0, 1)), r }), closestPointToPoint: function (t, e, i) { var n = this.closestPointToPointParameter(t, e), r = i || new kt; return this.delta(r).multiplyScalar(n).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }, nn.normal = (Oi = new kt, function (t, e, i, n) { var r = n || new kt; r.subVectors(i, e), Oi.subVectors(t, e), r.cross(Oi); var a = r.lengthSq(); return a > 0 ? r.multiplyScalar(1 / Math.sqrt(a)) : r.set(0, 0, 0) }), nn.barycoordFromPoint = function () { var t = new kt, e = new kt, i = new kt; return function (n, r, a, o, s) { t.subVectors(o, r), e.subVectors(a, r), i.subVectors(n, r); var c = t.dot(t), h = t.dot(e), l = t.dot(i), u = e.dot(e), p = e.dot(i), d = c * u - h * h, f = s || new kt; if (0 === d) return f.set(-2, -1, -1); var m = 1 / d, g = (u * l - h * p) * m, v = (c * p - h * l) * m; return f.set(1 - g - v, v, g) } }(), nn.containsPoint = function () { var t = new kt; return function (e, i, n, r) { var a = nn.barycoordFromPoint(e, i, n, r, t); return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1 } }(), nn.prototype = { constructor: nn, set: function (t, e, i) { return this.a.copy(t), this.b.copy(e), this.c.copy(i), this }, setFromPointsAndIndices: function (t, e, i, n) { return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, area: function () { var t = new kt, e = new kt; return function () { return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length() } }(), midpoint: function (t) { return (t || new kt).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, normal: function (t) { return nn.normal(this.a, this.b, this.c, t) }, plane: function (t) { return (t || new $e).setFromCoplanarPoints(this.a, this.b, this.c) }, barycoordFromPoint: function (t, e) { return nn.barycoordFromPoint(t, this.a, this.b, this.c, e) }, containsPoint: function (t) { return nn.containsPoint(t, this.a, this.b, this.c) }, closestPointToPoint: function () { var t, e, i, n; return function (r, a) { void 0 === t && (t = new $e, e = [new en, new en, new en], i = new kt, n = new kt); var o = a || new kt, s = 1 / 0; if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)) o.copy(i); else { e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a); for (var c = 0; c < e.length; c++) { e[c].closestPointToPoint(i, !0, n); var h = i.distanceToSquared(n); h < s && (s = h, o.copy(n)) } } return o } }(), equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }, rn.prototype = Object.create(Ne.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshBasicMaterial = !0, rn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }, an.prototype = Object.assign(Object.create(Si.prototype), { constructor: an, isMesh: !0, setDrawMode: function (t) { this.drawMode = t }, copy: function (t) { return Si.prototype.copy.call(this, t), this.drawMode = t.drawMode, this }, updateMorphTargets: function () { if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) { this.morphTargetBase = -1, this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t } }, getMorphTargetIndexByName: function (t) { return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."), 0) }, raycast: function () { var t = new Ht, e = new tn, i = new Qe, n = new kt, r = new kt, a = new kt, o = new kt, s = new kt, c = new kt, h = new Pt, l = new Pt, u = new Pt, p = new kt, d = new kt, g = new kt; function v(t, e, i, n, r, a, o) { return nn.barycoordFromPoint(t, e, i, n, p), r.multiplyScalar(p.x), a.multiplyScalar(p.y), o.multiplyScalar(p.z), r.add(a).add(o), r.clone() } function y(t, e, i, n, r, a, o) { var s = t.material; if (null === (s.side === f ? i.intersectTriangle(a, r, n, !0, o) : i.intersectTriangle(n, r, a, s.side !== m, o))) return null; g.copy(o), g.applyMatrix4(t.matrixWorld); var c = e.ray.origin.distanceTo(g); return c < e.near || c > e.far ? null : { distance: c, point: g.clone(), object: t } } function x(t, e, i, o, s, c, p, f) { n.fromArray(o, 3 * c), r.fromArray(o, 3 * p), a.fromArray(o, 3 * f); var m = y(t, e, i, n, r, a, d); return m && (s && (h.fromArray(s, 2 * c), l.fromArray(s, 2 * p), u.fromArray(s, 2 * f), m.uv = v(d, n, r, a, h, l, u)), m.face = new Mi(c, p, f, nn.normal(n, r, a)), m.faceIndex = c), m } return function (p, f) { var m, g, _ = this.geometry, w = this.material, b = this.matrixWorld; if (void 0 !== w && (null === _.boundingSphere && _.computeBoundingSphere(), i.copy(_.boundingSphere), i.applyMatrix4(b), !1 !== p.ray.intersectsSphere(i) && (t.getInverse(b), e.copy(p.ray).applyMatrix4(t), null === _.boundingBox || !1 !== e.intersectsBox(_.boundingBox)))) if (_ && _.isBufferGeometry) { var M, E, T, S = _.index, A = _.attributes, L = A.position.array; if (void 0 !== A.uv && (m = A.uv.array), null !== S) for (var R = S.array, P = 0, C = R.length; P < C; P += 3)M = R[P], E = R[P + 1], T = R[P + 2], (g = x(this, p, e, L, m, M, E, T)) && (g.faceIndex = Math.floor(P / 3), f.push(g)); else for (P = 0, C = L.length; P < C; P += 9)(g = x(this, p, e, L, m, M = P / 3, E = M + 1, T = M + 2)) && (g.index = M, f.push(g)) } else if (_ && _.isGeometry) { var U, I, D, N = w && w.isMultiMaterial, F = !0 === N ? w.materials : null, O = _.vertices, z = _.faces, B = _.faceVertexUvs[0]; B.length > 0 && (m = B); for (var G = 0, H = z.length; G < H; G++) { var V = z[G], k = !0 === N ? F[V.materialIndex] : w; if (void 0 !== k) { if (U = O[V.a], I = O[V.b], D = O[V.c], !0 === k.morphTargets) { var j = _.morphTargets, W = this.morphTargetInfluences; n.set(0, 0, 0), r.set(0, 0, 0), a.set(0, 0, 0); for (var X = 0, Y = j.length; X < Y; X++) { var q = W[X]; if (0 !== q) { var Z = j[X].vertices; n.addScaledVector(o.subVectors(Z[V.a], U), q), r.addScaledVector(s.subVectors(Z[V.b], I), q), a.addScaledVector(c.subVectors(Z[V.c], D), q) } } n.add(U), r.add(I), a.add(D), U = n, I = r, D = a } if (g = y(this, p, e, U, I, D, d)) { if (m) { var J = m[G]; h.copy(J[0]), l.copy(J[1]), u.copy(J[2]), g.uv = v(d, U, I, D, h, l, u) } g.face = V, g.faceIndex = G, f.push(g) } } } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), on.prototype = Object.create(ki.prototype), on.prototype.constructor = on, sn.prototype = Object.create(Si.prototype), sn.prototype.constructor = sn, sn.prototype.isCamera = !0, sn.prototype.getWorldDirection = function () { var t = new Vt; return function (e) { var i = e || new kt; return this.getWorldQuaternion(t), i.set(0, 0, -1).applyQuaternion(t) } }(), sn.prototype.lookAt = function () { var t = new Ht; return function (e) { t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t) } }(), sn.prototype.clone = function () { return (new this.constructor).copy(this) }, sn.prototype.copy = function (t) { return Si.prototype.copy.call(this, t), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this }, cn.prototype = Object.assign(Object.create(sn.prototype), { constructor: cn, isPerspectiveCamera: !0, copy: function (t) { return sn.prototype.copy.call(this, t), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (e) { var i = .5 * this.getFilmHeight() / e; this.fov = 2 * t.Math.RAD2DEG * Math.atan(i), this.updateProjectionMatrix() }, getFocalLength: function () { var e = Math.tan(.5 * t.Math.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function () { return 2 * t.Math.RAD2DEG * Math.atan(Math.tan(.5 * t.Math.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, i, n, r, a) { this.aspect = t / e, this.view = { fullWidth: t, fullHeight: e, offsetX: i, offsetY: n, width: r, height: a }, this.updateProjectionMatrix() }, clearViewOffset: function () { this.view = null, this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var e = this.near, i = e * Math.tan(.5 * t.Math.DEG2RAD * this.fov) / this.zoom, n = 2 * i, r = this.aspect * n, a = -.5 * r, o = this.view; if (null !== o) { var s = o.fullWidth, c = o.fullHeight; a += o.offsetX * r / s, i -= o.offsetY * n / c, r *= o.width / s, n *= o.height / c } var h = this.filmOffset; 0 !== h && (a += e * h / this.getFilmWidth()), this.projectionMatrix.makeFrustum(a, a + r, i - n, i, e, this.far) }, toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }), hn.prototype = Object.assign(Object.create(sn.prototype), { constructor: hn, isOrthographicCamera: !0, copy: function (t) { return sn.prototype.copy.call(this, t), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, i, n, r, a) { this.view = { fullWidth: t, fullHeight: e, offsetX: i, offsetY: n, width: r, height: a }, this.updateProjectionMatrix() }, clearViewOffset: function () { this.view = null, this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - t, a = i + t, o = n + e, s = n - e; if (null !== this.view) { var c = this.zoom / (this.view.width / this.view.fullWidth), h = this.zoom / (this.view.height / this.view.fullHeight), l = (this.right - this.left) / this.view.width, u = (this.top - this.bottom) / this.view.height; a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (o -= u * (this.view.offsetY / h)) - u * (this.view.height / h) } this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far) }, toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), un.prototype.isFogExp2 = !0, un.prototype.clone = function () { return new un(this.color.getHex(), this.density) }, un.prototype.toJSON = function (t) { return { type: "FogExp2", color: this.color.getHex(), density: this.density } }, pn.prototype.isFog = !0, pn.prototype.clone = function () { return new pn(this.color.getHex(), this.near, this.far) }, pn.prototype.toJSON = function (t) { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }, dn.prototype = Object.create(Si.prototype), dn.prototype.constructor = dn, dn.prototype.copy = function (t, e) { return Si.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, dn.prototype.toJSON = function (t) { var e = Si.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, fn.prototype = Object.assign(Object.create(Si.prototype), { constructor: fn, isLensFlare: !0, copy: function (t) { Si.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback; for (var e = 0, i = t.lensFlares.length; e < i; e++)this.lensFlares.push(t.lensFlares[e]); return this }, add: function (t, e, i, n, r, a) { void 0 === e && (e = -1), void 0 === i && (i = 0), void 0 === a && (a = 1), void 0 === r && (r = new Ge(16777215)), void 0 === n && (n = _), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({ texture: t, size: e, distance: i, x: 0, y: 0, z: 0, scale: 1, rotation: 0, opacity: a, color: r, blending: n }) }, updateLensFlares: function () { var t, e, i = this.lensFlares.length, n = 2 * -this.positionScreen.x, r = 2 * -this.positionScreen.y; for (t = 0; t < i; t++)(e = this.lensFlares[t]).x = this.positionScreen.x + n * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation) } }), mn.prototype = Object.create(Ne.prototype), mn.prototype.constructor = mn, mn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this }, gn.prototype = Object.assign(Object.create(Si.prototype), { constructor: gn, isSprite: !0, raycast: (zi = new kt, function (t, e) { zi.setFromMatrixPosition(this.matrixWorld); var i = t.ray.distanceSqToPoint(zi); i > this.scale.x * this.scale.y / 4 || e.push({ distance: Math.sqrt(i), point: this.position, face: null, object: this }) }), clone: function () { return new this.constructor(this.material).copy(this) } }), vn.prototype = Object.assign(Object.create(Si.prototype), { constructor: vn, copy: function (t) { Si.prototype.copy.call(this, t, !1); for (var e = t.levels, i = 0, n = e.length; i < n; i++) { var r = e[i]; this.addLevel(r.object.clone(), r.distance) } return this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++); i.splice(n, 0, { distance: e, object: t }), this.add(t) }, getObjectForDistance: function (t) { for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++); return e[i - 1].object }, raycast: function () { var t = new kt; return function (e, i) { t.setFromMatrixPosition(this.matrixWorld); var n = e.ray.origin.distanceTo(t); this.getObjectForDistance(n).raycast(e, i) } }(), update: function () { var t = new kt, e = new kt; return function (i) { var n = this.levels; if (n.length > 1) { t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld); var r = t.distanceTo(e); n[0].object.visible = !0; for (var a = 1, o = n.length; a < o && r >= n[a].distance; a++)n[a - 1].object.visible = !1, n[a].object.visible = !0; for (; a < o; a++)n[a].object.visible = !1 } } }(), toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); e.object.levels = []; for (var i = this.levels, n = 0, r = i.length; n < r; n++) { var a = i[n]; e.object.levels.push({ object: a.object.uuid, distance: a.distance }) } return e } }), yn.prototype = Object.create(Ct.prototype), yn.prototype.constructor = yn, yn.prototype.isDataTexture = !0, Object.assign(xn.prototype, { calculateInverses: function () { this.boneInverses = []; for (var t = 0, e = this.bones.length; t < e; t++) { var i = new Ht; this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i) } }, pose: function () { for (var t, e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]); for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, update: (Bi = new Ht, function () { for (var t = 0, e = this.bones.length; t < e; t++) { var i = this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix; Bi.multiplyMatrices(i, this.boneInverses[t]), Bi.toArray(this.boneMatrices, 16 * t) } this.useVertexTexture && (this.boneTexture.needsUpdate = !0) }), clone: function () { return new xn(this.bones, this.boneInverses, this.useVertexTexture) } }), _n.prototype = Object.assign(Object.create(Si.prototype), { constructor: _n, isBone: !0, copy: function (t) { return Si.prototype.copy.call(this, t), this.skin = t.skin, this } }), wn.prototype = Object.assign(Object.create(an.prototype), { constructor: wn, isSkinnedMesh: !0, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { if (this.geometry && this.geometry.isGeometry) for (var t = 0; t < this.geometry.skinWeights.length; t++) { var e = this.geometry.skinWeights[t]; (r = 1 / e.lengthManhattan()) !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0) } else if (this.geometry && this.geometry.isBufferGeometry) { var i = new Ue, n = this.geometry.attributes.skinWeight; for (t = 0; t < n.count; t++) { var r; i.x = n.getX(t), i.y = n.getY(t), i.z = n.getZ(t), i.w = n.getW(t), (r = 1 / i.lengthManhattan()) !== 1 / 0 ? i.multiplyScalar(r) : i.set(1, 0, 0, 0), n.setXYZW(t, i.x, i.y, i.z, i.w) } } }, updateMatrixWorld: function (t) { an.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode) }, clone: function () { return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this) } }), bn.prototype = Object.create(Ne.prototype), bn.prototype.constructor = bn, bn.prototype.isLineBasicMaterial = !0, bn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }, Mn.prototype = Object.assign(Object.create(Si.prototype), { constructor: Mn, isLine: !0, raycast: function () { var t = new Ht, e = new tn, i = new Qe; return function (n, r) { var a = n.linePrecision, o = a * a, s = this.geometry, c = this.matrixWorld; if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(c), !1 !== n.ray.intersectsSphere(i)) { t.getInverse(c), e.copy(n.ray).applyMatrix4(t); var h = new kt, l = new kt, u = new kt, p = new kt, d = this && this.isLineSegments ? 2 : 1; if (s && s.isBufferGeometry) { var f = s.index, m = s.attributes.position.array; if (null !== f) for (var g = f.array, v = 0, y = g.length - 1; v < y; v += d) { var x = g[v], _ = g[v + 1]; if (h.fromArray(m, 3 * x), l.fromArray(m, 3 * _), !(e.distanceSqToSegment(h, l, p, u) > o)) p.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(p)) < n.near || M > n.far || r.push({ distance: M, point: u.clone().applyMatrix4(this.matrixWorld), index: v, face: null, faceIndex: null, object: this }) } else for (v = 0, y = m.length / 3 - 1; v < y; v += d) { if (h.fromArray(m, 3 * v), l.fromArray(m, 3 * v + 3), !(e.distanceSqToSegment(h, l, p, u) > o)) p.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(p)) < n.near || M > n.far || r.push({ distance: M, point: u.clone().applyMatrix4(this.matrixWorld), index: v, face: null, faceIndex: null, object: this }) } } else if (s && s.isGeometry) { var w = s.vertices, b = w.length; for (v = 0; v < b - 1; v += d) { var M; if (!(e.distanceSqToSegment(w[v], w[v + 1], p, u) > o)) p.applyMatrix4(this.matrixWorld), (M = n.ray.origin.distanceTo(p)) < n.near || M > n.far || r.push({ distance: M, point: u.clone().applyMatrix4(this.matrixWorld), index: v, face: null, faceIndex: null, object: this }) } } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), En.prototype = Object.assign(Object.create(Mn.prototype), { constructor: En, isLineSegments: !0 }), Tn.prototype = Object.create(Ne.prototype), Tn.prototype.constructor = Tn, Tn.prototype.isPointsMaterial = !0, Tn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this }, Sn.prototype = Object.assign(Object.create(Si.prototype), { constructor: Sn, isPoints: !0, raycast: function () { var t = new Ht, e = new tn, i = new Qe; return function (n, r) { var a = this, o = this.geometry, s = this.matrixWorld, c = n.params.Points.threshold; if (null === o.boundingSphere && o.computeBoundingSphere(), i.copy(o.boundingSphere), i.applyMatrix4(s), !1 !== n.ray.intersectsSphere(i)) { t.getInverse(s), e.copy(n.ray).applyMatrix4(t); var h = c / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = h * h, u = new kt; if (o && o.isBufferGeometry) { var p = o.index, d = o.attributes.position.array; if (null !== p) for (var f = p.array, m = 0, g = f.length; m < g; m++) { var v = f[m]; u.fromArray(d, 3 * v), _(u, v) } else { m = 0; for (var y = d.length / 3; m < y; m++)u.fromArray(d, 3 * m), _(u, m) } } else { var x = o.vertices; for (m = 0, y = x.length; m < y; m++)_(x[m], m) } } function _(t, i) { var o = e.distanceSqToPoint(t); if (o < l) { var c = e.closestPointToPoint(t); c.applyMatrix4(s); var h = n.ray.origin.distanceTo(c); if (h < n.near || h > n.far) return; r.push({ distance: h, distanceToRay: Math.sqrt(o), point: c.clone(), index: i, face: null, object: a }) } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), An.prototype = Object.assign(Object.create(Si.prototype), { constructor: An }), Ln.prototype = Object.create(Ct.prototype), Ln.prototype.constructor = Ln, Rn.prototype = Object.create(Ct.prototype), Rn.prototype.constructor = Rn, Rn.prototype.isCompressedTexture = !0, Pn.prototype = Object.create(Ct.prototype), Pn.prototype.constructor = Pn, Cn.prototype = Object.create(Ct.prototype), Cn.prototype.constructor = Cn, Cn.prototype.isDepthTexture = !0, Un.prototype = Object.create(ze.prototype), Un.prototype.constructor = Un, Un.prototype.isShadowMaterial = !0, In.prototype = Object.create(ze.prototype), In.prototype.constructor = In, In.prototype.isRawShaderMaterial = !0, Dn.prototype = { constructor: Dn, isMultiMaterial: !0, toJSON: function (t) { for (var e = { metadata: { version: 4.2, type: "material", generator: "MaterialExporter" }, uuid: this.uuid, type: this.type, materials: [] }, i = this.materials, n = 0, r = i.length; n < r; n++) { var a = i[n].toJSON(t); delete a.metadata, e.materials.push(a) } return e.visible = this.visible, e }, clone: function () { for (var t = new this.constructor, e = 0; e < this.materials.length; e++)t.materials.push(this.materials[e].clone()); return t.visible = this.visible, t } }, Nn.prototype = Object.create(Ne.prototype), Nn.prototype.constructor = Nn, Nn.prototype.isMeshStandardMaterial = !0, Nn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Fn.prototype = Object.create(Nn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isMeshPhysicalMaterial = !0, Fn.prototype.copy = function (t) { return Nn.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this }, On.prototype = Object.create(Ne.prototype), On.prototype.constructor = On, On.prototype.isMeshPhongMaterial = !0, On.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, zn.prototype = Object.create(Ne.prototype), zn.prototype.constructor = zn, zn.prototype.isMeshNormalMaterial = !0, zn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, Bn.prototype = Object.create(Ne.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isMeshLambertMaterial = !0, Bn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Gn.prototype = Object.create(Ne.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isLineDashedMaterial = !0, Gn.prototype.copy = function (t) { return Ne.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }, t.Cache = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }, t.DefaultLoadingManager = new Hn, Object.assign(Vn.prototype, { load: function (e, i, n, r) { void 0 !== this.path && (e = this.path + e); var a = this, o = t.Cache.get(e); if (void 0 !== o) return a.manager.itemStart(e), setTimeout((function () { i && i(o), a.manager.itemEnd(e) }), 0), o; var s = new XMLHttpRequest; return s.open("GET", e, !0), s.addEventListener("load", (function (n) { var o = n.target.response; t.Cache.add(e, o), 200 === this.status ? (i && i(o), a.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), i && i(o), a.manager.itemEnd(e)) : (r && r(n), a.manager.itemError(e)) }), !1), void 0 !== n && s.addEventListener("progress", (function (t) { n(t) }), !1), s.addEventListener("error", (function (t) { r && r(t), a.manager.itemError(e) }), !1), void 0 !== this.responseType && (s.responseType = this.responseType), void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials), s.overrideMimeType && s.overrideMimeType("text/plain"), s.send(null), a.manager.itemStart(e), s }, setPath: function (t) { return this.path = t, this }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this } }), Object.assign(kn.prototype, { load: function (t, e, i, n) { var r = this, a = [], o = new Rn; o.image = a; var s = new Vn(this.manager); function c(c) { s.load(t[c], (function (t) { var i = r._parser(t, !0); a[c] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }, 6 === (h += 1) && (1 === i.mipmapCount && (o.minFilter = nt), o.format = i.format, o.needsUpdate = !0, e && e(o)) }), i, n) } if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t)) for (var h = 0, l = 0, u = t.length; l < u; ++l)c(l); else s.load(t, (function (t) { var i = r._parser(t, !0); if (i.isCubemap) for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) { a[s] = { mipmaps: [] }; for (var c = 0; c < i.mipmapCount; c++)a[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + c]), a[s].format = i.format, a[s].width = i.width, a[s].height = i.height } else o.image.width = i.width, o.image.height = i.height, o.mipmaps = i.mipmaps; 1 === i.mipmapCount && (o.minFilter = nt), o.format = i.format, o.needsUpdate = !0, e && e(o) }), i, n); return o }, setPath: function (t) { return this.path = t, this } }); var jn, Wn, Xn, Yn, qn = Zn; function Zn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this._parser = null } function Jn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function Qn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function Kn(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function $n(t, e) { Si.call(this), this.type = "Light", this.color = new Ge(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function tr(t, e, i) { $n.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Si.DefaultUp), this.updateMatrix(), this.groundColor = new Ge(e) } function er(t) { this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Pt(512, 512), this.map = null, this.matrix = new Ht } function ir() { er.call(this, new cn(50, 1, .5, 500)) } function nr(t, e, i, n, r, a) { $n.call(this, t, e), this.type = "SpotLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.target = new Si, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new ir } function rr(t, e, i, n) { $n.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new er(new cn(90, 1, .5, 500)) } function ar(t) { er.call(this, new hn(-5, 5, 5, -5, .5, 500)) } function or(t, e) { $n.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.target = new Si, this.shadow = new ar } function sr(t, e) { $n.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function cr(t, e, i, n) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i } function hr(t, e, i, n) { cr.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function lr(t, e, i, n) { cr.call(this, t, e, i, n) } function ur(t, e, i, n) { cr.call(this, t, e, i, n) } function pr(e, i, n, r) { if (void 0 === e) throw new Error("track name is undefined"); if (void 0 === i || 0 === i.length) throw new Error("no keyframes in track named " + e); this.name = e, this.times = t.AnimationUtils.convertArray(i, this.TimeBufferType), this.values = t.AnimationUtils.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation), this.validate(), this.optimize() } function dr(t, e, i, n) { pr.call(this, t, e, i, n) } function fr(t, e, i, n) { cr.call(this, t, e, i, n) } function mr(t, e, i, n) { pr.call(this, t, e, i, n) } function gr(t, e, i, n) { pr.call(this, t, e, i, n) } function vr(t, e, i, n) { pr.call(this, t, e, i, n) } function yr(t, e, i) { pr.call(this, t, e, i) } function xr(t, e, i, n) { pr.call(this, t, e, i, n) } function _r(t, e, i, n) { pr.apply(this, arguments) } function wr(e, i, n) { this.name = e, this.tracks = n, this.duration = void 0 !== i ? i : -1, this.uuid = t.Math.generateUUID(), this.duration < 0 && this.resetDuration(), this.trim(), this.optimize() } function br(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this.textures = {} } function Mr(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function Er() { this.onLoadStart = function () { }, this.onLoadProgress = function () { }, this.onLoadComplete = function () { } } function Tr(e) { "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this.withCredentials = !1 } function Sr(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this.texturePath = "" } function Ar() { } function Lr(t, e) { this.v1 = t, this.v2 = e } function Rr() { this.curves = [], this.autoClose = !1 } function Pr(t, e, i, n, r, a, o, s) { this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s || 0 } function Cr(t) { this.points = void 0 === t ? [] : t } function Ur(t, e, i, n) { this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n } function Ir(t, e, i) { this.v0 = t, this.v1 = e, this.v2 = i } Object.assign(Zn.prototype, { load: function (t, e, i, n) { var r = this, a = new yn, o = new Vn(this.manager); return o.setResponseType("arraybuffer"), o.load(t, (function (t) { var i = r._parser(t); i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width, a.image.height = i.height, a.image.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS : K, a.wrapT = void 0 !== i.wrapT ? i.wrapT : K, a.magFilter = void 0 !== i.magFilter ? i.magFilter : nt, a.minFilter = void 0 !== i.minFilter ? i.minFilter : rt, a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (a.format = i.format), void 0 !== i.type && (a.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps), 1 === i.mipmapCount && (a.minFilter = nt), a.needsUpdate = !0, e && e(a, i)) }), i, n), a } }), Object.assign(Jn.prototype, { load: function (t, e, i, n) { var r = this, a = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); if (a.onload = function () { URL.revokeObjectURL(a.src), e && e(a), r.manager.itemEnd(t) }, 0 === t.indexOf("data:")) a.src = t; else { var o = new Vn; o.setPath(this.path), o.setResponseType("blob"), o.setWithCredentials(this.withCredentials), o.load(t, (function (t) { a.src = URL.createObjectURL(t) }), i, n) } return r.manager.itemStart(t), a }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Qn.prototype, { load: function (t, e, i, n) { var r = new Yt, a = new Jn(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var o = 0; function s(i) { a.load(t[i], (function (t) { r.images[i] = t, 6 === ++o && (r.needsUpdate = !0, e && e(r)) }), void 0, n) } for (var c = 0; c < t.length; ++c)s(c); return r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Kn.prototype, { load: function (t, e, i, n) { var r = new Ct, a = new Jn(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setWithCredentials(this.withCredentials), a.setPath(this.path), a.load(t, (function (i) { var n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/); r.format = n ? ht : lt, r.image = i, r.needsUpdate = !0, void 0 !== e && e(r) }), i, n), r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setPath: function (t) { return this.path = t, this } }), $n.prototype = Object.assign(Object.create(Si.prototype), { constructor: $n, isLight: !0, copy: function (t) { return Si.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { var e = Si.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), tr.prototype = Object.assign(Object.create($n.prototype), { constructor: tr, isHemisphereLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(er.prototype, { copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = {}; return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), ir.prototype = Object.assign(Object.create(er.prototype), { constructor: ir, isSpotLightShadow: !0, update: function (e) { var i = 2 * t.Math.RAD2DEG * e.angle, n = this.mapSize.width / this.mapSize.height, r = e.distance || 500, a = this.camera; i === a.fov && n === a.aspect && r === a.far || (a.fov = i, a.aspect = n, a.far = r, a.updateProjectionMatrix()) } }), nr.prototype = Object.assign(Object.create($n.prototype), { constructor: nr, isSpotLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), rr.prototype = Object.assign(Object.create($n.prototype), { constructor: rr, isPointLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), ar.prototype = Object.assign(Object.create(er.prototype), { constructor: ar }), or.prototype = Object.assign(Object.create($n.prototype), { constructor: or, isDirectionalLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), sr.prototype = Object.assign(Object.create($n.prototype), { constructor: sr, isAmbientLight: !0 }), t.AnimationUtils = { arraySlice: function (e, i, n) { return t.AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(i, n)) : e.slice(i, n) }, convertArray: function (t, e, i) { return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n)i[n] = n; return i.sort((function (e, i) { return t[e] - t[i] })), i }, sortedArray: function (t, e, i) { for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)for (var s = i[a] * e, c = 0; c !== e; ++c)r[o++] = t[s + c]; return r }, flattenJSON: function (t, e, i, n) { for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];)a = t[r++]; if (void 0 !== a) { var o = a[n]; if (void 0 !== o) if (Array.isArray(o)) do { void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)), a = t[r++] } while (void 0 !== a); else if (void 0 !== o.toArray) do { void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)), a = t[r++] } while (void 0 !== a); else do { void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)), a = t[r++] } while (void 0 !== a) } } }, cr.prototype = { constructor: cr, evaluate: function (t) { var e = this.parameterPositions, i = this._cachedIndex, n = e[i], r = e[i - 1]; t: { e: { var a; i: { n: if (!(t < n)) { for (var o = i + 2; ;) { if (void 0 === n) { if (t < r) break n; return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r) } if (i === o) break; if (r = n, t < (n = e[++i])) break e } a = e.length; break i } if (t >= r) break t; var s = e[1]; t < s && (i = 2, r = s); for (o = i - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (i === o) break; if (n = r, t >= (r = e[--i - 1])) break e } a = i, i = 0 } for (; i < a;) { var c = i + a >>> 1; t < e[c] ? a = c : i = c + 1 } if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t) } this._cachedIndex = i, this.intervalChanged_(i, r, n) } return this.interpolate_(i, r, t, n) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, a = 0; a !== n; ++a)e[a] = i[r + a]; return e }, interpolate_: function (t, e, i, n) { throw new Error("call to abstract method") }, intervalChanged_: function (t, e, i) { } }, Object.assign(cr.prototype, { beforeStart_: cr.prototype.copySampleValue_, afterEnd_: cr.prototype.copySampleValue_ }), hr.prototype = Object.assign(Object.create(cr.prototype), { constructor: hr, DefaultSettings_: { endingStart: vt, endingEnd: vt }, intervalChanged_: function (t, e, i) { var n = this.parameterPositions, r = t - 2, a = t + 1, o = n[r], s = n[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case yt: r = t, o = 2 * e - i; break; case xt: o = e + n[r = n.length - 2] - n[r + 1]; break; default: r = t, o = i }if (void 0 === s) switch (this.getSettings_().endingEnd) { case yt: a = t, s = 2 * i - e; break; case xt: a = 1, s = i + n[1] - n[0]; break; default: a = t - 1, s = e }var c = .5 * (i - e), h = this.valueSize; this._weightPrev = c / (e - o), this._weightNext = c / (s - i), this._offsetPrev = r * h, this._offsetNext = a * h }, interpolate_: function (t, e, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, h = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, _ = 0; _ !== o; ++_)r[_] = g * a[h + _] + v * a[c + _] + y * a[s + _] + x * a[l + _]; return r } }), lr.prototype = Object.assign(Object.create(cr.prototype), { constructor: lr, interpolate_: function (t, e, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, h = (i - e) / (n - e), l = 1 - h, u = 0; u !== o; ++u)r[u] = a[c + u] * l + a[s + u] * h; return r } }), ur.prototype = Object.assign(Object.create(cr.prototype), { constructor: ur, interpolate_: function (t, e, i, n) { return this.copySampleValue_(t - 1) } }), jn = { TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: mt, InterpolantFactoryMethodDiscrete: function (t) { return new ur(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new lr(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new hr(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { var e; switch (t) { case ft: e = this.InterpolantFactoryMethodDiscrete; break; case mt: e = this.InterpolantFactoryMethodLinear; break; case gt: e = this.InterpolantFactoryMethodSmooth }if (void 0 !== e) this.createInterpolant = e; else { var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(i); this.setInterpolation(this.DefaultInterpolation) } console.warn(i) } }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return ft; case this.InterpolantFactoryMethodLinear: return mt; case this.InterpolantFactoryMethodSmooth: return gt } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i)e[i] += t; return this }, scale: function (t) { if (1 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i)e[i] *= t; return this }, trim: function (e, i) { for (var n = this.times, r = n.length, a = 0, o = r - 1; a !== r && n[a] < e;)++a; for (; -1 !== o && n[o] > i;)--o; if (++o, 0 !== a || o !== r) { a >= o && (a = (o = Math.max(o, 1)) - 1); var s = this.getValueSize(); this.times = t.AnimationUtils.arraySlice(n, a, o), this.values = t.AnimationUtils.arraySlice(this.values, a * s, o * s) } return this }, validate: function () { var e = !0, i = this.getValueSize(); i - Math.floor(i) != 0 && (console.error("invalid value size in track", this), e = !1); var n = this.times, r = this.values, a = n.length; 0 === a && (console.error("track is empty", this), e = !1); for (var o = null, s = 0; s !== a; s++) { var c = n[s]; if ("number" == typeof c && isNaN(c)) { console.error("time is not a valid number", this, s, c), e = !1; break } if (null !== o && o > c) { console.error("out of order keys", this, s, c, o), e = !1; break } o = c } if (void 0 !== r && t.AnimationUtils.isTypedArray(r)) { s = 0; for (var h = r.length; s !== h; ++s) { var l = r[s]; if (isNaN(l)) { console.error("value is not a valid number", this, s, l), e = !1; break } } } return e }, optimize: function () { for (var e = this.times, i = this.values, n = this.getValueSize(), r = 1, a = 1, o = e.length - 1; a <= o; ++a) { var s = !1, c = e[a]; if (c !== e[a + 1] && (1 !== a || c !== c[0])) for (var h = a * n, l = h - n, u = h + n, p = 0; p !== n; ++p) { var d = i[h + p]; if (d !== i[l + p] || d !== i[u + p]) { s = !0; break } } if (s) { if (a !== r) { e[r] = e[a]; var f = a * n, m = r * n; for (p = 0; p !== n; ++p)i[m + p] = i[f + p] } ++r } } return r !== e.length && (this.times = t.AnimationUtils.arraySlice(e, 0, r), this.values = t.AnimationUtils.arraySlice(i, 0, r * n)), this } }, dr.prototype = Object.assign(Object.create(jn), { constructor: dr, ValueTypeName: "vector" }), fr.prototype = Object.assign(Object.create(cr.prototype), { constructor: fr, interpolate_: function (t, e, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = (i - e) / (n - e), h = s + o; s !== h; s += 4)Vt.slerpFlat(r, 0, a, s - o, a, s, c); return r } }), mr.prototype = Object.assign(Object.create(jn), { constructor: mr, ValueTypeName: "quaternion", DefaultInterpolation: mt, InterpolantFactoryMethodLinear: function (t) { return new fr(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), gr.prototype = Object.assign(Object.create(jn), { constructor: gr, ValueTypeName: "number" }), vr.prototype = Object.assign(Object.create(jn), { constructor: vr, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: ft, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), yr.prototype = Object.assign(Object.create(jn), { constructor: yr, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: ft, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), xr.prototype = Object.assign(Object.create(jn), { constructor: xr, ValueTypeName: "color" }), _r.prototype = jn, jn.constructor = _r, Object.assign(_r, { parse: function (e) { if (void 0 === e.type) throw new Error("track type undefined, can not parse"); var i = _r._getTrackTypeForValueTypeName(e.type); if (void 0 === e.times) { var n = [], r = []; t.AnimationUtils.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r } return void 0 !== i.parse ? i.parse(e) : new i(e.name, e.times, e.values, e.interpolation) }, toJSON: function (e) { var i, n = e.constructor; if (void 0 !== n.toJSON) i = n.toJSON(e); else { i = { name: e.name, times: t.AnimationUtils.convertArray(e.times, Array), values: t.AnimationUtils.convertArray(e.values, Array) }; var r = e.getInterpolation(); r !== e.DefaultInterpolation && (i.interpolation = r) } return i.type = e.ValueTypeName, i }, _getTrackTypeForValueTypeName: function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return gr; case "vector": case "vector2": case "vector3": case "vector4": return dr; case "color": return xr; case "quaternion": return mr; case "bool": case "boolean": return yr; case "string": return vr }throw new Error("Unsupported typeName: " + t) } }), wr.prototype = { constructor: wr, resetDuration: function () { for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) { var n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } this.duration = t }, trim: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, optimize: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this } }, Object.assign(wr, { parse: function (t) { for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r)e.push(_r.parse(i[r]).scale(n)); return new wr(t.name, t.duration, e) }, toJSON: function (t) { for (var e = [], i = t.tracks, n = { name: t.name, duration: t.duration, tracks: e }, r = 0, a = i.length; r !== a; ++r)e.push(_r.toJSON(i[r])); return n }, CreateFromMorphTargetSequence: function (e, i, n, r) { for (var a = i.length, o = [], s = 0; s < a; s++) { var c = [], h = []; c.push((s + a - 1) % a, s, (s + 1) % a), h.push(0, 1, 0); var l = t.AnimationUtils.getKeyframeOrder(c); c = t.AnimationUtils.sortedArray(c, 1, l), h = t.AnimationUtils.sortedArray(h, 1, l), r || 0 !== c[0] || (c.push(a), h.push(h[0])), o.push(new gr(".morphTargetInfluences[" + i[s].name + "]", c, h).scale(1 / n)) } return new wr(e, -1, o) }, findByName: function (t, e) { var i = t; if (!Array.isArray(t)) { var n = t; i = n.geometry && n.geometry.animations || n.animations } for (var r = 0; r < i.length; r++)if (i[r].name === e) return i[r]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, i) { for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) { var s = t[a], c = s.name.match(r); if (c && c.length > 1) { var h = n[u = c[1]]; h || (n[u] = h = []), h.push(s) } } var l = []; for (var u in n) l.push(wr.CreateFromMorphTargetSequence(u, n[u], e, i)); return l }, parseAnimation: function (e, i, n) { if (!e) return console.error("  no animation in JSONLoader data"), null; for (var r = function (e, i, n, r, a) { if (0 !== n.length) { var o = [], s = []; t.AnimationUtils.flattenJSON(n, o, s, r), 0 !== o.length && a.push(new e(i, o, s)) } }, a = [], o = e.name || "default", s = e.length || -1, c = e.fps || 30, h = e.hierarchy || [], l = 0; l < h.length; l++) { var u = h[l].keys; if (u && 0 !== u.length) if (u[0].morphTargets) { for (var p = {}, d = 0; d < u.length; d++)if (u[d].morphTargets) for (var f = 0; f < u[d].morphTargets.length; f++)p[u[d].morphTargets[f]] = -1; for (var m in p) { var g = [], v = []; for (f = 0; f !== u[d].morphTargets.length; ++f) { var y = u[d]; g.push(y.time), v.push(y.morphTarget === m ? 1 : 0) } a.push(new gr(".morphTargetInfluence[" + m + "]", g, v)) } s = p.length * (c || 1) } else { var x = ".bones[" + i[l].name + "]"; r(dr, x + ".position", u, "pos", a), r(mr, x + ".quaternion", u, "rot", a), r(dr, x + ".scale", u, "scl", a) } } return 0 === a.length ? null : new wr(o, s, a) } }), Object.assign(br.prototype, { load: function (t, e, i, n) { var r = this; new Vn(r.manager).load(t, (function (t) { e(r.parse(JSON.parse(t))) }), i, n) }, setTextures: function (t) { this.textures = t }, parse: function (t) { var e = this.textures; function i(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } var n = new THREE[t.type]; if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.uniforms && (n.uniforms = t.uniforms), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.shading && (n.shading = t.shading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalScale) { var r = t.normalScale; !1 === Array.isArray(r) && (r = [r, r]), n.normalScale = (new Pt).fromArray(r) } if (void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.materials) for (var a = 0, o = t.materials.length; a < o; a++)n.materials.push(this.parse(t.materials[a])); return n } }), Object.assign(Mr.prototype, { load: function (t, e, i, n) { var r = this; new Vn(r.manager).load(t, (function (t) { e(r.parse(JSON.parse(t))) }), i, n) }, parse: function (t) { var e = new ki, i = t.data.index, n = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; if (void 0 !== i) { var r = new n[i.type](i.array); e.setIndex(new xi(r, 1)) } var a = t.data.attributes; for (var o in a) { var s = a[o]; r = new n[s.type](s.array); e.addAttribute(o, new xi(r, s.itemSize, s.normalized)) } var c = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== c) for (var h = 0, l = c.length; h !== l; ++h) { var u = c[h]; e.addGroup(u.start, u.count, u.materialIndex) } var p = t.data.boundingSphere; if (void 0 !== p) { var d = new kt; void 0 !== p.center && d.fromArray(p.center), e.boundingSphere = new Qe(d, p.radius) } return e } }), Er.prototype = { constructor: Er, crossOrigin: void 0, extractUrlBase: function (t) { var e = t.split("/"); return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/") }, initMaterials: function (t, e, i) { for (var n = [], r = 0; r < t.length; ++r)n[r] = this.createMaterial(t[r], e, i); return n }, createMaterial: function (e, i, n) { void 0 === Wn && (Wn = new Ge), void 0 === Xn && (Xn = new Kn), void 0 === Yn && (Yn = new br); var r = {}; function a(e, a, o, s, c) { var h, l = i + e, u = Er.Handlers.get(l); null !== u ? h = u.load(l) : (Xn.setCrossOrigin(n), h = Xn.load(l)), void 0 !== a && (h.repeat.fromArray(a), 1 !== a[0] && (h.wrapS = Q), 1 !== a[1] && (h.wrapT = Q)), void 0 !== o && h.offset.fromArray(o), void 0 !== s && ("repeat" === s[0] && (h.wrapS = Q), "mirror" === s[0] && (h.wrapS = $), "repeat" === s[1] && (h.wrapT = Q), "mirror" === s[1] && (h.wrapT = $)), void 0 !== c && (h.anisotropy = c); var p = t.Math.generateUUID(); return r[p] = h, p } var o = { uuid: t.Math.generateUUID(), type: "MeshLambertMaterial" }; for (var s in e) { var c = e[s]; switch (s) { case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "DbgName": o.name = c; break; case "blending": o.blending = THREE[c]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", s, "is no longer supported."); break; case "colorDiffuse": o.color = Wn.fromArray(c).getHex(); break; case "colorSpecular": o.specular = Wn.fromArray(c).getHex(); break; case "colorEmissive": o.emissive = Wn.fromArray(c).getHex(); break; case "specularCoef": o.shininess = c; break; case "shading": "basic" === c.toLowerCase() && (o.type = "MeshBasicMaterial"), "phong" === c.toLowerCase() && (o.type = "MeshPhongMaterial"), "standard" === c.toLowerCase() && (o.type = "MeshStandardMaterial"); break; case "mapDiffuse": o.map = a(c, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break; case "mapEmissive": o.emissiveMap = a(c, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break; case "mapLight": o.lightMap = a(c, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break; case "mapAO": o.aoMap = a(c, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy); break; case "mapBump": o.bumpMap = a(c, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break; case "mapBumpScale": o.bumpScale = c; break; case "mapNormal": o.normalMap = a(c, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break; case "mapNormalFactor": o.normalScale = [c, c]; break; case "mapSpecular": o.specularMap = a(c, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break; case "mapMetalness": o.metalnessMap = a(c, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break; case "mapRoughness": o.roughnessMap = a(c, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break; case "mapAlpha": o.alphaMap = a(c, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break; case "flipSided": o.side = f; break; case "doubleSided": o.side = m; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), o.opacity = c; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": o[s] = c; break; case "vertexColors": !0 === c && (o.vertexColors = 2), "face" === c && (o.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", s, c) } } return "MeshBasicMaterial" === o.type && delete o.emissive, "MeshPhongMaterial" !== o.type && delete o.specular, o.opacity < 1 && (o.transparent = !0), Yn.setTextures(r), Yn.parse(o) } }, Er.Handlers = { handlers: [], add: function (t, e) { this.handlers.push(t, e) }, get: function (t) { for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) { var r = e[i], a = e[i + 1]; if (r.test(t)) return a } return null } }, Object.assign(Tr.prototype, { load: function (t, e, i, n) { var r = this, a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Er.prototype.extractUrlBase(t), o = new Vn(this.manager); o.setWithCredentials(this.withCredentials), o.load(t, (function (i) { var n = JSON.parse(i), o = n.metadata; if (void 0 !== o) { var s = o.type; if (void 0 !== s) { if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead."); if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.") } } var c = r.parse(n, a); e(c.geometry, c.materials) }), i, n) }, setTexturePath: function (t) { this.texturePath = t }, parse: function (t, e) { var i = new Pi, n = void 0 !== t.scale ? 1 / t.scale : 1; if (function (e) { function n(t, e) { return t & 1 << e } var r, a, o, s, c, h, l, u, p, d, f, m, g, v, y, x, _, w, b, M, E, T, S, A, L, R = t.faces, P = t.vertices, C = t.normals, U = t.colors, I = 0; if (void 0 !== t.uvs) { for (r = 0; r < t.uvs.length; r++)t.uvs[r].length && I++; for (r = 0; r < I; r++)i.faceVertexUvs[r] = [] } s = 0, c = P.length; for (; s < c;)(w = new kt).x = P[s++] * e, w.y = P[s++] * e, w.z = P[s++] * e, i.vertices.push(w); s = 0, c = R.length; for (; s < c;)if (f = n(d = R[s++], 0), m = n(d, 1), g = n(d, 3), v = n(d, 4), y = n(d, 5), x = n(d, 6), _ = n(d, 7), f) { if ((M = new Mi).a = R[s], M.b = R[s + 1], M.c = R[s + 3], (E = new Mi).a = R[s + 1], E.b = R[s + 2], E.c = R[s + 3], s += 4, m && (p = R[s++], M.materialIndex = p, E.materialIndex = p), o = i.faces.length, g) for (r = 0; r < I; r++)for (A = t.uvs[r], i.faceVertexUvs[r][o] = [], i.faceVertexUvs[r][o + 1] = [], a = 0; a < 4; a++)L = new Pt(A[2 * (u = R[s++])], A[2 * u + 1]), 2 !== a && i.faceVertexUvs[r][o].push(L), 0 !== a && i.faceVertexUvs[r][o + 1].push(L); if (v && (l = 3 * R[s++], M.normal.set(C[l++], C[l++], C[l]), E.normal.copy(M.normal)), y) for (r = 0; r < 4; r++)l = 3 * R[s++], S = new kt(C[l++], C[l++], C[l]), 2 !== r && M.vertexNormals.push(S), 0 !== r && E.vertexNormals.push(S); if (x && (T = U[h = R[s++]], M.color.setHex(T), E.color.setHex(T)), _) for (r = 0; r < 4; r++)T = U[h = R[s++]], 2 !== r && M.vertexColors.push(new Ge(T)), 0 !== r && E.vertexColors.push(new Ge(T)); i.faces.push(M), i.faces.push(E) } else { if ((b = new Mi).a = R[s++], b.b = R[s++], b.c = R[s++], m && (p = R[s++], b.materialIndex = p), o = i.faces.length, g) for (r = 0; r < I; r++)for (A = t.uvs[r], i.faceVertexUvs[r][o] = [], a = 0; a < 3; a++)L = new Pt(A[2 * (u = R[s++])], A[2 * u + 1]), i.faceVertexUvs[r][o].push(L); if (v && (l = 3 * R[s++], b.normal.set(C[l++], C[l++], C[l])), y) for (r = 0; r < 3; r++)l = 3 * R[s++], S = new kt(C[l++], C[l++], C[l]), b.vertexNormals.push(S); if (x && (h = R[s++], b.color.setHex(U[h])), _) for (r = 0; r < 3; r++)h = R[s++], b.vertexColors.push(new Ge(U[h])); i.faces.push(b) } }(n), function () { var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2; if (t.skinWeights) for (var n = 0, r = t.skinWeights.length; n < r; n += e) { var a = t.skinWeights[n], o = e > 1 ? t.skinWeights[n + 1] : 0, s = e > 2 ? t.skinWeights[n + 2] : 0, c = e > 3 ? t.skinWeights[n + 3] : 0; i.skinWeights.push(new Ue(a, o, s, c)) } if (t.skinIndices) for (n = 0, r = t.skinIndices.length; n < r; n += e) { var h = t.skinIndices[n], l = e > 1 ? t.skinIndices[n + 1] : 0, u = e > 2 ? t.skinIndices[n + 2] : 0, p = e > 3 ? t.skinIndices[n + 3] : 0; i.skinIndices.push(new Ue(h, l, u, p)) } i.bones = t.bones, i.bones && i.bones.length > 0 && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && console.warn("When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match.") }(), function (e) { if (void 0 !== t.morphTargets) for (var n = 0, r = t.morphTargets.length; n < r; n++) { i.morphTargets[n] = {}, i.morphTargets[n].name = t.morphTargets[n].name, i.morphTargets[n].vertices = []; for (var a = i.morphTargets[n].vertices, o = t.morphTargets[n].vertices, s = 0, c = o.length; s < c; s += 3) { var h = new kt; h.x = o[s] * e, h.y = o[s + 1] * e, h.z = o[s + 2] * e, a.push(h) } } if (void 0 !== t.morphColors && t.morphColors.length > 0) { console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'); var l = i.faces, u = t.morphColors[0].colors; for (n = 0, r = l.length; n < r; n++)l[n].color.fromArray(u, 3 * n) } }(n), function () { var e = [], n = []; void 0 !== t.animation && n.push(t.animation); void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations)); for (var r = 0; r < n.length; r++) { var a = wr.parseAnimation(n[r], i.bones); a && e.push(a) } if (i.morphTargets) { var o = wr.CreateClipsFromMorphTargetSequences(i.morphTargets, 10); e = e.concat(o) } e.length > 0 && (i.animations = e) }(), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length) return { geometry: i }; var r = Er.prototype.initMaterials(t.materials, e, this.crossOrigin); return { geometry: i, materials: r } } }), Object.assign(Sr.prototype, { load: function (t, e, i, n) { "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1)); var r = this; new Vn(r.manager).load(t, (function (t) { r.parse(JSON.parse(t), e) }), i, n) }, setTexturePath: function (t) { this.texturePath = t }, setCrossOrigin: function (t) { this.crossOrigin = t }, parse: function (t, e) { var i = this.parseGeometries(t.geometries), n = this.parseImages(t.images, (function () { void 0 !== e && e(o) })), r = this.parseTextures(t.textures, n), a = this.parseMaterials(t.materials, r), o = this.parseObject(t.object, i, a); return t.animations && (o.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o }, parseGeometries: function (t) { var e = {}; if (void 0 !== t) for (var i = new Tr, n = new Mr, r = 0, a = t.length; r < a; r++) { var o, s = t[r]; switch (s.type) { case "PlaneGeometry": case "PlaneBufferGeometry": o = new THREE[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": o = new THREE[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": o = new THREE[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": o = new THREE[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": o = new THREE[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": o = new THREE[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case "DodecahedronGeometry": case "IcosahedronGeometry": case "OctahedronGeometry": case "TetrahedronGeometry": o = new THREE[s.type](s.radius, s.detail); break; case "RingGeometry": case "RingBufferGeometry": o = new THREE[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": o = new THREE[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": o = new THREE[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break; case "LatheGeometry": case "LatheBufferGeometry": o = new THREE[s.type](s.points, s.segments, s.phiStart, s.phiLength); break; case "BufferGeometry": o = n.parse(s); break; case "Geometry": o = i.parse(s.data, this.texturePath).geometry; break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"'); continue }o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), e[s.uuid] = o } return e }, parseMaterials: function (t, e) { var i = {}; if (void 0 !== t) { var n = new br; n.setTextures(e); for (var r = 0, a = t.length; r < a; r++) { var o = n.parse(t[r]); i[o.uuid] = o } } return i }, parseAnimations: function (t) { for (var e = [], i = 0; i < t.length; i++) { var n = wr.parse(t[i]); e.push(n) } return e }, parseImages: function (t, e) { var i = this, n = {}; function r(t) { return i.manager.itemStart(t), a.load(t, (function () { i.manager.itemEnd(t) }), void 0, (function () { i.manager.itemError(t) })) } if (void 0 !== t && t.length > 0) { var a = new Jn(new Hn(e)); a.setCrossOrigin(this.crossOrigin); for (var o = 0, s = t.length; o < s; o++) { var c = t[o], h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.texturePath + c.url; n[c.uuid] = r(h) } } return n }, parseTextures: function (t, e) { function i(t) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), THREE[t]) } var n = {}; if (void 0 !== t) for (var r = 0, a = t.length; r < a; r++) { var o = t[r]; void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image); var s = new Ct(e[o.image]); s.needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = i(o.mapping)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.wrap && (s.wrapS = i(o.wrap[0]), s.wrapT = i(o.wrap[1])), void 0 !== o.minFilter && (s.minFilter = i(o.minFilter)), void 0 !== o.magFilter && (s.magFilter = i(o.magFilter)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), n[o.uuid] = s } return n }, parseObject: function () { var t = new Ht; return function (e, i, n) { var r; function a(t) { return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), i[t] } function o(t) { if (void 0 !== t) return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t] } switch (e.type) { case "Scene": r = new dn, void 0 !== e.background && Number.isInteger(e.background) && (r.background = new THREE.Color(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? r.fog = new pn(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (r.fog = new un(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": r = new cn(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (r.focus = e.focus), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset), void 0 !== e.view && (r.view = Object.assign({}, e.view)); break; case "OrthographicCamera": r = new hn(e.left, e.right, e.top, e.bottom, e.near, e.far); break; case "AmbientLight": r = new sr(e.color, e.intensity); break; case "DirectionalLight": r = new or(e.color, e.intensity); break; case "PointLight": r = new rr(e.color, e.intensity, e.distance, e.decay); break; case "SpotLight": r = new nr(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": r = new tr(e.color, e.groundColor, e.intensity); break; case "Mesh": var s = a(e.geometry), c = o(e.material); r = s.bones && s.bones.length > 0 ? new wn(s, c) : new an(s, c); break; case "LOD": r = new vn; break; case "Line": r = new Mn(a(e.geometry), o(e.material), e.mode); break; case "LineSegments": r = new En(a(e.geometry), o(e.material)); break; case "PointCloud": case "Points": r = new Sn(a(e.geometry), o(e.material)); break; case "Sprite": r = new gn(o(e.material)); break; case "Group": r = new An; break; default: r = new Si }if (r.uuid = e.uuid, void 0 !== e.name && (r.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== e.position && r.position.fromArray(e.position), void 0 !== e.rotation && r.rotation.fromArray(e.rotation), void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion), void 0 !== e.scale && r.scale.fromArray(e.scale)), void 0 !== e.castShadow && (r.castShadow = e.castShadow), void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && r.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (r.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.children) for (var h in e.children) r.add(this.parseObject(e.children[h], i, n)); if ("LOD" === e.type) for (var l = e.levels, u = 0; u < l.length; u++) { var p = l[u]; void 0 !== (h = r.getObjectByProperty("uuid", p.object)) && r.addLevel(h, p.distance) } return r } }() }), t.ShapeUtils = { area: function (t) { for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++)i += t[n].x * t[r].y - t[r].x * t[n].y; return .5 * i }, triangulate: function () { function e(t, e, i, n, r, a) { var o, s, c, h, l, u, p, d, f, m, g, v, y, x, _, w, b; if (s = t[a[e]].x, c = t[a[e]].y, h = t[a[i]].x, l = t[a[i]].y, u = t[a[n]].x, p = t[a[n]].y, Number.EPSILON > (h - s) * (p - c) - (l - c) * (u - s)) return !1; for (m = u - h, g = p - l, v = s - u, y = c - p, x = h - s, _ = l - c, o = 0; o < r; o++)if (d = t[a[o]].x, f = t[a[o]].y, !(d === s && f === c || d === h && f === l || d === u && f === p) && (w = x * (f - c) - _ * (d - s), b = v * (f - p) - y * (d - u), m * (f - l) - g * (d - h) >= -Number.EPSILON && b >= -Number.EPSILON && w >= -Number.EPSILON)) return !1; return !0 } return function (i, n) { var r = i.length; if (r < 3) return null; var a, o, s, c = [], h = [], l = []; if (t.ShapeUtils.area(i) > 0) for (o = 0; o < r; o++)h[o] = o; else for (o = 0; o < r; o++)h[o] = r - 1 - o; var u = r, p = 2 * u; for (o = u - 1; u > 2;) { if (p-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), n ? l : c; if (u <= (a = o) && (a = 0), u <= (o = a + 1) && (o = 0), u <= (s = o + 1) && (s = 0), e(i, a, o, s, u, h)) { var d, f, m, g, v; for (d = h[a], f = h[o], m = h[s], c.push([i[d], i[f], i[m]]), l.push([h[a], h[o], h[s]]), g = o, v = o + 1; v < u; g++, v++)h[g] = h[v]; p = 2 * --u } } return n ? l : c } }(), triangulateShape: function (e, i) { function n(t) { var e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function r(t, e, i) { return t.x !== e.x ? t.x < e.x ? t.x <= i.x && i.x <= e.x : e.x <= i.x && i.x <= t.x : t.y < e.y ? t.y <= i.y && i.y <= e.y : e.y <= i.y && i.y <= t.y } function a(t, e, i, n, a) { var o = e.x - t.x, s = e.y - t.y, c = n.x - i.x, h = n.y - i.y, l = t.x - i.x, u = t.y - i.y, p = s * c - o * h, d = s * l - o * u; if (Math.abs(p) > Number.EPSILON) { var f; if (p > 0) { if (d < 0 || d > p) return []; if ((f = h * l - c * u) < 0 || f > p) return [] } else { if (d > 0 || d < p) return []; if ((f = h * l - c * u) > 0 || f < p) return [] } if (0 === f) return !a || 0 !== d && d !== p ? [t] : []; if (f === p) return !a || 0 !== d && d !== p ? [e] : []; if (0 === d) return [i]; if (d === p) return [n]; var m = f / p; return [{ x: t.x + m * o, y: t.y + m * s }] } if (0 !== d || h * l != c * u) return []; var g, v, y, x, _, w, b, M, E = 0 === o && 0 === s, T = 0 === c && 0 === h; return E && T ? t.x !== i.x || t.y !== i.y ? [] : [t] : E ? r(i, n, t) ? [t] : [] : T ? r(t, e, i) ? [i] : [] : (0 !== o ? (t.x < e.x ? (g = t, y = t.x, v = e, x = e.x) : (g = e, y = e.x, v = t, x = t.x), i.x < n.x ? (_ = i, b = i.x, w = n, M = n.x) : (_ = n, b = n.x, w = i, M = i.x)) : (t.y < e.y ? (g = t, y = t.y, v = e, x = e.y) : (g = e, y = e.y, v = t, x = t.y), i.y < n.y ? (_ = i, b = i.y, w = n, M = n.y) : (_ = n, b = n.y, w = i, M = i.y)), y <= b ? x < b ? [] : x === b ? a ? [] : [_] : x <= M ? [_, v] : [_, w] : y > M ? [] : y === M ? a ? [] : [g] : x <= M ? [g, v] : [g, w]) } function o(t, e, i, n) { var r = e.x - t.x, a = e.y - t.y, o = i.x - t.x, s = i.y - t.y, c = n.x - t.x, h = n.y - t.y, l = r * s - a * o, u = r * h - a * c; if (Math.abs(l) > Number.EPSILON) { var p = c * s - h * o; return l > 0 ? u >= 0 && p >= 0 : u >= 0 || p >= 0 } return u > 0 } n(e), i.forEach(n); for (var s, c, h, l, u, p, d = {}, f = e.concat(), m = 0, g = i.length; m < g; m++)Array.prototype.push.apply(f, i[m]); for (s = 0, c = f.length; s < c; s++)void 0 !== d[u = f[s].x + ":" + f[s].y] && console.warn("THREE.ShapeUtils: Duplicate point", u, s), d[u] = s; var v = function (t, e) { var i, n = t.concat(); function r(t, e) { var r = n.length - 1, a = t - 1; a < 0 && (a = r); var s = t + 1; s > r && (s = 0); var c = o(n[t], n[a], n[s], i[e]); if (!c) return !1; var h = i.length - 1, l = e - 1; l < 0 && (l = h); var u = e + 1; return u > h && (u = 0), !!(c = o(i[e], i[l], i[u], n[t])) } function s(t, e) { var i, r; for (i = 0; i < n.length; i++)if (r = i + 1, r %= n.length, a(t, e, n[i], n[r], !0).length > 0) return !0; return !1 } var c = []; function h(t, i) { var n, r, o, s; for (n = 0; n < c.length; n++)for (r = e[c[n]], o = 0; o < r.length; o++)if (s = o + 1, s %= r.length, a(t, i, r[o], r[s], !0).length > 0) return !0; return !1 } for (var l, u, p, d, f, m, g, v, y, x, _ = [], w = 0, b = e.length; w < b; w++)c.push(w); for (var M = 0, E = 2 * c.length; c.length > 0;) { if (--E < 0) { console.log("Infinite Loop! Holes left:" + c.length + ", Probably Hole outside Shape!"); break } for (u = M; u < n.length; u++) { p = n[u], l = -1; for (w = 0; w < c.length; w++)if (f = c[w], void 0 === _[m = p.x + ":" + p.y + ":" + f]) { i = e[f]; for (var T = 0; T < i.length; T++)if (d = i[T], r(u, T) && !s(p, d) && !h(p, d)) { l = T, c.splice(w, 1), g = n.slice(0, u + 1), v = n.slice(u), y = i.slice(l), x = i.slice(0, l + 1), n = g.concat(y).concat(x).concat(v), M = u; break } if (l >= 0) break; _[m] = !0 } if (l >= 0) break } } return n }(e, i), y = t.ShapeUtils.triangulate(v, !1); for (s = 0, c = y.length; s < c; s++)for (l = y[s], h = 0; h < 3; h++)void 0 !== (p = d[u = l[h].x + ":" + l[h].y]) && (l[h] = p); return y.concat() }, isClockWise: function (e) { return t.ShapeUtils.area(e) < 0 }, b2: function (t, e, i, n) { return function (t, e) { var i = 1 - t; return i * i * e }(t, e) + function (t, e) { return 2 * (1 - t) * t * e }(t, i) + function (t, e) { return t * t * e }(t, n) }, b3: function (t, e, i, n, r) { return function (t, e) { var i = 1 - t; return i * i * i * e }(t, e) + function (t, e) { var i = 1 - t; return 3 * i * i * t * e }(t, i) + function (t, e) { return 3 * (1 - t) * t * t * e }(t, n) + function (t, e) { return t * t * t * e }(t, r) } }, Ar.prototype = { constructor: Ar, getPoint: function (t) { return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null }, getPointAt: function (t) { var e = this.getUtoTmapping(t); return this.getPoint(e) }, getPoints: function (t) { t || (t = 5); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return e }, getSpacedPoints: function (t) { t || (t = 5); for (var e = [], i = 0; i <= t; i++)e.push(this.getPointAt(i / t)); return e }, getLength: function () { var t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var e, i, n = [], r = this.getPoint(0), a = 0; for (n.push(0), i = 1; i <= t; i++)a += (e = this.getPoint(i / t)).distanceTo(r), n.push(a), r = e; return this.cacheArcLengths = n, n }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { var i, n = this.getLengths(), r = 0, a = n.length; i = e || t * n[a - 1]; for (var o, s = 0, c = a - 1; s <= c;)if ((o = n[r = Math.floor(s + (c - s) / 2)] - i) < 0) s = r + 1; else { if (!(o > 0)) { c = r; break } c = r - 1 } if (n[r = c] === i) return r / (a - 1); var h = n[r]; return (r + (i - h) / (n[r + 1] - h)) / (a - 1) }, getTangent: function (t) { var e = 1e-4, i = t - e, n = t + e; i < 0 && (i = 0), n > 1 && (n = 1); var r = this.getPoint(i); return this.getPoint(n).clone().sub(r).normalize() }, getTangentAt: function (t) { var e = this.getUtoTmapping(t); return this.getTangent(e) } }, Ar.create = function (t, e) { return t.prototype = Object.create(Ar.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Lr.prototype = Object.create(Ar.prototype), Lr.prototype.constructor = Lr, Lr.prototype.isLineCurve = !0, Lr.prototype.getPoint = function (t) { if (1 === t) return this.v2.clone(); var e = this.v2.clone().sub(this.v1); return e.multiplyScalar(t).add(this.v1), e }, Lr.prototype.getPointAt = function (t) { return this.getPoint(t) }, Lr.prototype.getTangent = function (t) { return this.v2.clone().sub(this.v1).normalize() }, Rr.prototype = Object.assign(Object.create(Ar.prototype), { constructor: Rr, add: function (t) { this.curves.push(t) }, closePath: function () { var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Lr(e, t)) }, getPoint: function (t) { for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) { if (i[n] >= e) { var r = i[n] - e, a = this.curves[n], o = a.getLength(), s = 0 === o ? 0 : 1 - r / o; return a.getPointAt(s) } n++ } return null }, getLength: function () { var t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t, t }, getSpacedPoints: function (t) { t || (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)for (var a = r[n], o = a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) { var h = s[c]; e && e.equals(h) || (i.push(h), e = h) } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i }, createPointsGeometry: function (t) { var e = this.getPoints(t); return this.createGeometry(e) }, createSpacedPointsGeometry: function (t) { var e = this.getSpacedPoints(t); return this.createGeometry(e) }, createGeometry: function (t) { for (var e = new Pi, i = 0, n = t.length; i < n; i++) { var r = t[i]; e.vertices.push(new kt(r.x, r.y, r.z || 0)) } return e } }), Pr.prototype = Object.create(Ar.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isEllipseCurve = !0, Pr.prototype.getPoint = function (t) { for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, n = Math.abs(i) < Number.EPSILON; i < 0;)i += e; for (; i > e;)i -= e; i < Number.EPSILON && (i = n ? 0 : e), !0 !== this.aClockwise || n || (i === e ? i = -e : i -= e); var r = this.aStartAngle + t * i, a = this.aX + this.xRadius * Math.cos(r), o = this.aY + this.yRadius * Math.sin(r); if (0 !== this.aRotation) { var s = Math.cos(this.aRotation), c = Math.sin(this.aRotation), h = a - this.aX, l = o - this.aY; a = h * s - l * c + this.aX, o = h * c + l * s + this.aY } return new Pt(a, o) }, t.CurveUtils = { tangentQuadraticBezier: function (t, e, i, n) { return 2 * (1 - t) * (i - e) + 2 * t * (n - i) }, tangentCubicBezier: function (t, e, i, n, r) { return -3 * e * (1 - t) * (1 - t) + 3 * i * (1 - t) * (1 - t) - 6 * t * i * (1 - t) + 6 * t * n * (1 - t) - 3 * t * t * n + 3 * t * t * r }, tangentSpline: function (t, e, i, n, r) { return 6 * t * t - 6 * t + (3 * t * t - 4 * t + 1) + (-6 * t * t + 6 * t) + (3 * t * t - 2 * t) }, interpolate: function (t, e, i, n, r) { var a = .5 * (i - t), o = .5 * (n - e), s = r * r; return (2 * e - 2 * i + a + o) * (r * s) + (-3 * e + 3 * i - 2 * a - o) * s + a * r + e } }, Cr.prototype = Object.create(Ar.prototype), Cr.prototype.constructor = Cr, Cr.prototype.isSplineCurve = !0, Cr.prototype.getPoint = function (e) { var i = this.points, n = (i.length - 1) * e, r = Math.floor(n), a = n - r, o = i[0 === r ? r : r - 1], s = i[r], c = i[r > i.length - 2 ? i.length - 1 : r + 1], h = i[r > i.length - 3 ? i.length - 1 : r + 2], l = t.CurveUtils.interpolate; return new Pt(l(o.x, s.x, c.x, h.x, a), l(o.y, s.y, c.y, h.y, a)) }, Ur.prototype = Object.create(Ar.prototype), Ur.prototype.constructor = Ur, Ur.prototype.getPoint = function (e) { var i = t.ShapeUtils.b3; return new Pt(i(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), i(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)) }, Ur.prototype.getTangent = function (e) { var i = t.CurveUtils.tangentCubicBezier; return new Pt(i(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), i(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize() }, Ir.prototype = Object.create(Ar.prototype), Ir.prototype.constructor = Ir, Ir.prototype.getPoint = function (e) { var i = t.ShapeUtils.b2; return new Pt(i(e, this.v0.x, this.v1.x, this.v2.x), i(e, this.v0.y, this.v1.y, this.v2.y)) }, Ir.prototype.getTangent = function (e) { var i = t.CurveUtils.tangentQuadraticBezier; return new Pt(i(e, this.v0.x, this.v1.x, this.v2.x), i(e, this.v0.y, this.v1.y, this.v2.y)).normalize() }; var Dr, Nr, Fr, Or, zr, Br, Gr, Hr, Vr = Object.assign(Object.create(Rr.prototype), { fromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, i = t.length; e < i; e++)this.lineTo(t[e].x, t[e].y) }, moveTo: function (t, e) { this.currentPoint.set(t, e) }, lineTo: function (t, e) { var i = new Lr(this.currentPoint.clone(), new Pt(t, e)); this.curves.push(i), this.currentPoint.set(t, e) }, quadraticCurveTo: function (t, e, i, n) { var r = new Ir(this.currentPoint.clone(), new Pt(t, e), new Pt(i, n)); this.curves.push(r), this.currentPoint.set(i, n) }, bezierCurveTo: function (t, e, i, n, r, a) { var o = new Ur(this.currentPoint.clone(), new Pt(t, e), new Pt(i, n), new Pt(r, a)); this.curves.push(o), this.currentPoint.set(r, a) }, splineThru: function (t) { var e = new Cr([this.currentPoint.clone()].concat(t)); this.curves.push(e), this.currentPoint.copy(t[t.length - 1]) }, arc: function (t, e, i, n, r, a) { var o = this.currentPoint.x, s = this.currentPoint.y; this.absarc(t + o, e + s, i, n, r, a) }, absarc: function (t, e, i, n, r, a) { this.absellipse(t, e, i, i, n, r, a) }, ellipse: function (t, e, i, n, r, a, o, s) { var c = this.currentPoint.x, h = this.currentPoint.y; this.absellipse(t + c, e + h, i, n, r, a, o, s) }, absellipse: function (t, e, i, n, r, a, o, s) { var c = new Pr(t, e, i, n, r, a, o, s); if (this.curves.length > 0) { var h = c.getPoint(0); h.equals(this.currentPoint) || this.lineTo(h.x, h.y) } this.curves.push(c); var l = c.getPoint(1); this.currentPoint.copy(l) } }); function kr(t, e, i, n, r, a) { Pi.call(this), this.type = "TubeGeometry", this.parameters = { path: t, segments: e, radius: i, radialSegments: n, closed: r, taper: a }, e = e || 64, i = i || 1, n = n || 8, r = r || !1, a = a || kr.NoTaper; var o, s, c, h, l, u, p, d, f, m, g, v, y, x, _, w, b, M, E, T, S = [], A = this, L = e + 1, R = new kt, P = new kr.FrenetFrames(t, e, r), C = P.tangents, U = P.normals, I = P.binormals; function D(t, e, i) { return A.vertices.push(new kt(t, e, i)) - 1 } for (this.tangents = C, this.normals = U, this.binormals = I, f = 0; f < L; f++)for (S[f] = [], c = f / (L - 1), d = t.getPointAt(c), C[f], o = U[f], s = I[f], l = i * a(c), m = 0; m < n; m++)h = m / n * 2 * Math.PI, u = -l * Math.cos(h), p = l * Math.sin(h), R.copy(d), R.x += u * o.x + p * s.x, R.y += u * o.y + p * s.y, R.z += u * o.z + p * s.z, S[f][m] = D(R.x, R.y, R.z); for (f = 0; f < e; f++)for (m = 0; m < n; m++)g = r ? (f + 1) % e : f + 1, v = (m + 1) % n, y = S[f][m], x = S[g][m], _ = S[g][v], w = S[f][v], b = new Pt(f / e, m / n), M = new Pt((f + 1) / e, m / n), E = new Pt((f + 1) / e, (m + 1) / n), T = new Pt(f / e, (m + 1) / n), this.faces.push(new Mi(y, x, w)), this.faceVertexUvs[0].push([b, M, T]), this.faces.push(new Mi(x, _, w)), this.faceVertexUvs[0].push([M.clone(), E, T.clone()]); this.computeFaceNormals(), this.computeVertexNormals() } function jr(t, e) { void 0 !== t ? (Pi.call(this), this.type = "ExtrudeGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeFaceNormals()) : t = [] } function Wr(t, e) { Pi.call(this), this.type = "ShapeGeometry", !1 === Array.isArray(t) && (t = [t]), this.addShapeList(t, e), this.computeFaceNormals() } function Xr() { Yr.apply(this, arguments), this.holes = [] } function Yr(t) { Rr.call(this), this.currentPoint = new Pt, t && this.fromPoints(t) } function qr() { this.subPaths = [], this.currentPath = null } function Zr(t) { this.data = t } function Jr(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function Qr() { return void 0 === Dr && (Dr = new (window.AudioContext || window.webkitAudioContext)), Dr } function Kr(e) { this.manager = void 0 !== e ? e : t.DefaultLoadingManager } function $r() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new cn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new cn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 } function ta(t, e, i) { Si.call(this), this.type = "CubeCamera"; var n = 90, r = new cn(n, 1, t, e); r.up.set(0, -1, 0), r.lookAt(new kt(1, 0, 0)), this.add(r); var a = new cn(n, 1, t, e); a.up.set(0, -1, 0), a.lookAt(new kt(-1, 0, 0)), this.add(a); var o = new cn(n, 1, t, e); o.up.set(0, 0, 1), o.lookAt(new kt(0, 1, 0)), this.add(o); var s = new cn(n, 1, t, e); s.up.set(0, 0, -1), s.lookAt(new kt(0, -1, 0)), this.add(s); var c = new cn(n, 1, t, e); c.up.set(0, -1, 0), c.lookAt(new kt(0, 0, 1)), this.add(c); var h = new cn(n, 1, t, e); h.up.set(0, -1, 0), h.lookAt(new kt(0, 0, -1)), this.add(h); var l = { format: ht, magFilter: nt, minFilter: nt }; this.renderTarget = new Ki(i, i, l), this.updateCubeMap = function (t, e) { null === this.parent && this.updateMatrixWorld(); var i = this.renderTarget, n = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, a, i), i.activeCubeFace = 2, t.render(e, o, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, h, i), t.setRenderTarget(null) } } function ea() { Si.call(this), this.type = "AudioListener", this.context = Qr(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null } function ia(t) { Si.call(this), this.type = "Audio", this.context = t.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] } function na(t) { ia.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain) } function ra(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function aa(t, e, i) { this.binding = t, this.valueSize = i; var n, r = Float64Array; switch (e) { case "quaternion": n = this._slerp; break; case "string": case "bool": r = Array, n = this._select; break; default: n = this._lerp }this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0 } function oa(t, e, i) { this.path = e, this.parsedPath = i || oa.parseTrackName(e), this.node = oa.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function sa(e) { this.uuid = t.Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var i = {}; this._indicesByUUID = i; for (var n = 0, r = arguments.length; n !== r; ++n)i[arguments[n].uuid] = n; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var a = this; this.stats = { objects: { get total() { return a._objects.length }, get inUse() { return this.total - a.nCachedObjects_ } }, get bindingsPerObject() { return a._bindings.length } } } function ca(t, e, i) { this._mixer = t, this._clip = e, this._localRoot = i || null; for (var n = e.tracks, r = n.length, a = new Array(r), o = { endingStart: vt, endingEnd: vt }, s = 0; s !== r; ++s) { var c = n[s].createInterpolant(null); a[s] = c, c.settings = o } this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function ha(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function la(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t, this.dynamic = !1 } function ua() { ki.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 } function pa(e, i, n, r) { this.uuid = t.Math.generateUUID(), this.data = e, this.itemSize = i, this.offset = n, this.normalized = !0 === r } function da(e, i) { this.uuid = t.Math.generateUUID(), this.array = e, this.stride = i, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function fa(t, e, i) { da.call(this, t, e), this.meshPerAttribute = i || 1 } function ma(t, e, i) { xi.call(this, t, e), this.meshPerAttribute = i || 1 } function ga(t, e, i, n) { this.ray = new tn(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function va(t, e) { return t.distance - e.distance } function ya(t, e, i, n) { if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) for (var r = t.children, a = 0, o = r.length; a < o; a++)ya(r[a], e, i, !0) } function xa(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } function _a(t, e, i) { return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this } function wa(t, e) { an.call(this, t, e), this.animationsMap = {}, this.animationsList = []; var i = this.geometry.morphTargets.length, n = "__default", r = i - 1, a = i / 1; this.createAnimation(n, 0, r, a), this.setAnimationWeight(n, 1) } function ba(t) { Si.call(this), this.material = t, this.render = function (t) { } } function Ma(t) { ki.call(this); var e = [0, 0], i = {}; function n(t, e) { return t - e } var r = ["a", "b", "c"]; if (t && t.isGeometry) { for (var a = t.vertices, o = t.faces, s = 0, c = new Uint32Array(6 * o.length), h = 0, l = o.length; h < l; h++)for (var u = o[h], p = 0; p < 3; p++) { e[0] = u[r[p]], e[1] = u[r[(p + 1) % 3]], e.sort(n), void 0 === i[b = e.toString()] && (c[2 * s] = e[0], c[2 * s + 1] = e[1], i[b] = !0, s++) } var d = new Float32Array(2 * s * 3); for (h = 0, l = s; h < l; h++)for (p = 0; p < 2; p++) { var f = a[c[2 * h + p]]; d[(M = 6 * h + 3 * p) + 0] = f.x, d[M + 1] = f.y, d[M + 2] = f.z } this.addAttribute("position", new xi(d, 3)) } else if (t && t.isBufferGeometry) if (null !== t.index) { var m = t.index.array, g = (a = t.attributes.position, t.groups); s = 0; 0 === g.length && t.addGroup(0, m.length); c = new Uint32Array(2 * m.length); for (var v = 0, y = g.length; v < y; ++v)for (var x = g[v], _ = x.start, w = (h = _, _ + x.count); h < w; h += 3)for (p = 0; p < 3; p++) { var b; e[0] = m[h + p], e[1] = m[h + (p + 1) % 3], e.sort(n), void 0 === i[b = e.toString()] && (c[2 * s] = e[0], c[2 * s + 1] = e[1], i[b] = !0, s++) } for (d = new Float32Array(2 * s * 3), h = 0, l = s; h < l; h++)for (p = 0; p < 2; p++) { var M = 6 * h + 3 * p, E = c[2 * h + p]; d[M + 0] = a.getX(E), d[M + 1] = a.getY(E), d[M + 2] = a.getZ(E) } this.addAttribute("position", new xi(d, 3)) } else { var T = (s = (a = t.attributes.position.array).length / 3) / 3; for (d = new Float32Array(2 * s * 3), h = 0, l = T; h < l; h++)for (p = 0; p < 3; p++) { var S = 9 * h + 3 * p; d[(M = 18 * h + 6 * p) + 0] = a[S], d[M + 1] = a[S + 1], d[M + 2] = a[S + 2]; E = 9 * h + (p + 1) % 3 * 3; d[M + 3] = a[E], d[M + 4] = a[E + 1], d[M + 5] = a[E + 2] } this.addAttribute("position", new xi(d, 3)) } } function Ea(t, e) { var i = void 0 !== e ? e : 16777215; En.call(this, new Ma(t.geometry), new bn({ color: i })), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Ta(t, e, i, n) { this.object = t, this.size = void 0 !== e ? e : 1; var r = void 0 !== i ? i : 16711680, a = void 0 !== n ? n : 1, o = 0, s = this.object.geometry; s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count); var c = new ki, h = new bi(2 * o * 3, 3); c.addAttribute("position", h), En.call(this, c, new bn({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() } function Sa(t) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1; for (var e = new ki, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, r = 1; n < 32; n++, r++) { var a = n / 32 * Math.PI * 2, o = r / 32 * Math.PI * 2; i.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1) } e.addAttribute("position", new bi(i, 3)); var s = new bn({ fog: !1 }); this.cone = new En(e, s), this.add(this.cone), this.update() } function Aa(t) { this.bones = this.getBoneList(t); for (var e = new Pi, i = 0; i < this.bones.length; i++) { var n = this.bones[i]; n.parent && n.parent.isBone && (e.vertices.push(new kt), e.vertices.push(new kt), e.colors.push(new Ge(0, 0, 1)), e.colors.push(new Ge(0, 1, 0))) } e.dynamic = !0; var r = new bn({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }); En.call(this, e, r), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function La(t, e, i, n, r, a, o) { ki.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI; for (var s = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI), c = (e + 1) * (i + 1), h = new xi(new Float32Array(3 * c), 3), l = new xi(new Float32Array(3 * c), 3), u = new xi(new Float32Array(2 * c), 2), p = 0, d = [], f = new kt, m = 0; m <= i; m++) { for (var g = [], v = m / i, y = 0; y <= e; y++) { var x = y / e, _ = -t * Math.cos(n + x * r) * Math.sin(a + v * o), w = t * Math.cos(a + v * o), b = t * Math.sin(n + x * r) * Math.sin(a + v * o); f.set(_, w, b).normalize(), h.setXYZ(p, _, w, b), l.setXYZ(p, f.x, f.y, f.z), u.setXY(p, x, 1 - v), g.push(p), p++ } d.push(g) } var M = []; for (m = 0; m < i; m++)for (y = 0; y < e; y++) { var E = d[m][y + 1], T = d[m][y], S = d[m + 1][y], A = d[m + 1][y + 1]; (0 !== m || a > 0) && M.push(E, T, A), (m !== i - 1 || s < Math.PI) && M.push(T, S, A) } this.setIndex(new (h.count > 65535 ? wi : _i)(M, 1)), this.addAttribute("position", h), this.addAttribute("normal", l), this.addAttribute("uv", u), this.boundingSphere = new Qe(new kt, t) } function Ra(t, e) { this.light = t, this.light.updateMatrixWorld(); var i = new La(e, 4, 2), n = new rn({ wireframe: !0, fog: !1 }); n.color.copy(this.light.color).multiplyScalar(this.light.intensity), an.call(this, i, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1 } function Pa(t, e, i, n, r, a, o) { Pi.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o }, this.fromBufferGeometry(new La(t, e, i, n, r, a, o)) } function Ca(t, e) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new Ge, new Ge]; var i = new Pa(e, 4, 2); i.rotateX(-Math.PI / 2); for (var n = 0; n < 8; n++)i.faces[n].color = this.colors[n < 4 ? 0 : 1]; var r = new rn({ vertexColors: 1, wireframe: !0 }); this.lightSphere = new an(i, r), this.add(this.lightSphere), this.update() } function Ua(t, e, i, n) { e = e || 1, i = new Ge(void 0 !== i ? i : 4473924), n = new Ge(void 0 !== n ? n : 8947848); for (var r = e / 2, a = 2 * t / e, o = [], s = [], c = 0, h = 0, l = -t; c <= e; c++, l += a) { o.push(-t, 0, l, t, 0, l), o.push(l, 0, -t, l, 0, t); var u = c === r ? i : n; u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3 } var p = new ki; p.addAttribute("position", new bi(o, 3)), p.addAttribute("color", new bi(s, 3)); var d = new bn({ vertexColors: 2 }); En.call(this, p, d) } function Ia(t, e, i, n) { this.object = t, this.size = void 0 !== e ? e : 1; var r = void 0 !== i ? i : 16776960, a = void 0 !== n ? n : 1, o = 0, s = this.object.geometry; s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); var c = new ki, h = new bi(2 * o * 3, 3); c.addAttribute("position", h), En.call(this, c, new bn({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() } function Da(e, i) { ki.call(this), i = void 0 !== i ? i : 1; var n = Math.cos(t.Math.DEG2RAD * i), r = [0, 0], a = {}; function o(t, e) { return t - e } var s, c = ["a", "b", "c"]; e && e.isBufferGeometry ? (s = new Pi).fromBufferGeometry(e) : s = e.clone(), s.mergeVertices(), s.computeFaceNormals(); for (var h = s.vertices, l = s.faces, u = 0, p = l.length; u < p; u++)for (var d = l[u], f = 0; f < 3; f++) { r[0] = d[c[f]], r[1] = d[c[(f + 1) % 3]], r.sort(o), void 0 === a[g = r.toString()] ? a[g] = { vert1: r[0], vert2: r[1], face1: u, face2: void 0 } : a[g].face2 = u } var m = []; for (var g in a) { var v = a[g]; if (void 0 === v.face2 || l[v.face1].normal.dot(l[v.face2].normal) <= n) { var y = h[v.vert1]; m.push(y.x), m.push(y.y), m.push(y.z), y = h[v.vert2], m.push(y.x), m.push(y.y), m.push(y.z) } } this.addAttribute("position", new xi(new Float32Array(m), 3)) } function Na(t, e, i) { var n = void 0 !== e ? e : 16777215; En.call(this, new Da(t.geometry, i), new bn({ color: n })), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Fa(t, e) { Si.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, void 0 === e && (e = 1); var i = new ki; i.addAttribute("position", new bi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); var n = new bn({ fog: !1 }); this.add(new Mn(i, n)), (i = new ki).addAttribute("position", new bi([0, 0, 0, 0, 0, 1], 3)), this.add(new Mn(i, n)), this.update() } function Oa(t) { var e = new Pi, i = new bn({ color: 16777215, vertexColors: 1 }), n = {}, r = 16755200, a = 16711680, o = 43775, s = 3355443; function c(t, e, i) { h(t, i), h(e, i) } function h(t, i) { e.vertices.push(new kt), e.colors.push(new Ge(i)), void 0 === n[t] && (n[t] = []), n[t].push(e.vertices.length - 1) } c("n1", "n2", r), c("n2", "n4", r), c("n4", "n3", r), c("n3", "n1", r), c("f1", "f2", r), c("f2", "f4", r), c("f4", "f3", r), c("f3", "f1", r), c("n1", "f1", r), c("n2", "f2", r), c("n3", "f3", r), c("n4", "f4", r), c("p", "n1", a), c("p", "n2", a), c("p", "n3", a), c("p", "n4", a), c("u1", "u2", o), c("u2", "u3", o), c("u3", "u1", o), c("c", "t", 16777215), c("p", "c", s), c("cn1", "cn2", s), c("cn3", "cn4", s), c("cf1", "cf2", s), c("cf3", "cf4", s), En.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = n, this.update() } function za(t, e, i, n, r, a) { Pi.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }, this.fromBufferGeometry(new $i(t, e, i, n, r, a)), this.mergeVertices() } function Ba(t, e) { var i = void 0 !== e ? e : 8947848; this.object = t, this.box = new Je, an.call(this, new za(1, 1, 1), new rn({ color: i, wireframe: !0 })) } function Ga(t, e) { void 0 === e && (e = 16776960); var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(24), r = new ki; r.setIndex(new xi(i, 1)), r.addAttribute("position", new xi(n, 3)), En.call(this, r, new bn({ color: e })), void 0 !== t && this.update(t) } function Ha(t, e, i, n, r, a, o, s) { ki.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }; var c = this; t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, i = void 0 !== i ? i : 100, n = Math.floor(n) || 8, r = Math.floor(r) || 1, a = void 0 !== a && a, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI; var h = 0; !1 === a && (t > 0 && h++, e > 0 && h++); var l = function () { var t = (n + 1) * (r + 1); !1 === a && (t += (n + 1) * h + n * h); return t }(), u = function () { var t = n * r * 2 * 3; !1 === a && (t += n * h * 3); return t }(), p = new xi(new (u > 65535 ? Uint32Array : Uint16Array)(u), 1), d = new xi(new Float32Array(3 * l), 3), f = new xi(new Float32Array(3 * l), 3), m = new xi(new Float32Array(2 * l), 2), g = 0, v = 0, y = [], x = i / 2, _ = 0; function w(i) { var r, a, h, l = new Pt, u = new kt, y = 0, w = !0 === i ? t : e, b = !0 === i ? 1 : -1; for (a = g, r = 1; r <= n; r++)d.setXYZ(g, 0, x * b, 0), f.setXYZ(g, 0, b, 0), l.x = .5, l.y = .5, m.setXY(g, l.x, l.y), g++; for (h = g, r = 0; r <= n; r++) { var M = r / n * s + o, E = Math.cos(M), T = Math.sin(M); u.x = w * T, u.y = x * b, u.z = w * E, d.setXYZ(g, u.x, u.y, u.z), f.setXYZ(g, 0, b, 0), l.x = .5 * E + .5, l.y = .5 * T * b + .5, m.setXY(g, l.x, l.y), g++ } for (r = 0; r < n; r++) { var S = a + r, A = h + r; !0 === i ? (p.setX(v, A), v++, p.setX(v, A + 1), v++, p.setX(v, S), v++) : (p.setX(v, A + 1), v++, p.setX(v, A), v++, p.setX(v, S), v++), y += 3 } c.addGroup(_, y, !0 === i ? 1 : 2), _ += y } !function () { var a, h, l = new kt, u = new kt, w = 0, b = (e - t) / i; for (h = 0; h <= r; h++) { var M = [], E = h / r, T = E * (e - t) + t; for (a = 0; a <= n; a++) { var S = a / n; u.x = T * Math.sin(S * s + o), u.y = -E * i + x, u.z = T * Math.cos(S * s + o), d.setXYZ(g, u.x, u.y, u.z), l.copy(u), (0 === t && 0 === h || 0 === e && h === r) && (l.x = Math.sin(S * s + o), l.z = Math.cos(S * s + o)), l.setY(Math.sqrt(l.x * l.x + l.z * l.z) * b).normalize(), f.setXYZ(g, l.x, l.y, l.z), m.setXY(g, S, 1 - E), M.push(g), g++ } y.push(M) } for (a = 0; a < n; a++)for (h = 0; h < r; h++) { var A = y[h][a], L = y[h + 1][a], R = y[h + 1][a + 1], P = y[h][a + 1]; p.setX(v, A), v++, p.setX(v, L), v++, p.setX(v, P), v++, p.setX(v, L), v++, p.setX(v, R), v++, p.setX(v, P), v++, w += 6 } c.addGroup(_, w, 0), _ += w }(), !1 === a && (t > 0 && w(!0), e > 0 && w(!1)), this.setIndex(p), this.addAttribute("position", d), this.addAttribute("normal", f), this.addAttribute("uv", m) } kr.prototype = Object.create(Pi.prototype), kr.prototype.constructor = kr, kr.NoTaper = function (t) { return 1 }, kr.SinusoidalTaper = function (t) { return Math.sin(Math.PI * t) }, kr.FrenetFrames = function (e, i, n) { var r, a, o, s, c, h, l, u = new kt, p = [], d = [], f = [], m = new kt, g = new Ht, v = i + 1; for (this.tangents = p, this.normals = d, this.binormals = f, h = 0; h < v; h++)l = h / (v - 1), p[h] = e.getTangentAt(l), p[h].normalize(); for (function () { d[0] = new kt, f[0] = new kt, a = Number.MAX_VALUE, o = Math.abs(p[0].x), s = Math.abs(p[0].y), c = Math.abs(p[0].z), o <= a && (a = o, u.set(1, 0, 0)); s <= a && (a = s, u.set(0, 1, 0)); c <= a && u.set(0, 0, 1); m.crossVectors(p[0], u).normalize(), d[0].crossVectors(p[0], m), f[0].crossVectors(p[0], d[0]) }(), h = 1; h < v; h++)d[h] = d[h - 1].clone(), f[h] = f[h - 1].clone(), m.crossVectors(p[h - 1], p[h]), m.length() > Number.EPSILON && (m.normalize(), r = Math.acos(t.Math.clamp(p[h - 1].dot(p[h]), -1, 1)), d[h].applyMatrix4(g.makeRotationAxis(m, r))), f[h].crossVectors(p[h], d[h]); if (n) for (r = Math.acos(t.Math.clamp(d[0].dot(d[v - 1]), -1, 1)), r /= v - 1, p[0].dot(m.crossVectors(d[0], d[v - 1])) > 0 && (r = -r), h = 1; h < v; h++)d[h].applyMatrix4(g.makeRotationAxis(p[h], r * h)), f[h].crossVectors(p[h], d[h]) }, jr.prototype = Object.create(Pi.prototype), jr.prototype.constructor = jr, jr.prototype.addShapeList = function (t, e) { for (var i = t.length, n = 0; n < i; n++) { var r = t[n]; this.addShape(r, e) } }, jr.prototype.addShape = function (e, i) { var n, r, a, o, s, c, h, l, u = void 0 !== i.amount ? i.amount : 100, p = void 0 !== i.bevelThickness ? i.bevelThickness : 6, d = void 0 !== i.bevelSize ? i.bevelSize : p - 2, f = void 0 !== i.bevelSegments ? i.bevelSegments : 3, m = void 0 === i.bevelEnabled || i.bevelEnabled, g = void 0 !== i.curveSegments ? i.curveSegments : 12, v = void 0 !== i.steps ? i.steps : 1, y = i.extrudePath, x = !1, _ = void 0 !== i.UVGenerator ? i.UVGenerator : jr.WorldUVGenerator; y && (n = y.getSpacedPoints(v), x = !0, m = !1, r = void 0 !== i.frames ? i.frames : new kr.FrenetFrames(y, v, !1), a = new kt, o = new kt, s = new kt), m || (f = 0, p = 0, d = 0); var w = this, b = this.vertices.length, M = e.extractPoints(g), E = M.shape, T = M.holes, S = !t.ShapeUtils.isClockWise(E); if (S) { for (E = E.reverse(), h = 0, l = T.length; h < l; h++)c = T[h], t.ShapeUtils.isClockWise(c) && (T[h] = c.reverse()); S = !1 } var A = t.ShapeUtils.triangulateShape(E, T), L = E; for (h = 0, l = T.length; h < l; h++)c = T[h], E = E.concat(c); function R(t, e, i) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t) } var P, C, U, I, D, N, F = E.length, O = A.length; function z(t, e, i) { var n, r, a = 1, o = t.x - e.x, s = t.y - e.y, c = i.x - t.x, h = i.y - t.y, l = o * o + s * s, u = o * h - s * c; if (Math.abs(u) > Number.EPSILON) { var p = Math.sqrt(l), d = Math.sqrt(c * c + h * h), f = e.x - s / p, m = e.y + o / p, g = ((i.x - h / d - f) * h - (i.y + c / d - m) * c) / (o * h - s * c), v = (n = f + o * g - t.x) * n + (r = m + s * g - t.y) * r; if (v <= 2) return new Pt(n, r); a = Math.sqrt(v / 2) } else { var y = !1; o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0), y ? (n = -s, r = o, a = Math.sqrt(l)) : (n = o, r = s, a = Math.sqrt(l / 2)) } return new Pt(n / a, r / a) } for (var B = [], G = 0, H = L.length, V = H - 1, k = G + 1; G < H; G++, V++, k++)V === H && (V = 0), k === H && (k = 0), B[G] = z(L[G], L[V], L[k]); var j, W, X = [], Y = B.concat(); for (h = 0, l = T.length; h < l; h++) { for (c = T[h], j = [], G = 0, V = (H = c.length) - 1, k = G + 1; G < H; G++, V++, k++)V === H && (V = 0), k === H && (k = 0), j[G] = z(c[G], c[V], c[k]); X.push(j), Y = Y.concat(j) } for (P = 0; P < f; P++) { for (U = P / f, I = p * Math.cos(U * Math.PI / 2), C = d * Math.sin(U * Math.PI / 2), G = 0, H = L.length; G < H; G++)Z((D = R(L[G], B[G], C)).x, D.y, -I); for (h = 0, l = T.length; h < l; h++)for (c = T[h], j = X[h], G = 0, H = c.length; G < H; G++)Z((D = R(c[G], j[G], C)).x, D.y, -I) } for (C = d, G = 0; G < F; G++)D = m ? R(E[G], Y[G], C) : E[G], x ? (o.copy(r.normals[0]).multiplyScalar(D.x), a.copy(r.binormals[0]).multiplyScalar(D.y), s.copy(n[0]).add(o).add(a), Z(s.x, s.y, s.z)) : Z(D.x, D.y, 0); for (W = 1; W <= v; W++)for (G = 0; G < F; G++)D = m ? R(E[G], Y[G], C) : E[G], x ? (o.copy(r.normals[W]).multiplyScalar(D.x), a.copy(r.binormals[W]).multiplyScalar(D.y), s.copy(n[W]).add(o).add(a), Z(s.x, s.y, s.z)) : Z(D.x, D.y, u / v * W); for (P = f - 1; P >= 0; P--) { for (U = P / f, I = p * Math.cos(U * Math.PI / 2), C = d * Math.sin(U * Math.PI / 2), G = 0, H = L.length; G < H; G++)Z((D = R(L[G], B[G], C)).x, D.y, u + I); for (h = 0, l = T.length; h < l; h++)for (c = T[h], j = X[h], G = 0, H = c.length; G < H; G++)D = R(c[G], j[G], C), x ? Z(D.x, D.y + n[v - 1].y, n[v - 1].x + I) : Z(D.x, D.y, u + I) } function q(t, e) { var i, n; for (G = t.length; --G >= 0;) { i = G, (n = G - 1) < 0 && (n = t.length - 1); var r = 0, a = v + 2 * f; for (r = 0; r < a; r++) { var o = F * r, s = F * (r + 1); Q(e + i + o, e + n + o, e + n + s, e + i + s, t, r, a, i, n) } } } function Z(t, e, i) { w.vertices.push(new kt(t, e, i)) } function J(t, e, i) { t += b, e += b, i += b, w.faces.push(new Mi(t, e, i, null, null, 0)); var n = _.generateTopUV(w, t, e, i); w.faceVertexUvs[0].push(n) } function Q(t, e, i, n, r, a, o, s, c) { t += b, e += b, i += b, n += b, w.faces.push(new Mi(t, e, n, null, null, 1)), w.faces.push(new Mi(e, i, n, null, null, 1)); var h = _.generateSideWallUV(w, t, e, i, n); w.faceVertexUvs[0].push([h[0], h[1], h[3]]), w.faceVertexUvs[0].push([h[1], h[2], h[3]]) } !function () { if (m) { var t = 0, e = F * t; for (G = 0; G < O; G++)J((N = A[G])[2] + e, N[1] + e, N[0] + e); for (e = F * (t = v + 2 * f), G = 0; G < O; G++)J((N = A[G])[0] + e, N[1] + e, N[2] + e) } else { for (G = 0; G < O; G++)J((N = A[G])[2], N[1], N[0]); for (G = 0; G < O; G++)J((N = A[G])[0] + F * v, N[1] + F * v, N[2] + F * v) } }(), function () { var t = 0; for (q(L, t), t += L.length, h = 0, l = T.length; h < l; h++)q(c = T[h], t), t += c.length }() }, jr.WorldUVGenerator = { generateTopUV: function (t, e, i, n) { var r = t.vertices, a = r[e], o = r[i], s = r[n]; return [new Pt(a.x, a.y), new Pt(o.x, o.y), new Pt(s.x, s.y)] }, generateSideWallUV: function (t, e, i, n, r) { var a = t.vertices, o = a[e], s = a[i], c = a[n], h = a[r]; return Math.abs(o.y - s.y) < .01 ? [new Pt(o.x, 1 - o.z), new Pt(s.x, 1 - s.z), new Pt(c.x, 1 - c.z), new Pt(h.x, 1 - h.z)] : [new Pt(o.y, 1 - o.z), new Pt(s.y, 1 - s.z), new Pt(c.y, 1 - c.z), new Pt(h.y, 1 - h.z)] } }, Wr.prototype = Object.create(Pi.prototype), Wr.prototype.constructor = Wr, Wr.prototype.addShapeList = function (t, e) { for (var i = 0, n = t.length; i < n; i++)this.addShape(t[i], e); return this }, Wr.prototype.addShape = function (e, i) { void 0 === i && (i = {}); var n, r, a, o = void 0 !== i.curveSegments ? i.curveSegments : 12, s = i.material, c = void 0 === i.UVGenerator ? jr.WorldUVGenerator : i.UVGenerator, h = this.vertices.length, l = e.extractPoints(o), u = l.shape, p = l.holes, d = !t.ShapeUtils.isClockWise(u); if (d) { for (u = u.reverse(), n = 0, r = p.length; n < r; n++)a = p[n], t.ShapeUtils.isClockWise(a) && (p[n] = a.reverse()); d = !1 } var f = t.ShapeUtils.triangulateShape(u, p); for (n = 0, r = p.length; n < r; n++)a = p[n], u = u.concat(a); var m, g, v = u.length, y = f.length; for (n = 0; n < v; n++)m = u[n], this.vertices.push(new kt(m.x, m.y, 0)); for (n = 0; n < y; n++) { var x = (g = f[n])[0] + h, _ = g[1] + h, w = g[2] + h; this.faces.push(new Mi(x, _, w, null, null, s)), this.faceVertexUvs[0].push(c.generateTopUV(this, x, _, w)) } }, Xr.prototype = Object.assign(Object.create(Vr), { constructor: Xr, extrude: function (t) { return new jr(this, t) }, makeGeometry: function (t) { return new Wr(this, t) }, getPointsHoles: function (t) { for (var e = [], i = 0, n = this.holes.length; i < n; i++)e[i] = this.holes[i].getPoints(t); return e }, extractAllPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, extractPoints: function (t) { return this.extractAllPoints(t) } }), Yr.prototype = Vr, Vr.constructor = Yr, qr.prototype = { moveTo: function (t, e) { this.currentPath = new Yr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e) }, lineTo: function (t, e) { this.currentPath.lineTo(t, e) }, quadraticCurveTo: function (t, e, i, n) { this.currentPath.quadraticCurveTo(t, e, i, n) }, bezierCurveTo: function (t, e, i, n, r, a) { this.currentPath.bezierCurveTo(t, e, i, n, r, a) }, splineThru: function (t) { this.currentPath.splineThru(t) }, toShapes: function (e, i) { function n(t) { for (var e = [], i = 0, n = t.length; i < n; i++) { var r = t[i], a = new Xr; a.curves = r.curves, e.push(a) } return e } function r(t, e) { for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) { var o = e[r], s = e[a], c = s.x - o.x, h = s.y - o.y; if (Math.abs(h) > Number.EPSILON) { if (h < 0 && (o = e[a], c = -c, s = e[r], h = -h), t.y < o.y || t.y > s.y) continue; if (t.y === o.y) { if (t.x === o.x) return !0 } else { var l = h * (t.x - o.x) - c * (t.y - o.y); if (0 === l) return !0; if (l < 0) continue; n = !n } } else { if (t.y !== o.y) continue; if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0 } } return n } var a = t.ShapeUtils.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === i) return n(o); var s, c, h, l = []; if (1 === o.length) return c = o[0], (h = new Xr).curves = c.curves, l.push(h), l; var u = !a(o[0].getPoints()); u = e ? !u : u; var p, d, f = [], m = [], g = [], v = 0; m[v] = void 0, g[v] = []; for (var y = 0, x = o.length; y < x; y++)s = a(p = (c = o[y]).getPoints()), (s = e ? !s : s) ? (!u && m[v] && v++, m[v] = { s: new Xr, p: p }, m[v].s.curves = c.curves, u && v++, g[v] = []) : g[v].push({ h: c, p: p[0] }); if (!m[0]) return n(o); if (m.length > 1) { for (var _ = !1, w = [], b = 0, M = m.length; b < M; b++)f[b] = []; for (b = 0, M = m.length; b < M; b++)for (var E = g[b], T = 0; T < E.length; T++) { for (var S = E[T], A = !0, L = 0; L < m.length; L++)r(S.p, m[L].p) && (b !== L && w.push({ froms: b, tos: L, hole: T }), A ? (A = !1, f[L].push(S)) : _ = !0); A && f[b].push(S) } w.length > 0 && (_ || (g = f)) } y = 0; for (var R = m.length; y < R; y++) { h = m[y].s, l.push(h); for (var P = 0, C = (d = g[y]).length; P < C; P++)h.holes.push(d[P].h) } return l } }, Object.assign(Zr.prototype, { isFont: !0, generateShapes: function (e, i, n) { function r(e, i, r) { var o = a.glyphs[e] || a.glyphs["?"]; if (o) { var s, c, h, l, u, p, d, f, m, g, v, y = new qr, x = [], _ = t.ShapeUtils.b2, w = t.ShapeUtils.b3; if (o.o) for (var b = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), M = 0, E = b.length; M < E;) { switch (b[M++]) { case "m": s = b[M++] * i + r, c = b[M++] * i, y.moveTo(s, c); break; case "l": s = b[M++] * i + r, c = b[M++] * i, y.lineTo(s, c); break; case "q": if (h = b[M++] * i + r, l = b[M++] * i, d = b[M++] * i + r, f = b[M++] * i, y.quadraticCurveTo(d, f, h, l), v = x[x.length - 1]) { u = v.x, p = v.y; for (var T = 1; T <= n; T++) { _(S = T / n, u, d, h), _(S, p, f, l) } } break; case "b": if (h = b[M++] * i + r, l = b[M++] * i, d = b[M++] * i + r, f = b[M++] * i, m = b[M++] * i + r, g = b[M++] * i, y.bezierCurveTo(d, f, m, g, h, l), v = x[x.length - 1]) { u = v.x, p = v.y; for (T = 1; T <= n; T++) { var S; w(S = T / n, u, d, m, h), w(S, p, f, g, l) } } } } return { offset: o.ha * i, path: y } } } void 0 === i && (i = 100), void 0 === n && (n = 4); for (var a = this.data, o = function (t) { for (var e = String(t).split(""), n = i / a.resolution, o = 0, s = [], c = 0; c < e.length; c++) { var h = r(e[c], n, o); o += h.offset, s.push(h.path) } return s }(e), s = [], c = 0, h = o.length; c < h; c++)Array.prototype.push.apply(s, o[c].toShapes()); return s } }), Object.assign(Jr.prototype, { load: function (t, e, i, n) { var r = this; new Vn(this.manager).load(t, (function (t) { var i; try { i = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2)) } var n = r.parse(i); e && e(n) }), i, n) }, parse: function (t) { return new Zr(t) } }), Object.assign(Kr.prototype, { load: function (t, e, i, n) { var r = new Vn(this.manager); r.setResponseType("arraybuffer"), r.load(t, (function (t) { Qr().decodeAudioData(t, (function (t) { e(t) })) }), i, n) } }), Object.assign($r.prototype, { update: (Gr = new Ht, Hr = new Ht, function (e) { if (Nr !== e.focus || Fr !== e.fov || Or !== e.aspect * this.aspect || zr !== e.near || Br !== e.far) { Nr = e.focus, Fr = e.fov, Or = e.aspect * this.aspect, zr = e.near, Br = e.far; var i, n, r = e.projectionMatrix.clone(), a = this.eyeSep / 2, o = a * zr / Nr, s = zr * Math.tan(t.Math.DEG2RAD * Fr * .5); Hr.elements[12] = -a, Gr.elements[12] = a, i = -s * Or + o, n = s * Or + o, r.elements[0] = 2 * zr / (n - i), r.elements[8] = (n + i) / (n - i), this.cameraL.projectionMatrix.copy(r), i = -s * Or - o, n = s * Or - o, r.elements[0] = 2 * zr / (n - i), r.elements[8] = (n + i) / (n - i), this.cameraR.projectionMatrix.copy(r) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Hr), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Gr) }) }), ta.prototype = Object.create(Si.prototype), ta.prototype.constructor = ta, ea.prototype = Object.assign(Object.create(Si.prototype), { constructor: ea, getInput: function () { return this.gain }, removeFilter: function () { null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null) }, getFilter: function () { return this.filter }, setFilter: function (t) { null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination) }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { this.gain.gain.value = t }, updateMatrixWorld: function () { var t = new kt, e = new Vt, i = new kt, n = new kt; return function (r) { Si.prototype.updateMatrixWorld.call(this, r); var a = this.context.listener, o = this.up; this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z) } }() }), ia.prototype = Object.assign(Object.create(Si.prototype), { constructor: ia, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setBuffer: function (t) { return this.source.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function () { if (!0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { var t = this.context.createBufferSource(); return t.buffer = this.source.buffer, t.loop = this.source.loop, t.onended = this.source.onended, t.start(0, this.startTime), t.playbackRate.value = this.playbackRate, this.isPlaying = !0, this.source = t, this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") }, pause: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop }, setLoop: function (t) { !1 !== this.hasPlaybackControl ? this.source.loop = t : console.warn("THREE.Audio: this Audio has no playback control.") }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.value = t, this } }), na.prototype = Object.assign(Object.create(ia.prototype), { constructor: na, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { this.panner.refDistance = t }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { this.panner.rolloffFactor = t }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { this.panner.distanceModel = t }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { this.panner.maxDistance = t }, updateMatrixWorld: function () { var t = new kt; return function (e) { Si.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z) } }() }), Object.assign(ra.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)t += e[i]; return t / e.length } }), aa.prototype = { constructor: aa, accumulate: function (t, e) { var i = this.buffer, n = this.valueSize, r = t * n + n, a = this.cumulativeWeight; if (0 === a) { for (var o = 0; o !== n; ++o)i[r + o] = i[o]; a = e } else { var s = e / (a += e); this._mixBufferRegion(i, r, 0, s, n) } this.cumulativeWeight = a }, apply: function (t) { var e = this.valueSize, i = this.buffer, n = t * e + e, r = this.cumulativeWeight, a = this.binding; if (this.cumulativeWeight = 0, r < 1) { var o = 3 * e; this._mixBufferRegion(i, n, o, 1 - r, e) } for (var s = e, c = e + e; s !== c; ++s)if (i[s] !== i[s + e]) { a.setValue(i, n); break } }, saveOriginalState: function () { var t = this.binding, e = this.buffer, i = this.valueSize, n = 3 * i; t.getValue(e, n); for (var r = i, a = n; r !== a; ++r)e[r] = e[n + r % i]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { var t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _select: function (t, e, i, n, r) { if (n >= .5) for (var a = 0; a !== r; ++a)t[e + a] = t[i + a] }, _slerp: function (t, e, i, n, r) { Vt.slerpFlat(t, e, t, e, t, i, n) }, _lerp: function (t, e, i, n, r) { for (var a = 1 - n, o = 0; o !== r; ++o) { var s = e + o; t[s] = t[s] * a + t[i + o] * n } } }, oa.prototype = { constructor: oa, getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, r = e.propertyIndex; if (t || (t = oa.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) { if (i) { var a = e.objectIndex; switch (i) { case "materials": if (!t.material) return void console.error("  can not bind to material as node does not have a material", this); if (!t.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this); t = t.skeleton.bones; for (var o = 0; o < t.length; o++)if (t[o].name === a) { a = o; break } break; default: if (void 0 === t[i]) return void console.error("  can not bind to objectName of node, undefined", this); t = t[i] }if (void 0 !== a) { if (void 0 === t[a]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t); t = t[a] } } var s = t[n]; if (void 0 !== s) { var c = this.Versioning.None; void 0 !== t.needsUpdate ? (c = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t); var h = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === n) { if (!t.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this); if (!t.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this); for (o = 0; o < this.node.geometry.morphTargets.length; o++)if (t.geometry.morphTargets[o].name === r) { r = o; break } } h = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = s) : void 0 !== s.length ? (h = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n; this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c] } else { var l = e.nodeName; console.error("  trying to update property for track: " + l + "." + n + " but it wasn't found.", t) } } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }, Object.assign(oa.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, _getValue_unbound: oa.prototype.getValue, _setValue_unbound: oa.prototype.setValue, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)t[e++] = i[n] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.node[this.propertyName] = t[e] }, function (t, e) { this.node[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.node[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++] }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]] }), oa.Composite = function (t, e, i) { var n = i || oa.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, n) }, oa.Composite.prototype = { constructor: oa.Composite, getValue: function (t, e) { this.bind(); var i = this._targetGroup.nCachedObjects_, n = this._bindings[i]; void 0 !== n && n.getValue(t, e) }, setValue: function (t, e) { for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)i[n].setValue(t, e) }, bind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)t[e].bind() }, unbind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)t[e].unbind() } }, oa.create = function (t, e, i) { return t && t.isAnimationObjectGroup ? new oa.Composite(t, e, i) : new oa(t, e, i) }, oa.parseTrackName = function (t) { var e = /^((?:\w+\/)*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/.exec(t); if (!e) throw new Error("cannot parse trackName at all: " + t); var i = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }; if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("can not parse propertyName from trackName: " + t); return i }, oa.findNode = function (t, e) { if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { var i = function (t) { for (var i = 0; i < t.bones.length; i++) { var n = t.bones[i]; if (n.name === e) return n } return null }(t.skeleton); if (i) return i } if (t.children) { var n = function (t) { for (var i = 0; i < t.length; i++) { var r = t[i]; if (r.name === e || r.uuid === e) return r; var a = n(r.children); if (a) return a } return null }, r = n(t.children); if (r) return r } return null }, sa.prototype = { constructor: sa, isAnimationObjectGroup: !0, add: function (t) { for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, c = s.length, h = 0, l = arguments.length; h !== l; ++h) { var u = arguments[h], p = u.uuid, d = r[p]; if (void 0 === d) { d = i++, r[p] = d, e.push(u); for (var f = 0, m = c; f !== m; ++f)s[f].push(new oa(u, a[f], o[f])) } else if (d < n) { var g = e[d], v = --n, y = e[v]; r[y.uuid] = d, e[d] = y, r[p] = v, e[v] = u; for (f = 0, m = c; f !== m; ++f) { var x = s[f], _ = x[v], w = x[d]; x[d] = _, void 0 === w && (w = new oa(u, a[f], o[f])), x[v] = w } } else e[d] !== g && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...") } this.nCachedObjects_ = n }, remove: function (t) { for (var e = this._objects, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) { var c = arguments[o], h = c.uuid, l = n[h]; if (void 0 !== l && l >= i) { var u = i++, p = e[u]; n[p.uuid] = l, e[l] = p, n[h] = u, e[u] = c; for (var d = 0, f = a; d !== f; ++d) { var m = r[d], g = m[u], v = m[l]; m[l] = g, m[u] = v } } } this.nCachedObjects_ = i }, uncache: function (t) { for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, a = this._bindings, o = a.length, s = 0, c = arguments.length; s !== c; ++s) { var h = arguments[s].uuid, l = r[h]; if (void 0 !== l) if (delete r[h], l < n) { var u = --n, p = e[u], d = e[y = --i]; r[p.uuid] = l, e[l] = p, r[d.uuid] = u, e[u] = d, e.pop(); for (var f = 0, m = o; f !== m; ++f) { var g = (x = a[f])[u], v = x[y]; x[l] = g, x[u] = v, x.pop() } } else { var y; r[(d = e[y = --i]).uuid] = l, e[l] = d, e.pop(); for (f = 0, m = o; f !== m; ++f) { var x; (x = a[f])[l] = x[y], x.pop() } } } this.nCachedObjects_ = n }, subscribe_: function (t, e) { var i = this._bindingsIndicesByPath, n = i[t], r = this._bindings; if (void 0 !== n) return r[n]; var a = this._paths, o = this._parsedPaths, s = this._objects, c = s.length, h = this.nCachedObjects_, l = new Array(c); n = r.length, i[t] = n, a.push(t), o.push(e), r.push(l); for (var u = h, p = s.length; u !== p; ++u) { var d = s[u]; l[u] = new oa(d, t, e) } return l }, unsubscribe_: function (t) { var e = this._bindingsIndicesByPath, i = e[t]; if (void 0 !== i) { var n = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o]; e[t[o]] = i, a[i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop() } } }, ca.prototype = { constructor: ca, play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, i) { if (t.fadeOut(e), this.fadeIn(e), i) { var n = this._clip.duration, r = t._clip.duration, a = r / n, o = n / r; t.warp(1, a, e), this.warp(o, 1, e) } return this }, crossFadeTo: function (t, e, i) { return t.crossFadeFrom(this, e, i) }, stopFading: function () { var t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, i) { var n = this._mixer, r = n.time, a = this._timeScaleInterpolant, o = this.timeScale; null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a); var s = a.parameterPositions, c = a.sampleValues; return s[0] = r, s[1] = r + i, c[0] = t / o, c[1] = e / o, this }, stopWarping: function () { var t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, i, n) { var r = this._startTime; if (null !== r) { var a = (t - r) * i; if (a < 0 || 0 === i) return; this._startTime = null, e = i * a } e *= this._updateTimeScale(t); var o = this._updateTime(e), s = this._updateWeight(t); if (s > 0) for (var c = this._interpolants, h = this._propertyBindings, l = 0, u = c.length; l !== u; ++l)c[l].evaluate(o), h[l].accumulate(n, s) }, _updateWeight: function (t) { var e = 0; if (this.enabled) { e = this.weight; var i = this._weightInterpolant; if (null !== i) { var n = i.evaluate(t)[0]; e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = e, e }, _updateTimeScale: function (t) { var e = 0; if (!this.paused) { e = this.timeScale; var i = this._timeScaleInterpolant; if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } return this._effectiveTimeScale = e, e }, _updateTime: function (t) { var e = this.time + t; if (0 === t) return e; var i = this._clip.duration, n = this.loop, r = this._loopCount; if (2200 === n) { -1 === r && (this.loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (e >= i) e = i; else { if (!(e < 0)) break t; e = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { var a = 2202 === n; if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= i || e < 0) { var o = Math.floor(e / i); e -= i * o, r += Math.abs(o); var s = this.repetitions - r; if (s < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (0 === s) { var c = t < 0; this._setEndings(c, !c, a) } else this._setEndings(!1, !1, a); this._loopCount = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o }) } } if (a && 1 == (1 & r)) return this.time = e, i - e } return this.time = e, e }, _setEndings: function (t, e, i) { var n = this._interpolantSettings; i ? (n.endingStart = yt, n.endingEnd = yt) : (n.endingStart = t ? this.zeroSlopeAtStart ? yt : vt : xt, n.endingEnd = e ? this.zeroSlopeAtEnd ? yt : vt : xt) }, _scheduleFading: function (t, e, i) { var n = this._mixer, r = n.time, a = this._weightInterpolant; null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a); var o = a.parameterPositions, s = a.sampleValues; return o[0] = r, s[0] = e, o[1] = r + t, s[1] = i, this } }, Object.assign(ha.prototype, e.prototype, { clipAction: function (t, e) { var i = e || this._root, n = i.uuid, r = "string" == typeof t ? wr.findByName(i, t) : t, a = null !== r ? r.uuid : t, o = this._actionsByClip[a], s = null; if (void 0 !== o) { var c = o.actionByRoot[n]; if (void 0 !== c) return c; s = o.knownActions[0], null === r && (r = s._clip) } if (null === r) return null; var h = new ca(this, r, e); return this._bindAction(h, s), this._addInactiveAction(h, a, n), h }, existingAction: function (t, e) { var i = e || this._root, n = i.uuid, r = "string" == typeof t ? wr.findByName(i, t) : t, a = r ? r.uuid : t, o = this._actionsByClip[a]; return void 0 !== o && o.actionByRoot[n] || null }, stopAllAction: function () { var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings; this._nActiveActions = 0, this._nActiveBindings = 0; for (var r = 0; r !== e; ++r)t[r].reset(); for (r = 0; r !== n; ++r)i[r].useCount = 0; return this }, update: function (t) { t *= this.timeScale; for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) { var s = e[o]; s.enabled && s._update(n, t, r, a) } var c = this._bindings, h = this._nActiveBindings; for (o = 0; o !== h; ++o)c[o].apply(a); return this }, getRoot: function () { return this._root }, uncacheClip: function (t) { var e = this._actions, i = t.uuid, n = this._actionsByClip, r = n[i]; if (void 0 !== r) { for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) { var c = a[o]; this._deactivateAction(c); var h = c._cacheIndex, l = e[e.length - 1]; c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = h, e[h] = l, e.pop(), this._removeInactiveBindingsForAction(c) } delete n[i] } }, uncacheRoot: function (t) { var e = t.uuid, i = this._actionsByClip; for (var n in i) { var r = i[n].actionByRoot[e]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } var a = this._bindingsByRootAndName[e]; if (void 0 !== a) for (var o in a) { var s = a[o]; s.restoreOriginalState(), this._removeInactiveBinding(s) } }, uncacheAction: function (t, e) { var i = this.existingAction(t, e); null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } }), Object.assign(ha.prototype, { _bindAction: function (t, e) { var i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, a = t._propertyBindings, o = t._interpolants, s = i.uuid, c = this._bindingsByRootAndName, h = c[s]; void 0 === h && (h = {}, c[s] = h); for (var l = 0; l !== r; ++l) { var u = n[l], p = u.name, d = h[p]; if (void 0 !== d) a[l] = d; else { if (void 0 !== (d = a[l])) { null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p)); continue } var f = e && e._propertyBindings[l].binding.parsedPath; ++(d = new aa(oa.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), a[l] = d } o[l].resultBuffer = d.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i]; this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e) } for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) { var s = r[a]; 0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) { var r = e[i]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { var e = t._cacheIndex; return null !== e && e < this._nActiveActions }, _addInactiveAction: function (t, e, i) { var n = this._actions, r = this._actionsByClip, a = r[e]; if (void 0 === a) a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = a; else { var o = a.knownActions; t._byClipCacheIndex = o.length, o.push(t) } t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t }, _removeInactiveAction: function (t) { var e = this._actions, i = e[e.length - 1], n = t._cacheIndex; i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null; var r = t._clip.uuid, a = this._actionsByClip, o = a[r], s = o.knownActions, c = s[s.length - 1], h = t._byClipCacheIndex; c._byClipCacheIndex = h, s[h] = c, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) { var r = e[i]; 0 == --r.referenceCount && this._removeInactiveBinding(r) } }, _lendAction: function (t) { var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _takeBackAction: function (t) { var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _addInactiveBinding: function (t, e, i) { var n = this._bindingsByRootAndName, r = n[e], a = this._bindings; void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = a.length, a.push(t) }, _removeInactiveBinding: function (t) { var e = this._bindings, i = t.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, o = a[n], s = e[e.length - 1], c = t._cacheIndex; s._cacheIndex = c, e[c] = s, e.pop(), delete o[r]; t: { for (var h in o) break t; delete a[n] } }, _lendBinding: function (t) { var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _takeBackBinding: function (t) { var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _lendControlInterpolant: function () { var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e]; return void 0 === i && ((i = new lr(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i }, _takeBackControlInterpolant: function (t) { var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n]; t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r }, _controlInterpolantsResultBuffer: new Float32Array(1) }), la.prototype = { constructor: la, onUpdate: function (t) { return this.dynamic = !0, this.onUpdateCallback = t, this } }, ua.prototype = Object.create(ki.prototype), ua.prototype.constructor = ua, ua.prototype.isInstancedBufferGeometry = !0, ua.prototype.addGroup = function (t, e, i) { this.groups.push({ start: t, count: e, instances: i }) }, ua.prototype.copy = function (t) { var e = t.index; null !== e && this.setIndex(e.clone()); var i = t.attributes; for (var n in i) { var r = i[n]; this.addAttribute(n, r.clone()) } for (var a = t.groups, o = 0, s = a.length; o < s; o++) { var c = a[o]; this.addGroup(c.start, c.count, c.instances) } return this }, pa.prototype = { constructor: pa, isInterleavedBufferAttribute: !0, get length() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length }, get count() { return this.data.count }, get array() { return this.data.array }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this }, setXYZ: function (t, e, i, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this }, setXYZW: function (t, e, i, n, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this } }, da.prototype = { constructor: da, isInterleavedBuffer: !0, get length() { return this.array.length }, get count() { return this.array.length / this.stride }, set needsUpdate(t) { !0 === t && this.version++ }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.stride = t.stride, this.dynamic = t.dynamic, this }, copyAt: function (t, e, i) { t *= this.stride, i *= e.stride; for (var n = 0, r = this.stride; n < r; n++)this.array[t + n] = e.array[i + n]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function () { return (new this.constructor).copy(this) } }, fa.prototype = Object.create(da.prototype), fa.prototype.constructor = fa, fa.prototype.isInstancedInterleavedBuffer = !0, fa.prototype.copy = function (t) { return da.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, ma.prototype = Object.create(xi.prototype), ma.prototype.constructor = ma, ma.prototype.isInstancedBufferAttribute = !0, ma.prototype.copy = function (t) { return xi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, ga.prototype = { constructor: ga, linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e) { var i = []; return ya(t, this, i, e), i.sort(va), i }, intersectObjects: function (t, e) { var i = []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (var n = 0, r = t.length; n < r; n++)ya(t[n], this, i, e); return i.sort(va), i } }, xa.prototype = { constructor: xa, start: function () { this.startTime = (performance || Date).now(), this.oldTime = this.startTime, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t = 0; if (this.autoStart && !this.running && this.start(), this.running) { var e = (performance || Date).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }, _a.prototype = { constructor: _a, set: function (t, e, i) { return this.radius = t, this.phi = e, this.theta = i, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius.copy(t.radius), this.phi.copy(t.phi), this.theta.copy(t.theta), this }, makeSafe: function () { var t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this }, setFromVector3: function (e) { return this.radius = e.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(t.Math.clamp(e.y / this.radius, -1, 1))), this } }, wa.prototype = Object.create(an.prototype), wa.prototype.constructor = wa, wa.prototype.createAnimation = function (t, e, i, n) { var r = { start: e, end: i, length: i - e + 1, fps: n, duration: (i - e) / n, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 }; this.animationsMap[t] = r, this.animationsList.push(r) }, wa.prototype.autoCreateAnimations = function (t) { for (var e, i = /([a-z]+)_?(\d+)/i, n = {}, r = this.geometry, a = 0, o = r.morphTargets.length; a < o; a++) { var s = r.morphTargets[a].name.match(i); if (s && s.length > 1) n[c = s[1]] || (n[c] = { start: 1 / 0, end: -1 / 0 }), a < (h = n[c]).start && (h.start = a), a > h.end && (h.end = a), e || (e = c) } for (var c in n) { var h = n[c]; this.createAnimation(c, h.start, h.end, t) } this.firstAnimation = e }, wa.prototype.setAnimationDirectionForward = function (t) { var e = this.animationsMap[t]; e && (e.direction = 1, e.directionBackwards = !1) }, wa.prototype.setAnimationDirectionBackward = function (t) { var e = this.animationsMap[t]; e && (e.direction = -1, e.directionBackwards = !0) }, wa.prototype.setAnimationFPS = function (t, e) { var i = this.animationsMap[t]; i && (i.fps = e, i.duration = (i.end - i.start) / i.fps) }, wa.prototype.setAnimationDuration = function (t, e) { var i = this.animationsMap[t]; i && (i.duration = e, i.fps = (i.end - i.start) / i.duration) }, wa.prototype.setAnimationWeight = function (t, e) { var i = this.animationsMap[t]; i && (i.weight = e) }, wa.prototype.setAnimationTime = function (t, e) { var i = this.animationsMap[t]; i && (i.time = e) }, wa.prototype.getAnimationTime = function (t) { var e = 0, i = this.animationsMap[t]; return i && (e = i.time), e }, wa.prototype.getAnimationDuration = function (t) { var e = -1, i = this.animationsMap[t]; return i && (e = i.duration), e }, wa.prototype.playAnimation = function (t) { var e = this.animationsMap[t]; e ? (e.time = 0, e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()") }, wa.prototype.stopAnimation = function (t) { var e = this.animationsMap[t]; e && (e.active = !1) }, wa.prototype.update = function (e) { for (var i = 0, n = this.animationsList.length; i < n; i++) { var r = this.animationsList[i]; if (r.active) { var a = r.duration / r.length; r.time += r.direction * e, r.mirroredLoop ? (r.time > r.duration || r.time < 0) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), r.time < 0 && (r.time = 0, r.directionBackwards = !1)) : (r.time = r.time % r.duration, r.time < 0 && (r.time += r.duration)); var o = r.start + t.Math.clamp(Math.floor(r.time / a), 0, r.length - 1), s = r.weight; o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * s, this.morphTargetInfluences[o] = 0, r.lastFrame = r.currentFrame, r.currentFrame = o); var c = r.time % a / a; r.directionBackwards && (c = 1 - c), r.currentFrame !== r.lastFrame ? (this.morphTargetInfluences[r.currentFrame] = c * s, this.morphTargetInfluences[r.lastFrame] = (1 - c) * s) : this.morphTargetInfluences[r.currentFrame] = s } } }, ba.prototype = Object.create(Si.prototype), ba.prototype.constructor = ba, ba.prototype.isImmediateRenderObject = !0, Ma.prototype = Object.create(ki.prototype), Ma.prototype.constructor = Ma, Ea.prototype = Object.create(En.prototype), Ea.prototype.constructor = Ea, Ta.prototype = Object.create(En.prototype), Ta.prototype.constructor = Ta, Ta.prototype.update = function () { var t = new kt, e = new kt, i = new Ke; return function () { var n = ["a", "b", "c"]; this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); var r = this.object.matrixWorld, a = this.geometry.attributes.position, o = this.object.geometry; if (o && o.isGeometry) for (var s = o.vertices, c = o.faces, h = 0, l = 0, u = c.length; l < u; l++)for (var p = c[l], d = 0, f = p.vertexNormals.length; d < f; d++) { var m = s[p[n[d]]], g = p.vertexNormals[d]; t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(h, t.x, t.y, t.z), h += 1, a.setXYZ(h, e.x, e.y, e.z), h += 1 } else if (o && o.isBufferGeometry) { var v = o.attributes.position, y = o.attributes.normal; for (h = 0, d = 0, f = v.count; d < f; d++)t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(r), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(h, t.x, t.y, t.z), h += 1, a.setXYZ(h, e.x, e.y, e.z), h += 1 } return a.needsUpdate = !0, this } }(), Sa.prototype = Object.create(Si.prototype), Sa.prototype.constructor = Sa, Sa.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, Sa.prototype.update = function () { var t = new kt, e = new kt; return function () { var i = this.light.distance ? this.light.distance : 1e3, n = i * Math.tan(this.light.angle); this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) } }(), Aa.prototype = Object.create(En.prototype), Aa.prototype.constructor = Aa, Aa.prototype.getBoneList = function (t) { var e = []; t && t.isBone && e.push(t); for (var i = 0; i < t.children.length; i++)e.push.apply(e, this.getBoneList(t.children[i])); return e }, Aa.prototype.update = function () { for (var t = this.geometry, e = (new Ht).getInverse(this.root.matrixWorld), i = new Ht, n = 0, r = 0; r < this.bones.length; r++) { var a = this.bones[r]; a.parent && a.parent.isBone && (i.multiplyMatrices(e, a.matrixWorld), t.vertices[n].setFromMatrixPosition(i), i.multiplyMatrices(e, a.parent.matrixWorld), t.vertices[n + 1].setFromMatrixPosition(i), n += 2) } t.verticesNeedUpdate = !0, t.computeBoundingSphere() }, La.prototype = Object.create(ki.prototype), La.prototype.constructor = La, Ra.prototype = Object.create(an.prototype), Ra.prototype.constructor = Ra, Ra.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Ra.prototype.update = function () { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) }, Pa.prototype = Object.create(Pi.prototype), Pa.prototype.constructor = Pa, Ca.prototype = Object.create(Si.prototype), Ca.prototype.constructor = Ca, Ca.prototype.dispose = function () { this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose() }, Ca.prototype.update = function () { var t = new kt; return function () { this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0 } }(), Ua.prototype = Object.create(En.prototype), Ua.prototype.constructor = Ua, Ua.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Ia.prototype = Object.create(En.prototype), Ia.prototype.constructor = Ia, Ia.prototype.update = function () { var t = new kt, e = new kt, i = new Ke; return function () { this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, c = 0, h = 0, l = s.length; h < l; h++) { var u = s[h], p = u.normal; t.copy(o[u.a]).add(o[u.b]).add(o[u.c]).divideScalar(3).applyMatrix4(n), e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1 } return r.needsUpdate = !0, this } }(), Da.prototype = Object.create(ki.prototype), Da.prototype.constructor = Da, Na.prototype = Object.create(En.prototype), Na.prototype.constructor = Na, Fa.prototype = Object.create(Si.prototype), Fa.prototype.constructor = Fa, Fa.prototype.dispose = function () { var t = this.children[0], e = this.children[1]; t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose() }, Fa.prototype.update = function () { var t = new kt, e = new kt, i = new kt; return function () { t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t); var n = this.children[0], r = this.children[1]; n.lookAt(i), n.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), r.lookAt(i), r.scale.z = i.length() } }(), Oa.prototype = Object.create(En.prototype), Oa.prototype.constructor = Oa, Oa.prototype.update = function () { var t, e, i = new kt, n = new sn; function r(r, a, o, s) { i.set(a, o, s).unproject(n); var c = e[r]; if (void 0 !== c) for (var h = 0, l = c.length; h < l; h++)t.vertices[c[h]].copy(i) } return function () { t = this.geometry, e = this.pointMap; n.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.verticesNeedUpdate = !0 } }(), za.prototype = Object.create(Pi.prototype), za.prototype.constructor = za, Ba.prototype = Object.create(an.prototype), Ba.prototype.constructor = Ba, Ba.prototype.update = function () { this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position) }, Ga.prototype = Object.create(En.prototype), Ga.prototype.constructor = Ga, Ga.prototype.update = function () { var t = new Je; return function (e) { if (e && e.isBox3 ? t.copy(e) : t.setFromObject(e), !t.isEmpty()) { var i = t.min, n = t.max, r = this.geometry.attributes.position, a = r.array; a[0] = n.x, a[1] = n.y, a[2] = n.z, a[3] = i.x, a[4] = n.y, a[5] = n.z, a[6] = i.x, a[7] = i.y, a[8] = n.z, a[9] = n.x, a[10] = i.y, a[11] = n.z, a[12] = n.x, a[13] = n.y, a[14] = i.z, a[15] = i.x, a[16] = n.y, a[17] = i.z, a[18] = i.x, a[19] = i.y, a[20] = i.z, a[21] = n.x, a[22] = i.y, a[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } } }(), Ha.prototype = Object.create(ki.prototype), Ha.prototype.constructor = Ha; var Va = new ki; Va.addAttribute("position", new bi([0, 0, 0, 0, 1, 0], 3)); var ka, ja, Wa = new Ha(0, .5, 1, 5, 1); function Xa(t, e, i, n, r, a) { Si.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), this.position.copy(e), this.line = new Mn(Va, new bn({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new an(Wa, new rn({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, a) } function Ya(t) { t = t || 1; var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]), i = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]), n = new ki; n.addAttribute("position", new xi(e, 3)), n.addAttribute("color", new xi(i, 3)); var r = new bn({ vertexColors: 2 }); En.call(this, n, r) } function qa(t, e, i) { Pi.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }; var n, r, a, o, s, c, h, l, u, p, d, f, m = this.vertices, g = this.faces, v = this.faceVertexUvs[0], y = e + 1; for (n = 0; n <= i; n++)for (o = n / i, r = 0; r <= e; r++)a = t(r / e, o), m.push(a); for (n = 0; n < i; n++)for (r = 0; r < e; r++)s = n * y + r, c = n * y + r + 1, h = (n + 1) * y + r + 1, l = (n + 1) * y + r, u = new Pt(r / e, n / i), p = new Pt((r + 1) / e, n / i), d = new Pt((r + 1) / e, (n + 1) / i), f = new Pt(r / e, (n + 1) / i), g.push(new Mi(s, c, l)), v.push([u, p, f]), g.push(new Mi(c, h, l)), v.push([p.clone(), d, f.clone()]); this.computeFaceNormals(), this.computeVertexNormals() } function Za(t, e, i, n) { Pi.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, i = i || 1, n = n || 0; for (var r = this, a = 0, o = t.length; a < o; a += 3)_(new kt(t[a], t[a + 1], t[a + 2])); var s = this.vertices, c = [], h = (a = 0, 0); for (o = e.length; a < o; a += 3, h++) { var l = s[e[a]], u = s[e[a + 1]], p = s[e[a + 2]]; c[h] = new Mi(l.index, u.index, p.index, [l.clone(), u.clone(), p.clone()]) } var d = new kt; for (a = 0, o = c.length; a < o; a++)b(c[a], n); for (a = 0, o = this.faceVertexUvs[0].length; a < o; a++) { var f = this.faceVertexUvs[0][a], m = f[0].x, g = f[1].x, v = f[2].x, y = Math.max(m, g, v), x = Math.min(m, g, v); y > .9 && x < .1 && (m < .2 && (f[0].x += 1), g < .2 && (f[1].x += 1), v < .2 && (f[2].x += 1)) } for (a = 0, o = this.vertices.length; a < o; a++)this.vertices[a].multiplyScalar(i); function _(t) { var e = t.normalize().clone(); e.index = r.vertices.push(e) - 1; var i = M(t) / 2 / Math.PI + .5, n = function (t) { return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) }(t) / Math.PI + .5; return e.uv = new Pt(i, 1 - n), e } function w(t, e, i) { var n = new Mi(t.index, e.index, i.index, [t.clone(), e.clone(), i.clone()]); r.faces.push(n), d.copy(t).add(e).add(i).divideScalar(3); var a = M(d); r.faceVertexUvs[0].push([E(t.uv, t, a), E(e.uv, e, a), E(i.uv, i, a)]) } function b(t, e) { for (var i = Math.pow(2, e), n = _(r.vertices[t.a]), a = _(r.vertices[t.b]), o = _(r.vertices[t.c]), s = [], c = 0; c <= i; c++) { s[c] = []; for (var h = _(n.clone().lerp(o, c / i)), l = _(a.clone().lerp(o, c / i)), u = i - c, p = 0; p <= u; p++)s[c][p] = 0 === p && c === i ? h : _(h.clone().lerp(l, p / u)) } for (c = 0; c < i; c++)for (p = 0; p < 2 * (i - c) - 1; p++) { var d = Math.floor(p / 2); p % 2 == 0 ? w(s[c][d + 1], s[c + 1][d], s[c][d]) : w(s[c][d + 1], s[c + 1][d + 1], s[c + 1][d]) } } function M(t) { return Math.atan2(t.z, -t.x) } function E(t, e, i) { return i < 0 && 1 === t.x && (t = new Pt(t.x - 1, t.y)), 0 === e.x && 0 === e.z && (t = new Pt(i / 2 / Math.PI + .5, t.y)), t.clone() } this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new Qe(new kt, i) } function Ja(t, e) { Za.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e } } function Qa(t, e) { Za.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e } } function Ka(t, e) { var i = (1 + Math.sqrt(5)) / 2, n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]; Za.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e } } function $a(t, e) { var i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n]; Za.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e } } function to(t, e, i, n, r, a) { ki.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: r, q: a }, t = t || 100, e = e || 40, i = Math.floor(i) || 64, r = r || 2, a = a || 3; var o, s, c = ((n = Math.floor(n) || 8) + 1) * (i + 1), h = n * i * 2 * 3, l = new xi(new (h > 65535 ? Uint32Array : Uint16Array)(h), 1), u = new xi(new Float32Array(3 * c), 3), p = new xi(new Float32Array(3 * c), 3), d = new xi(new Float32Array(2 * c), 2), f = 0, m = 0, g = new kt, v = new kt, y = new Pt, x = new kt, _ = new kt, w = new kt, b = new kt, M = new kt; for (o = 0; o <= i; ++o) { var E = o / i * r * Math.PI * 2; for (U(E, r, a, t, x), U(E + .01, r, a, t, _), b.subVectors(_, x), M.addVectors(_, x), w.crossVectors(b, M), M.crossVectors(w, b), w.normalize(), M.normalize(), s = 0; s <= n; ++s) { var T = s / n * Math.PI * 2, S = -e * Math.cos(T), A = e * Math.sin(T); g.x = x.x + (S * M.x + A * w.x), g.y = x.y + (S * M.y + A * w.y), g.z = x.z + (S * M.z + A * w.z), u.setXYZ(f, g.x, g.y, g.z), v.subVectors(g, x).normalize(), p.setXYZ(f, v.x, v.y, v.z), y.x = o / i, y.y = s / n, d.setXY(f, y.x, y.y), f++ } } for (s = 1; s <= i; s++)for (o = 1; o <= n; o++) { var L = (n + 1) * (s - 1) + (o - 1), R = (n + 1) * s + (o - 1), P = (n + 1) * s + o, C = (n + 1) * (s - 1) + o; l.setX(m, L), m++, l.setX(m, R), m++, l.setX(m, C), m++, l.setX(m, R), m++, l.setX(m, P), m++, l.setX(m, C), m++ } function U(t, e, i, n, r) { var a = Math.cos(t), o = Math.sin(t), s = i / e * t, c = Math.cos(s); r.x = n * (2 + c) * .5 * a, r.y = n * (2 + c) * o * .5, r.z = n * Math.sin(s) * .5 } this.setIndex(l), this.addAttribute("position", u), this.addAttribute("normal", p), this.addAttribute("uv", d) } function eo(t, e, i, n, r, a, o) { Pi.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: r, q: a }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new to(t, e, i, n, r, a)), this.mergeVertices() } function io(t, e, i, n, r) { ki.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: r }, t = t || 100, e = e || 40, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI; var a, o, s = (i + 1) * (n + 1), c = i * n * 2 * 3, h = new (c > 65535 ? Uint32Array : Uint16Array)(c), l = new Float32Array(3 * s), u = new Float32Array(3 * s), p = new Float32Array(2 * s), d = 0, f = 0, m = 0, g = new kt, v = new kt, y = new kt; for (a = 0; a <= i; a++)for (o = 0; o <= n; o++) { var x = o / n * r, _ = a / i * Math.PI * 2; v.x = (t + e * Math.cos(_)) * Math.cos(x), v.y = (t + e * Math.cos(_)) * Math.sin(x), v.z = e * Math.sin(_), l[d] = v.x, l[d + 1] = v.y, l[d + 2] = v.z, g.x = t * Math.cos(x), g.y = t * Math.sin(x), y.subVectors(v, g).normalize(), u[d] = y.x, u[d + 1] = y.y, u[d + 2] = y.z, p[f] = o / n, p[f + 1] = a / i, d += 3, f += 2 } for (a = 1; a <= i; a++)for (o = 1; o <= n; o++) { var w = (n + 1) * a + o - 1, b = (n + 1) * (a - 1) + o - 1, M = (n + 1) * (a - 1) + o, E = (n + 1) * a + o; h[m] = w, h[m + 1] = b, h[m + 2] = E, h[m + 3] = b, h[m + 4] = M, h[m + 5] = E, m += 6 } this.setIndex(new xi(h, 1)), this.addAttribute("position", new xi(l, 3)), this.addAttribute("normal", new xi(u, 3)), this.addAttribute("uv", new xi(p, 2)) } function no(t, e, i, n, r) { Pi.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: r }, this.fromBufferGeometry(new io(t, e, i, n, r)) } function ro(t, e) { var i = (e = e || {}).font; if (!1 === (i && i.isFont)) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Pi; var n = i.generateShapes(t, e.size, e.curveSegments); e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), jr.call(this, n, e), this.type = "TextGeometry" } function ao(t, e, i, n, r, a) { ki.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, t = t || 20, e = e || 50, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI; var o, s, c, h = ((i = void 0 !== i ? Math.max(3, i) : 8) + 1) * ((n = void 0 !== n ? Math.max(1, n) : 1) + 1), l = i * n * 2 * 3, u = new xi(new (l > 65535 ? Uint32Array : Uint16Array)(l), 1), p = new xi(new Float32Array(3 * h), 3), d = new xi(new Float32Array(3 * h), 3), f = new xi(new Float32Array(2 * h), 2), m = 0, g = 0, v = t, y = (e - t) / n, x = new kt, _ = new Pt; for (s = 0; s <= n; s++) { for (c = 0; c <= i; c++)o = r + c / i * a, x.x = v * Math.cos(o), x.y = v * Math.sin(o), p.setXYZ(m, x.x, x.y, x.z), d.setXYZ(m, 0, 0, 1), _.x = (x.x / e + 1) / 2, _.y = (x.y / e + 1) / 2, f.setXY(m, _.x, _.y), m++; v += y } for (s = 0; s < n; s++) { var w = s * (i + 1); for (c = 0; c < i; c++) { var b = o = c + w, M = o + i + 1, E = o + i + 2, T = o + 1; u.setX(g, b), g++, u.setX(g, M), g++, u.setX(g, E), g++, u.setX(g, b), g++, u.setX(g, E), g++, u.setX(g, T), g++ } } this.setIndex(u), this.addAttribute("position", p), this.addAttribute("normal", d), this.addAttribute("uv", f) } function oo(t, e, i, n, r, a) { Pi.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new ao(t, e, i, n, r, a)) } function so(t, e, i, n) { Pi.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }, this.fromBufferGeometry(new on(t, e, i, n)) } function co(e, i, n, r) { ki.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e, segments: i, phiStart: n, phiLength: r }, i = Math.floor(i) || 12, n = n || 0, r = r || 2 * Math.PI, r = t.Math.clamp(r, 0, 2 * Math.PI); var a, o, s, c = (i + 1) * e.length, h = i * e.length * 2 * 3, l = new xi(new (h > 65535 ? Uint32Array : Uint16Array)(h), 1), u = new xi(new Float32Array(3 * c), 3), p = new xi(new Float32Array(2 * c), 2), d = 0, f = 0, m = 1 / i, g = new kt, v = new Pt; for (o = 0; o <= i; o++) { var y = n + o * m * r, x = Math.sin(y), _ = Math.cos(y); for (s = 0; s <= e.length - 1; s++)g.x = e[s].x * x, g.y = e[s].y, g.z = e[s].x * _, u.setXYZ(d, g.x, g.y, g.z), v.x = o / i, v.y = s / (e.length - 1), p.setXY(d, v.x, v.y), d++ } for (o = 0; o < i; o++)for (s = 0; s < e.length - 1; s++) { var w = a = s + o * e.length, b = a + e.length, M = a + e.length + 1, E = a + 1; l.setX(f, w), f++, l.setX(f, b), f++, l.setX(f, E), f++, l.setX(f, b), f++, l.setX(f, M), f++, l.setX(f, E), f++ } if (this.setIndex(l), this.addAttribute("position", u), this.addAttribute("uv", p), this.computeVertexNormals(), r === 2 * Math.PI) { var T = this.attributes.normal.array, S = new kt, A = new kt, L = new kt; for (a = i * e.length * 3, o = 0, s = 0; o < e.length; o++, s += 3)S.x = T[s + 0], S.y = T[s + 1], S.z = T[s + 2], A.x = T[a + s + 0], A.y = T[a + s + 1], A.z = T[a + s + 2], L.addVectors(S, A).normalize(), T[s + 0] = T[a + s + 0] = L.x, T[s + 1] = T[a + s + 1] = L.y, T[s + 2] = T[a + s + 2] = L.z } } function ho(t, e, i, n) { Pi.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new co(t, e, i, n)), this.mergeVertices() } function lo(t, e, i, n, r, a, o, s) { Pi.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new Ha(t, e, i, n, r, a, o, s)), this.mergeVertices() } function uo(t, e, i, n, r, a, o) { lo.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: o } } function po(t, e, i, n, r, a, o) { Ha.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: i, heightSegments: n, thetaStart: a, thetaLength: o } } function fo(t, e, i, n) { ki.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI; var r = e + 2, a = new Float32Array(3 * r), o = new Float32Array(3 * r), s = new Float32Array(2 * r); o[2] = 1, s[0] = .5, s[1] = .5; for (var c = 0, h = 3, l = 2; c <= e; c++, h += 3, l += 2) { var u = i + c / e * n; a[h] = t * Math.cos(u), a[h + 1] = t * Math.sin(u), o[h + 2] = 1, s[l] = (a[h] / t + 1) / 2, s[l + 1] = (a[h + 1] / t + 1) / 2 } var p = []; for (h = 1; h <= e; h++)p.push(h, h + 1, 0); this.setIndex(new xi(new Uint16Array(p), 1)), this.addAttribute("position", new xi(a, 3)), this.addAttribute("normal", new xi(o, 3)), this.addAttribute("uv", new xi(s, 2)), this.boundingSphere = new Qe(new kt, t) } function mo(t, e, i, n) { Pi.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new fo(t, e, i, n)) } function go(e) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), t.CatmullRomCurve3.call(this, e), this.type = "catmullrom", this.closed = !0 } Wa.translate(0, -.5, 0), Xa.prototype = Object.create(Si.prototype), Xa.prototype.constructor = Xa, Xa.prototype.setDirection = (ja = new kt, function (t) { t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (ja.set(t.z, 0, -t.x).normalize(), ka = Math.acos(t.y), this.quaternion.setFromAxisAngle(ja, ka)) }), Xa.prototype.setLength = function (t, e, i) { void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix() }, Xa.prototype.setColor = function (t) { this.line.material.color.copy(t), this.cone.material.color.copy(t) }, Ya.prototype = Object.create(En.prototype), Ya.prototype.constructor = Ya, qa.prototype = Object.create(Pi.prototype), qa.prototype.constructor = qa, Za.prototype = Object.create(Pi.prototype), Za.prototype.constructor = Za, Ja.prototype = Object.create(Za.prototype), Ja.prototype.constructor = Ja, Qa.prototype = Object.create(Za.prototype), Qa.prototype.constructor = Qa, Ka.prototype = Object.create(Za.prototype), Ka.prototype.constructor = Ka, $a.prototype = Object.create(Za.prototype), $a.prototype.constructor = $a, to.prototype = Object.create(ki.prototype), to.prototype.constructor = to, eo.prototype = Object.create(Pi.prototype), eo.prototype.constructor = eo, io.prototype = Object.create(ki.prototype), io.prototype.constructor = io, no.prototype = Object.create(Pi.prototype), no.prototype.constructor = no, ro.prototype = Object.create(jr.prototype), ro.prototype.constructor = ro, ao.prototype = Object.create(ki.prototype), ao.prototype.constructor = ao, oo.prototype = Object.create(Pi.prototype), oo.prototype.constructor = oo, so.prototype = Object.create(Pi.prototype), so.prototype.constructor = so, co.prototype = Object.create(ki.prototype), co.prototype.constructor = co, ho.prototype = Object.create(Pi.prototype), ho.prototype.constructor = ho, lo.prototype = Object.create(Pi.prototype), lo.prototype.constructor = lo, uo.prototype = Object.create(lo.prototype), uo.prototype.constructor = uo, po.prototype = Object.create(ki.prototype), po.prototype.constructor = po, fo.prototype = Object.create(ki.prototype), fo.prototype.constructor = fo, mo.prototype = Object.create(Pi.prototype), mo.prototype.constructor = mo, t.CatmullRomCurve3 = function () { var t = new kt, e = new r, i = new r, n = new r; function r() { } return r.prototype.init = function (t, e, i, n) { this.c0 = t, this.c1 = i, this.c2 = -3 * t + 3 * e - 2 * i - n, this.c3 = 2 * t - 2 * e + i + n }, r.prototype.initNonuniformCatmullRom = function (t, e, i, n, r, a, o) { var s = (e - t) / r - (i - t) / (r + a) + (i - e) / a, c = (i - e) / a - (n - e) / (a + o) + (n - i) / o; s *= a, c *= a, this.init(e, i, s, c) }, r.prototype.initCatmullRom = function (t, e, i, n, r) { this.init(e, i, r * (i - t), r * (n - e)) }, r.prototype.calc = function (t) { var e = t * t, i = e * t; return this.c0 + this.c1 * t + this.c2 * e + this.c3 * i }, Ar.create((function (t) { this.points = t || [], this.closed = !1 }), (function (r) { var a, o, s, c, h, l, u, p, d = this.points; if ((c = d.length) < 2 && console.log("duh, you need at least 2 points"), s = (a = (c - (this.closed ? 0 : 1)) * r) - (o = Math.floor(a)), this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / d.length) + 1) * d.length : 0 === s && o === c - 1 && (o = c - 2, s = 1), this.closed || o > 0 ? h = d[(o - 1) % c] : (t.subVectors(d[0], d[1]).add(d[0]), h = t), l = d[o % c], u = d[(o + 1) % c], this.closed || o + 2 < c ? p = d[(o + 2) % c] : (t.subVectors(d[c - 1], d[c - 2]).add(d[c - 1]), p = t), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) { var f = "chordal" === this.type ? .5 : .25, m = Math.pow(h.distanceToSquared(l), f), g = Math.pow(l.distanceToSquared(u), f), v = Math.pow(u.distanceToSquared(p), f); g < 1e-4 && (g = 1), m < 1e-4 && (m = g), v < 1e-4 && (v = g), e.initNonuniformCatmullRom(h.x, l.x, u.x, p.x, m, g, v), i.initNonuniformCatmullRom(h.y, l.y, u.y, p.y, m, g, v), n.initNonuniformCatmullRom(h.z, l.z, u.z, p.z, m, g, v) } else if ("catmullrom" === this.type) { var y = void 0 !== this.tension ? this.tension : .5; e.initCatmullRom(h.x, l.x, u.x, p.x, y), i.initCatmullRom(h.y, l.y, u.y, p.y, y), n.initCatmullRom(h.z, l.z, u.z, p.z, y) } return new kt(e.calc(s), i.calc(s), n.calc(s)) })) }(), go.prototype = Object.create(t.CatmullRomCurve3.prototype); var vo = Ar.create((function (t) { console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 === t ? [] : t }), (function (e) { var i = this.points, n = (i.length - 1) * e, r = Math.floor(n), a = n - r, o = i[0 == r ? r : r - 1], s = i[r], c = i[r > i.length - 2 ? i.length - 1 : r + 1], h = i[r > i.length - 3 ? i.length - 1 : r + 2], l = t.CurveUtils.interpolate; return new kt(l(o.x, s.x, c.x, h.x, a), l(o.y, s.y, c.y, h.y, a), l(o.z, s.z, c.z, h.z, a)) })); function yo(t, e, i, n, r, a) { Pr.call(this, t, e, i, i, n, r, a) } t.CubicBezierCurve3 = Ar.create((function (t, e, i, n) { this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n }), (function (e) { var i = t.ShapeUtils.b3; return new kt(i(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), i(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), i(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z)) })), t.QuadraticBezierCurve3 = Ar.create((function (t, e, i) { this.v0 = t, this.v1 = e, this.v2 = i }), (function (e) { var i = t.ShapeUtils.b2; return new kt(i(e, this.v0.x, this.v1.x, this.v2.x), i(e, this.v0.y, this.v1.y, this.v2.y), i(e, this.v0.z, this.v1.z, this.v2.z)) })), t.LineCurve3 = Ar.create((function (t, e) { this.v1 = t, this.v2 = e }), (function (t) { if (1 === t) return this.v2.clone(); var e = new kt; return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e })), yo.prototype = Object.create(Pr.prototype), yo.prototype.constructor = yo, t.SceneUtils = { createMultiMaterialObject: function (t, e) { for (var i = new An, n = 0, r = e.length; n < r; n++)i.add(new an(t, e[n])); return i }, detach: function (t, e, i) { t.applyMatrix(e.matrixWorld), e.remove(t), i.add(t) }, attach: function (t, e, i) { var n = new Ht; n.getInverse(i.matrixWorld), t.applyMatrix(n), e.remove(t), i.add(t) } }; Object.assign(Wt.prototype, { empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) } }), Object.assign(Je.prototype, { empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(Ke.prototype, { multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t) } }), Object.assign(Ht.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), t.applyProjection(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t) }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function (t) { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function (t) { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function (t) { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function (t) { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function (t, e) { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") } }), Object.assign($e.prototype, { isIntersectionLine: function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) } }), Object.assign(Vt.prototype, { multiplyVector3: function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) } }), Object.assign(tn.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(kt.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) } }), Object.assign(Si.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function (t) { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) } }), Object.defineProperties(Si.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function (t) { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(vn.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), cn.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties($n.prototype, { onlyShadow: { set: function (t) { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function (t) { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function (t) { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(xi.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length } } }), Object.assign(ki.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addDrawCall: function (t, e, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(ki.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(Ne.prototype, { wrapAround: { get: function () { console.warn("THREE." + this.type + ": .wrapAround has been removed.") }, set: function (t) { console.warn("THREE." + this.type + ": .wrapAround has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new Ge } } }), Object.defineProperties(On.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function (t) { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(ze.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), e.prototype = Object.assign(Object.create({ constructor: e, apply: function (t) { console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."), Object.assign(t, this) } }), e.prototype), Object.assign(ln.prototype, { supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") } }), Object.defineProperties(ln.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { return this.shadowMap.cullFace }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t } } }), Object.defineProperties(ei.prototype, { cullFace: { get: function () { return this.renderReverseSided ? l : h }, set: function (t) { var e = t !== h; console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e } } }), Object.defineProperties(De.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.assign(ia.prototype, { load: function (t) { console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader."); var e = this; return (new Kr).load(t, (function (t) { e.setBuffer(t) })), this } }), Object.assign(ra.prototype, { getData: function (t) { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() } }); var xo = { merge: function (t, e, i) { var n; console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i) }, center: function (t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }, _o = { crossOrigin: void 0, loadTexture: function (t, e, i, n) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new Kn; r.setCrossOrigin(this.crossOrigin); var a = r.load(t, i, void 0, n); return e && (a.mapping = e), a }, loadTextureCube: function (t, e, i, n) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new Qn; r.setCrossOrigin(this.crossOrigin); var a = r.load(t, i, void 0, n); return e && (a.mapping = e), a }, loadCompressedTexture: function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, loadCompressedTextureCube: function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") } }; Object.defineProperty(t, "AudioContext", { get: function () { return t.getAudioContext() } }), t.SpritePlugin = jt, t.LensFlarePlugin = Xt, t.WebGLUniforms = Pe, t.WebGLTextures = Ce, t.WebGLState = Ie, t.WebGLShadowMap = ei, t.WebGLShader = ii, t.WebGLProperties = ni, t.WebGLPrograms = yi, t.WebGLProgram = vi, t.WebGLObjects = Wi, t.WebGLLights = Xi, t.WebGLGeometries = ji, t.WebGLCapabilities = Yi, t.WebGLExtensions = qi, t.WebGLIndexedBufferRenderer = Zi, t.WebGLClipping = Ji, t.WebGLBufferRenderer = Qi, t.WebGLRenderTargetCube = Ki, t.WebGLRenderTarget = De, t.WebGLRenderer = ln, t.ShaderLib = qe, t.UniformsLib = Ye, t.ShaderChunk = Be, t.FogExp2 = un, t.Fog = pn, t.Scene = dn, t.LensFlare = fn, t.Sprite = gn, t.LOD = vn, t.SkinnedMesh = wn, t.Skeleton = xn, t.Bone = _n, t.Mesh = an, t.LineSegments = En, t.Line = Mn, t.Points = Sn, t.Group = An, t.VideoTexture = Ln, t.DataTexture = yn, t.CompressedTexture = Rn, t.CubeTexture = Yt, t.CanvasTexture = Pn, t.DepthTexture = Cn, t.TextureIdCount = Gt, t.Texture = Ct, t.ShadowMaterial = Un, t.SpriteMaterial = mn, t.RawShaderMaterial = In, t.ShaderMaterial = ze, t.PointsMaterial = Tn, t.MultiMaterial = Dn, t.MeshPhysicalMaterial = Fn, t.MeshStandardMaterial = Nn, t.MeshPhongMaterial = On, t.MeshNormalMaterial = zn, t.MeshLambertMaterial = Bn, t.MeshDepthMaterial = Ze, t.MeshBasicMaterial = rn, t.LineDashedMaterial = Gn, t.LineBasicMaterial = bn, t.MaterialIdCount = Oe, t.Material = Ne, t.CompressedTextureLoader = kn, t.BinaryTextureLoader = Zn, t.DataTextureLoader = qn, t.CubeTextureLoader = Qn, t.TextureLoader = Kn, t.ObjectLoader = Sr, t.MaterialLoader = br, t.BufferGeometryLoader = Mr, t.LoadingManager = Hn, t.JSONLoader = Tr, t.ImageLoader = Jn, t.FontLoader = Jr, t.XHRLoader = Vn, t.Loader = Er, t.AudioLoader = Kr, t.SpotLightShadow = ir, t.SpotLight = nr, t.PointLight = rr, t.HemisphereLight = tr, t.DirectionalLightShadow = ar, t.DirectionalLight = or, t.AmbientLight = sr, t.LightShadow = er, t.Light = $n, t.StereoCamera = $r, t.PerspectiveCamera = cn, t.OrthographicCamera = hn, t.CubeCamera = ta, t.Camera = sn, t.AudioListener = ea, t.PositionalAudio = na, t.getAudioContext = Qr, t.AudioAnalyser = ra, t.Audio = ia, t.VectorKeyframeTrack = dr, t.StringKeyframeTrack = vr, t.QuaternionKeyframeTrack = mr, t.NumberKeyframeTrack = gr, t.ColorKeyframeTrack = xr, t.BooleanKeyframeTrack = yr, t.PropertyMixer = aa, t.PropertyBinding = oa, t.KeyframeTrack = _r, t.AnimationObjectGroup = sa, t.AnimationMixer = ha, t.AnimationClip = wr, t.Uniform = la, t.InstancedBufferGeometry = ua, t.BufferGeometry = ki, t.DirectGeometry = Vi, t.GeometryIdCount = Hi, t.Geometry = Pi, t.InterleavedBufferAttribute = pa, t.InstancedInterleavedBuffer = fa, t.InterleavedBuffer = da, t.InstancedBufferAttribute = ma, t.DynamicBufferAttribute = function (t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new xi(t, e).setDynamic(!0) }, t.Float64Attribute = function (t, e) { return new xi(new Float64Array(t), e) }, t.Float32Attribute = bi, t.Uint32Attribute = wi, t.Int32Attribute = function (t, e) { return new xi(new Int32Array(t), e) }, t.Uint16Attribute = _i, t.Int16Attribute = function (t, e) { return new xi(new Int16Array(t), e) }, t.Uint8ClampedAttribute = function (t, e) { return new xi(new Uint8ClampedArray(t), e) }, t.Uint8Attribute = function (t, e) { return new xi(new Uint8Array(t), e) }, t.Int8Attribute = function (t, e) { return new xi(new Int8Array(t), e) }, t.BufferAttribute = xi, t.Face3 = Mi, t.Object3DIdCount = Ri, t.Object3D = Si, t.Raycaster = ga, t.Layers = Ti, t.EventDispatcher = e, t.Clock = xa, t.QuaternionLinearInterpolant = fr, t.LinearInterpolant = lr, t.DiscreteInterpolant = ur, t.CubicInterpolant = hr, t.Interpolant = cr, t.Triangle = nn, t.Spline = function (t) { this.points = t; var e, i, n, r, a, o, s, c, h, l = [], u = { x: 0, y: 0, z: 0 }; function p(t, e, i, n, r, a, o) { var s = .5 * (i - t), c = .5 * (n - e); return (2 * (e - i) + s + c) * o + (-3 * (e - i) - 2 * s - c) * a + s * r + e } this.initFromArray = function (t) { this.points = []; for (var e = 0; e < t.length; e++)this.points[e] = { x: t[e][0], y: t[e][1], z: t[e][2] } }, this.getPoint = function (t) { return e = (this.points.length - 1) * t, i = Math.floor(e), n = e - i, l[0] = 0 === i ? i : i - 1, l[1] = i, l[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1, l[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2, o = this.points[l[0]], s = this.points[l[1]], c = this.points[l[2]], h = this.points[l[3]], a = n * (r = n * n), u.x = p(o.x, s.x, c.x, h.x, n, r, a), u.y = p(o.y, s.y, c.y, h.y, n, r, a), u.z = p(o.z, s.z, c.z, h.z, n, r, a), u }, this.getControlPointsArray = function () { var t, e, i = this.points.length, n = []; for (t = 0; t < i; t++)e = this.points[t], n[t] = [e.x, e.y, e.z]; return n }, this.getLength = function (t) { var e, i, n, r, a = 0, o = 0, s = 0, c = new kt, h = new kt, l = [], u = 0; for (l[0] = 0, t || (t = 100), n = this.points.length * t, c.copy(this.points[0]), e = 1; e < n; e++)i = e / n, r = this.getPoint(i), h.copy(r), u += h.distanceTo(c), c.copy(r), a = (this.points.length - 1) * i, (o = Math.floor(a)) !== s && (l[o] = u, s = o); return l[l.length] = u, { chunks: l, total: u } }, this.reparametrizeByArcLength = function (t) { var e, i, n, r, a, o, s, c, h = [], l = new kt, u = this.getLength(); for (h.push(l.copy(this.points[0]).clone()), e = 1; e < this.points.length; e++) { for (o = u.chunks[e] - u.chunks[e - 1], s = Math.ceil(t * o / u.total), r = (e - 1) / (this.points.length - 1), a = e / (this.points.length - 1), i = 1; i < s - 1; i++)n = r + i * (1 / s) * (a - r), c = this.getPoint(n), h.push(l.copy(c).clone()); h.push(l.copy(this.points[e]).clone()) } this.points = h } }, t.Spherical = _a, t.Plane = $e, t.Frustum = ti, t.Sphere = Qe, t.Ray = tn, t.Matrix4 = Ht, t.Matrix3 = Ke, t.Box3 = Je, t.Box2 = Wt, t.Line3 = en, t.Euler = Ei, t.Vector4 = Ue, t.Vector3 = kt, t.Vector2 = Pt, t.Quaternion = Vt, t.Color = Ge, t.MorphBlendMesh = wa, t.ImmediateRenderObject = ba, t.WireframeHelper = Ea, t.VertexNormalsHelper = Ta, t.SpotLightHelper = Sa, t.SkeletonHelper = Aa, t.PointLightHelper = Ra, t.HemisphereLightHelper = Ca, t.GridHelper = Ua, t.FaceNormalsHelper = Ia, t.EdgesHelper = Na, t.DirectionalLightHelper = Fa, t.CameraHelper = Oa, t.BoundingBoxHelper = Ba, t.BoxHelper = Ga, t.ArrowHelper = Xa, t.AxisHelper = Ya, t.WireframeGeometry = Ma, t.ParametricGeometry = qa, t.TetrahedronGeometry = Ja, t.OctahedronGeometry = Qa, t.IcosahedronGeometry = Ka, t.DodecahedronGeometry = $a, t.PolyhedronGeometry = Za, t.TubeGeometry = kr, t.TorusKnotGeometry = eo, t.TorusKnotBufferGeometry = to, t.TorusGeometry = no, t.TorusBufferGeometry = io, t.TextGeometry = ro, t.SphereBufferGeometry = La, t.SphereGeometry = Pa, t.RingGeometry = oo, t.RingBufferGeometry = ao, t.PlaneBufferGeometry = on, t.PlaneGeometry = so, t.LatheGeometry = ho, t.LatheBufferGeometry = co, t.ShapeGeometry = Wr, t.ExtrudeGeometry = jr, t.EdgesGeometry = Da, t.ConeGeometry = uo, t.ConeBufferGeometry = po, t.CylinderGeometry = lo, t.CylinderBufferGeometry = Ha, t.CircleBufferGeometry = fo, t.CircleGeometry = mo, t.BoxBufferGeometry = $i, t.BoxGeometry = za, t.ClosedSplineCurve3 = go, t.SplineCurve3 = vo, t.ArcCurve = yo, t.EllipseCurve = Pr, t.SplineCurve = Cr, t.CubicBezierCurve = Ur, t.QuadraticBezierCurve = Ir, t.LineCurve = Lr, t.Shape = Xr, t.ShapePath = qr, t.Path = Yr, t.Font = Zr, t.CurvePath = Rr, t.Curve = Ar, t.REVISION = "80", t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, t.CullFaceNone = c, t.CullFaceBack = h, t.CullFaceFront = l, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = u, t.PCFSoftShadowMap = p, t.FrontSide = d, t.BackSide = f, t.DoubleSide = m, t.FlatShading = g, t.SmoothShading = v, t.NoColors = y, t.FaceColors = 1, t.VertexColors = 2, t.NoBlending = x, t.NormalBlending = _, t.AdditiveBlending = w, t.SubtractiveBlending = b, t.MultiplyBlending = M, t.CustomBlending = E, t.AddEquation = T, t.SubtractEquation = 101, t.ReverseSubtractEquation = 102, t.MinEquation = 103, t.MaxEquation = 104, t.ZeroFactor = 200, t.OneFactor = 201, t.SrcColorFactor = 202, t.OneMinusSrcColorFactor = 203, t.SrcAlphaFactor = S, t.OneMinusSrcAlphaFactor = A, t.DstAlphaFactor = 206, t.OneMinusDstAlphaFactor = 207, t.DstColorFactor = 208, t.OneMinusDstColorFactor = 209, t.SrcAlphaSaturateFactor = 210, t.NeverDepth = L, t.AlwaysDepth = R, t.LessDepth = P, t.LessEqualDepth = C, t.EqualDepth = U, t.GreaterEqualDepth = I, t.GreaterDepth = D, t.NotEqualDepth = N, t.MultiplyOperation = F, t.MixOperation = O, t.AddOperation = z, t.NoToneMapping = B, t.LinearToneMapping = G, t.ReinhardToneMapping = H, t.Uncharted2ToneMapping = V, t.CineonToneMapping = k, t.UVMapping = 300, t.CubeReflectionMapping = j, t.CubeRefractionMapping = W, t.EquirectangularReflectionMapping = X, t.EquirectangularRefractionMapping = Y, t.SphericalReflectionMapping = q, t.CubeUVReflectionMapping = Z, t.CubeUVRefractionMapping = J, t.RepeatWrapping = Q, t.ClampToEdgeWrapping = K, t.MirroredRepeatWrapping = $, t.NearestFilter = tt, t.NearestMipMapNearestFilter = et, t.NearestMipMapLinearFilter = it, t.LinearFilter = nt, t.LinearMipMapNearestFilter = 1007, t.LinearMipMapLinearFilter = rt, t.UnsignedByteType = at, t.ByteType = 1010, t.ShortType = 1011, t.UnsignedShortType = ot, t.IntType = 1013, t.UnsignedIntType = 1014, t.FloatType = st, t.HalfFloatType = ct, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedInt248Type = 1020, t.AlphaFormat = 1021, t.RGBFormat = ht, t.RGBAFormat = lt, t.LuminanceFormat = 1024, t.LuminanceAlphaFormat = 1025, t.RGBEFormat = ut, t.DepthFormat = pt, t.DepthStencilFormat = dt, t.RGB_S3TC_DXT1_Format = 2001, t.RGBA_S3TC_DXT1_Format = 2002, t.RGBA_S3TC_DXT3_Format = 2003, t.RGBA_S3TC_DXT5_Format = 2004, t.RGB_PVRTC_4BPPV1_Format = 2100, t.RGB_PVRTC_2BPPV1_Format = 2101, t.RGBA_PVRTC_4BPPV1_Format = 2102, t.RGBA_PVRTC_2BPPV1_Format = 2103, t.RGB_ETC1_Format = 2151, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = ft, t.InterpolateLinear = mt, t.InterpolateSmooth = gt, t.ZeroCurvatureEnding = vt, t.ZeroSlopeEnding = yt, t.WrapAroundEnding = xt, t.TrianglesDrawMode = _t, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = wt, t.sRGBEncoding = bt, t.GammaEncoding = Mt, t.RGBEEncoding = Et, t.LogLuvEncoding = 3003, t.RGBM7Encoding = Tt, t.RGBM16Encoding = St, t.RGBDEncoding = At, t.BasicDepthPacking = Lt, t.RGBADepthPacking = Rt, t.CubeGeometry = za, t.Face4 = function (t, e, i, n, r, a, o) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Mi(t, e, i, r, a, o) }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = Dn, t.PointCloud = function (t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Sn(t, e) }, t.Particle = gn, t.ParticleSystem = function (t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Sn(t, e) }, t.PointCloudMaterial = function (t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Tn(t) }, t.ParticleBasicMaterial = function (t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Tn(t) }, t.ParticleSystemMaterial = function (t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Tn(t) }, t.Vertex = function (t, e, i) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new kt(t, e, i) }, t.GeometryUtils = xo, t.ImageUtils = _o, t.Projector = function () { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) { console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e) }, this.unprojectVector = function (t, e) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e) }, this.pickingRay = function (t, e) { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }, t.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function () { }, this.render = function () { }, this.setClearColor = function () { }, this.setSize = function () { } }, Object.defineProperty(t, "__esModule", { value: !0 }) }))