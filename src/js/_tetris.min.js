import { isHasWindowOpen, writeScoreToScoreBoard } from "./main.min.js"; import { setScore, local } from "./../appscript/classx.min.js"; const tetris_element = document.querySelector("#tetris"), panel_element = document.querySelector("#tetris-panel #panel-display"), scoreboard_element = document.querySelector("#tetris-panel #score-board"), title_element = document.querySelector("#tetris-panel #panel-title"), subtitle_element = document.querySelector("#tetris-panel #panel-sub-title"), action_element = document.querySelector("#tetris-panel #action"); function takeAction(e) { switch (gameStatus = e, e) { case GameStatus.isPause: title_element.textContent = "", subtitle_element.textContent = "", action_element.textContent = "Resume", tetris_element.classList.add("on-pause"), scoreboard_element.classList.add("on-pause"), panel_element.classList.remove("hide"); break; case GameStatus.isPlaying: tetris_element.classList.remove("on-pause"), scoreboard_element.classList.remove("on-pause"), panel_element.classList.add("hide"); break; case GameStatus.isGameOver: action_element.textContent = "Re-Play", title_element.textContent = "Game Over", subtitle_element.textContent = `score: ${score} points`, tetris_element.classList.add("on-pause"), panel_element.classList.remove("hide") } } action_element.addEventListener("click", (() => { switch (gameStatus) { case GameStatus.isPlaying: takeAction(GameStatus.isPause); break; case GameStatus.isGameOver: reset(); break; default: takeAction(GameStatus.isPlaying) } })); const GameStatus = { isPause: "isPause", isPlaying: "isPlaying", isGameOver: "isGameOver", isInit: "isInit", isWaiting: "isWaiting" }; let gameStatus = GameStatus.isInit; function gameOver(e) { if (local("user")) { gameStatus = GameStatus.isWaiting; const t = document.createElement("x-loading"); t.title = "Update Scoreboard", document.querySelector("body").appendChild(t), t.style.position = "absolute", t.style.left = "15%", t.style.top = "15%", t.style.width = "70%", setScore(e, (e => { e && (sessionStorage.setItem("scoreboard", "updated"), writeScoreToScoreBoard(), t.remove()), takeAction(GameStatus.isGameOver) })) } else takeAction(GameStatus.isGameOver) } const rowMaster = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], gridMaster = [[...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster], [...rowMaster]]; let grid = JSON.parse(JSON.stringify(gridMaster)); const shapes = { S: [[0, 0, 1], [1, 1, 1]], J: [[0, 0, 0], [0, 0, 2], [2, 2, 2]], L: [[0, 3, 0], [3, 3, 3]], O: [[0, 4, 0], [4, 4, 4]], U: [[5, 0, 0], [5, 5, 5]], T: [[6, 0, 0], [6, 6, 6]], Z: [[7, 7, 0], [0, 7, 0], [0, 7, 7]], Y: [[0, 8, 8], [0, 8, 0], [8, 8, 0]], I: [[0, 0, 0], [9, 9, 9], [0, 0, 0]], H: [[1, 2, 3], [8, 9, 4], [7, 6, 5]] }; let upcomingShape, interval, rndSeed = 1, currentShape = { x: 0, y: 0, shape: void 0 }, bag = [], bagIndex = 0, score = 0, speed = 900, draw = !0; function initialize(e = GameStatus.isInit) { let t = clearInterval(); gameStatus = e, nextShape(), currentShape.y = 0, moveDown(), removeShape(), updateScore(); t = setInterval((function () { gameStatus === GameStatus.isPlaying && (draw = !0, update(), 0 === speed && updateScore()) }), speed) } function update() { moveDown(), output(), updateScore() } function moveDown() { var e = { lose: !1, moved: !0, rowsCleared: 0 }; return removeShape(), currentShape.y++, collides(grid, currentShape) && (currentShape.y--, applyShape(), nextShape(), e.rowsCleared = clearRows(), collides(grid, currentShape) && (e.lose = !0, gameOver(score)), e.moved = !1), gameStatus === GameStatus.isPlaying && (applyShape(), score++), updateScore(), output(), e } function moveLeft() { removeShape(), currentShape.x--, collides(grid, currentShape) && currentShape.x++, applyShape() } function moveRight() { removeShape(), currentShape.x++, collides(grid, currentShape) && currentShape.x--, applyShape() } function rotateShape() { removeShape(), currentShape.shape = rotate(currentShape.shape, 1), collides(grid, currentShape) && (currentShape.shape = rotate(currentShape.shape, 3)), applyShape() } function clearRows() { for (var e = [], t = 0; t < grid.length; t++) { for (var a = !1, r = 0; r < grid[t].length; r++)0 === grid[t][r] && (a = !0); a || e.push(t) } 1 == e.length ? score += 400 : 2 == e.length ? score += 1e3 : 3 == e.length ? score += 3e3 : e.length >= 4 && (score += 12e3); for (var n = e.length - 1; n >= 0; n--)grid.splice(e[n], 1); for (; grid.length < gridMaster.length;)grid.unshift([...rowMaster]); return {} } function applyShape() { for (var e = 0; e < currentShape.shape.length; e++)for (var t = 0; t < currentShape.shape[e].length; t++)0 !== currentShape.shape[e][t] && (grid[currentShape.y + e][currentShape.x + t] = currentShape.shape[e][t]) } function removeShape() { for (var e = 0; e < currentShape.shape.length; e++)for (var t = 0; t < currentShape.shape[e].length; t++)0 !== currentShape.shape[e][t] && (grid[currentShape.y + e][currentShape.x + t] = 0) } function nextShape() { if (bagIndex += 1, 0 !== bag.length && bagIndex != bag.length || generateBag(), bagIndex == bag.length - 1) { var e = rndSeed; upcomingShape = randomProperty(shapes), rndSeed = e } else upcomingShape = shapes[bag[bagIndex + 1]]; currentShape.shape = shapes[bag[bagIndex]], currentShape.x = Math.floor(grid[0].length / 2) - Math.ceil(currentShape.shape[0].length / 2), currentShape.y = 0 } function generateBag() { bag = []; for (var e = "", t = 0; t < 7; t++) { for (var a = randomKey(shapes); -1 != e.indexOf(a);)a = randomKey(shapes); bag[t] = a, e += a } bagIndex = 0 } function reset() { score = 0, grid = JSON.parse(JSON.stringify(gridMaster)), takeAction(GameStatus.isPlaying) } function collides(e, t) { for (var a = 0; a < t.shape.length; a++)for (var r = 0; r < t.shape[a].length; r++)if (0 !== t.shape[a][r] && (void 0 === e[t.y + a] || void 0 === e[t.y + a][t.x + r] || 0 !== e[t.y + a][t.x + r])) return !0; return !1 } function rotate(e, t) { for (var a = 0; a < t; a++) { e = transpose(e); for (var r = 0; r < e.length; r++)e[r].reverse() } return e } function transpose(e) { return e[0].map((function (t, a) { return e.map((function (e) { return e[a] })) })) } function output() { if (draw) { for (var e = document.getElementById("output"), t = "", a = 0; a < grid.length; a++)t += "<p>," + grid[a].toString() + "<p>"; e.innerHTML = replaceColor(t) } } function replaceColor(e) { return e = replaceAll(e, ",0", ",<font class='text-0'>,X</font>"), e = replaceAll(e, ",1", ",<font class='text-1'>,Ю</font>"), e = replaceAll(e, ",2", ",<font class='text-2'>,Ж</font>"), e = replaceAll(e, ",3", ",<font class='text-3'>,ẞ</font>"), e = replaceAll(e, ",4", ",<font class='text-4'>,Њ</font>"), e = replaceAll(e, ",5", ",<font class='text-5'>,Я</font>"), e = replaceAll(e, ",6", ",<font class='text-6'>,€</font>"), e = replaceAll(e, ",7", ",<font class='text-7'>,¥</font>"), e = replaceAll(e, ",8", ",<font class='text-8'>,£</font>"), e = (e = replaceAll(e, ",9", ",<font class='text-9'>,Ǽ</font>")).replace(/,/g, " ") } function updateScore() { if (draw) { let e = document.querySelector("#tetris #score"), t = `\n        <span >Next :</span>\n        <span >Score: ${score}</span>\n        `; e.innerHTML = t; let a = document.querySelector("#tetris #next"); t = "<pre class='next-block'>"; for (let e = 0; e < upcomingShape.length; e++)t += "<p>," + upcomingShape[e] + "</p>"; t += "</pre>", a.innerHTML = replaceColor(t) } } function randomProperty(e) { return e[randomKey(e)] } function randomKey(e) { var t = Object.keys(e); return t[seededRandom(0, t.length)] } function replaceAll(e, t, a) { return e.replace(new RegExp(t, "g"), a) } function seededRandom(e, t) { t = t || 1, e = e || 0, rndSeed = (9301 * rndSeed + 49297) % 233280; var a = rndSeed / 233280; return Math.floor(e + a * (t - e)) } document.onLoad = initialize(), window.onkeydown = function (e) { isHasWindowOpen ? takeAction(GameStatus.isPause) : 32 == e.keyCode ? gameStatus === GameStatus.isPlaying ? takeAction(GameStatus.isPause) : gameStatus === GameStatus.isPause || gameStatus === GameStatus.isInit ? takeAction(GameStatus.isPlaying) : gameStatus === GameStatus.isGameOver && reset() : 38 == e.keyCode && gameStatus === GameStatus.isPlaying ? rotateShape() : 40 == e.keyCode && gameStatus === GameStatus.isPlaying ? moveDown() : 37 == e.keyCode && gameStatus === GameStatus.isPlaying ? moveLeft() : 39 == e.keyCode && gameStatus === GameStatus.isPlaying && moveRight(), output() }; export { initialize as initTetris, takeAction as setTetrisStatus, GameStatus as TetrisStatus }